; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	\SiteView\Ecc_Common\Base\funcGeneral.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0BB@FOOCKEH@Magellan?5MSWHEEL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06PIBNFFGP@MouseZ?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@NAALPGKC@MSWHEEL_ROLLMSG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@MKEAJGJE@MSH_WHEELSUPPORT_MSG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@DMMDPNAL@MSH_SCROLL_LINES_MSG?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BB@KEKMKJPM@Invalid?5DateTime?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BF@GPPHKJFN@Invalid?5DateTimeSpan?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LLAMLEHD@?$CFI64d?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05KCADNOJC@?$CF02ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0FG@EOHGAEB@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0IH@HPGJLCCK@?3Jan?3January?3Feb?3February?3Mar?3Ma@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GFHCPBMG@C?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@NLJHBKOA@HTTP_COOKIE?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04IEFHJGLE@cid?$DN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@JOODGAEE@SOFTWARE?2siteview?2siteviewecc?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@KEDFDEMF@root_path_7?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05ONEOBAM@?$CFs_?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09BMHOOPHN@oscmd?4ini?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@KFDBAEJB@?$CFs?2data?2TmpIniFile?2?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@ELOFBODM@?6info?5path?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@MBOFKFHK@?$CFd?9?$CFd?9?$CFd?5?$CFd?3?$CFd?3?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@GIIBNEJI@?$CFs?2groups?2log?4ini?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EFEFJCIK@IsOpen?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_06DKEIEPKC@IsOpen?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05GCIPIGEI@Debug?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGJHIBPE@?$CFd?D?j?$CFd?T?B?$CFd?H?U?5LogType?$DN?$CFd?5?$CFd?3?$CFd?3?$CFd@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@DONDPCJE@?$CFs?2logs?2log?4txt?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@GNDEBDFN@?$CFs?2monitormanager?2logs?2?$CFs?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BK@DHDFGIGF@?$CFs?2groups?2resource?4config?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@DHIAIDA@CompanyName?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08FLGELGHE@Resource?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HDFBFFKD@CompanyUrl?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BG@BFJACLLI@?$CFs?2fcgi?9bin?2mc?4config?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04BPKCJLI@SEID?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGPFGLLN@MonitorSchedule?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_09IPAEKDAI@localhost?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0L@HPMGBIOI@ServerHost?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BH@HHDGIIFB@0123456789abcdefABCDEF?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01DDCIFGEA@E?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _==
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextWindow@@YAPAUHWND__@@PAU1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DrawState@@YGHPAUHDC__@@PAUHBRUSH__@@P6GH0JIHH@ZJIHHHHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ocslen@@YAHPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ocscpy@@YAPA_WPA_WPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?A2WBSTR@@YAPA_WPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CComCriticalSection@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Term@CComCriticalSection@ATL@@QAEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@PAUHRSRC__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlGetStringResourceImage@ATL@@YAPBUATLSTRINGRESOURCEIMAGE@1@PAUHINSTANCE__@@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AtlFindResourceInstance@ATL@@YAPAUHINSTANCE__@@PBD0G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CWin32Heap@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CWin32Heap@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CWin32Heap@ATL@@UAEXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CWin32Heap@ATL@@UAEPAXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CWin32Heap@ATL@@UAEIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCWin32Heap@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?data@CStringData@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddRef@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLocked@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsShared@CStringData@ATL@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CStringData@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_GetEnvironmentVariableW@?$ChTraitsCRT@_W@ATL@@CGKPB_WPA_WK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@_W@ATL@@SAPB_WPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringMgr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Free@CFixedStringMgr@ATL@@UAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Reallocate@CFixedStringMgr@ATL@@UAEPAUCStringData@2@PAU32@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNilString@CFixedStringMgr@ATL@@UAEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clone@CFixedStringMgr@ATL@@UAEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringMgr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFixedStringLog@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnAllocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnReallocateSpill@CFixedStringLog@ATL@@UAEXHHPBUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFixedStringLog@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0IFixedStringLog@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTimeSpan@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDays@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTotalHours@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHours@CTimeSpan@ATL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTotalMinutes@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMinutes@CTimeSpan@ATL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTotalSeconds@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSeconds@CTimeSpan@ATL@@QBEJXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeSpan@CTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@HHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CTime@ATL@@QAE@ABU_SYSTEMTIME@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetYear@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMonth@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDay@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHour@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMinute@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSecond@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFileTimeSpan@ATL@@QAE@_J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTimeSpan@CFileTimeSpan@ATL@@QBE_JXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFileTime@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CFileTime@ATL@@QAE@_K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTime@CFileTime@ATL@@QBE_KXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetTime@CFileTime@ATL@@QAEX_K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTimeSpan@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FormatGmt@CTime@ATL@@QBE?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@2@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPair@CMapStringToString@@IAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPair@CMapStringToString@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@UtagSIZE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSize@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@UtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CRect@@QAE@PBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Width@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Height@CRect@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SwapLeftRight@CRect@@SGXPAUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveToY@CRect@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MoveToX@CRect@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HCRect@@QBE?AV0@UtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GCRect@@QBE?AV0@UtagPOINT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??HCRect@@QBE?AV0@UtagSIZE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??GCRect@@QBE?AV0@UtagSIZE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InflateRect@CRect@@QAEXPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DeflateRect@CRect@@QAEXPBUtagRECT@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNextPtr@CSimpleList@@QBEPAPAXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CNoTrackObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@CByteArray@@QBEEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@CByteArray@@QAEAAEH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@CWordArray@@QBEGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@CWordArray@@QAEAAGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@CDWordArray@@QBEKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@CDWordArray@@QAEAAKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@CUIntArray@@QBEIH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@CUIntArray@@QAEAAIH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@CPtrArray@@QBEPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@CPtrArray@@QAEAAPAXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@CObArray@@QBEPAVCObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@CObArray@@QAEAAPAVCObject@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetAt@CStringArray@@QBEABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ElementAt@CStringArray@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCount@CStringList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHeadPosition@CStringList@@QBEPAU__POSITION@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@CStringList@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAPAU__POSITION@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CObject@@IAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Serialize@CObject@@UAEXAAVCArchive@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3CObject@@SGXPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AssertValid@CObject@@UBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Dump@CObject@@UBEXAAVCDumpContext@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSimpleException@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSimpleException@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSimpleException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMemoryException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMemoryException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCNotSupportedException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CNotSupportedException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCInvalidArgException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CInvalidArgException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCArchiveException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CArchiveException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFileException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFileException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLoading@CArchive@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsStoring@CArchive@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CArchive@@QAEAAV0@E@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CArchive@@QAEAAV0@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??6CArchive@@QAEAAV0@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CArchive@@QAEAAV0@AAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CArchive@@QAEAAV0@AAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??5CArchive@@QAEAAV0@AAJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AfxGetApp@@YGPAVCWinApp@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCResourceException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CResourceException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCUserException@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CUserException@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCGdiObject@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHandle@CGdiObject@@QBEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CGdiObject@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCGdiObject@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CGdiObject@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FromHandle@CPen@@SGPAV1@PAUHPEN__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPen@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPen@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FromHandle@CBrush@@SGPAV1@PAUHBRUSH__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBrush@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBrush@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FromHandle@CFont@@SGPAV1@PAUHFONT__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCFont@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CFont@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FromHandle@CBitmap@@SGPAV1@PAUHBITMAP__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBitmap@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBitmap@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FromHandle@CPalette@@SGPAV1@PAUHPALETTE__@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCPalette@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CPalette@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCRgn@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CRgn@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHdc@CDC@@QBEPAUHDC__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCMenu@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMenu@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCMenu@@QBEPAUHMENU__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHmenu@CMenu@@QBEPAUHMENU__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BCWnd@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSafeHwnd@CWnd@@QBEPAUHWND__@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetParent@CWnd@@QBEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EnableActiveAccessibility@CWnd@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoDataExchange@CWnd@@MAEXPAVCDataExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?BeginModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?EndModalState@CWnd@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCStatic@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCButton@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CListBox@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCListBox@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetItemData@CListBox@@QAEHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCCheckListBox@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CCheckListBox@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCComboBox@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetItemData@CComboBox@@QBEKH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetItemData@CComboBox@@QAEHHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCEdit@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCScrollBar@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHelpMode@CWinApp@@QAEXW4AFX_HELP_TYPE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IN6_IS_ADDR_UNSPECIFIED@@YAHPBUin6_addr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IN6_IS_ADDR_LOOPBACK@@YAHPBUin6_addr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IN6_IS_ADDR_MULTICAST@@YAHPBUin6_addr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IN6_SET_ADDR_UNSPECIFIED@@YAXPAUin6_addr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IN6_SET_ADDR_LOOPBACK@@YAXPAUin6_addr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CSocketAddr@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSocketAddr@ATL@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSocketAddr@ATL@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindAddr@CSocketAddr@ATL@@QAEHPBD0HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindAddr@CSocketAddr@ATL@@QAEHPBDHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getaddrinfo@CSocketAddr@ATL@@QBEQAUaddrinfo@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPeerName@CAsyncSocket@@QAEHPAUsockaddr@@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSockName@CAsyncSocket@@QAEHPAUsockaddr@@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSockOpt@CAsyncSocket@@QAEHHPAXPAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Bind@CAsyncSocket@@QAEHPBUsockaddr@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Connect@CAsyncSocket@@QAEHPBUsockaddr@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ReceiveFrom@CAsyncSocket@@QAEHPAXHPAUsockaddr@@PAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendTo@CAsyncSocket@@QAEHPBXHPBUsockaddr@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_exception@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_exception@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemchr
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcmp
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?length@?$char_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$char_traits@_W@std@@SAPA_WPA_WI_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?to_char_type@?$char_traits@_W@std@@SA_WABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?to_int_type@?$char_traits@_W@std@@SAGAB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?eq_int_type@?$char_traits@_W@std@@SA_NABG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?eof@?$char_traits@_W@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1domain_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gdomain_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1overflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Goverflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1underflow_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gunderflow_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1range_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Grange_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0_Timevec@std@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1_Timevec@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4_Timevec@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1locale@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@_W@std@@YAD_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@_W@std@@YA_WDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$codecvt@_WDH@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$codecvt@_WDH@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$codecvt@_WDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_in@?$codecvt@_WDH@std@@MBEHAAHPBD1AAPBDPA_W3AAPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_out@?$codecvt@_WDH@std@@MBEHAAHPB_W1AAPB_WPAD3AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_unshift@?$codecvt@_WDH@std@@MBEHAAHPAD1AAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_length@?$codecvt@_WDH@std@@MBEHABHPBD1I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_always_noconv@?$codecvt@_WDH@std@@MBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_max_length@?$codecvt@_WDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_encoding@?$codecvt@_WDH@std@@MBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$codecvt@_WDH@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?table@?$ctype@D@std@@IBEPBFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?widen@?$ctype@_W@std@@QBE_WD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$ctype@_W@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$ctype@_W@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$ctype@_W@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_is@?$ctype@_W@std@@MBE_NF_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Dowiden@?$ctype@_W@std@@IBE_WD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_widen@?$ctype@_W@std@@MBE_WD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Donarrow@?$ctype@_W@std@@IBED_WD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_narrow@?$ctype@_W@std@@MBED_WD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?clear@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setstate@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?eof@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?exceptions@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setf@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?unsetf@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?precision@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ?CheckTempPath@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetInstallRootSCPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetCIDFromCookie@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetInstallRootPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WSA_Init@@YAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WSA_Free@@YAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DFNParser_GetPrivateProfileString@@YAKPBD00PADK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DFNParser_GetPrivateProfileInt@@YAHPBD0H0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DFN_GetPrivateProfileInt@@YAHPBD0H0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DFN_WritePrivateProfileString@@YAHPBD000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetCountByMark@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetProfileIntBy@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetLeftStringByMark@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TimeToString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@VCTime@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetValueFromList@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@AAVCStringList@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateListByStringandMark@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCStringList@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?WriteLog@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetProfileStringBy@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetCompanyName@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetCompanyUrl@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SortList@@YAXAAVCStringList@@0H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_E_rec@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_rec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_rec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Sort@@YAXPAU_rec@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4_rec@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FuncGetRightString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeStringListByChar@@YA_NAAVCStringList@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?MakeCharByString@@YA_NPADAAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSEIP@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetResourceValue@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??B?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetLength@?$CSimpleStringT@D$00@ATL@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Preallocate@?$CSimpleStringT@D$00@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ReleaseBuffer@?$CSimpleStringT@D$00@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CompareNoCase@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Right@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?AppendFormat@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?LoadStringA@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$_String_val@_WV?$allocator@_W@std@@@std@@IAE@V?$allocator@_W@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@_W@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$codecvt@DDH@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$numpunct@_W@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_decimal_point@?$numpunct@_W@std@@MBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_thousands_sep@?$numpunct@_W@std@@MBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_grouping@?$numpunct@_W@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_falsename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_truename@?$numpunct@_W@std@@MBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$num_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setstate@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?rdbuf@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_ostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?put@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_iostream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glocale@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_iostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$CSimpleStringT@D$00@ATL@@QAE@PAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$CSimpleStringT@D$00@ATL@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$CSimpleStringT@D$00@ATL@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4?$CSimpleStringT@D$00@ATL@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4?$CSimpleStringT@D$00@ATL@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$CSimpleStringT@D$00@ATL@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetManager@?$CSimpleStringT@D$00@ATL@@QBEPAUIAtlStringMgr@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetString@?$CSimpleStringT@D$00@ATL@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?StringLength@?$CSimpleStringT@D$00@ATL@@SAHPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetData@?$CSimpleStringT@D$00@ATL@@ABEPAUCStringData@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PrepareWrite@?$CSimpleStringT@D$00@ATL@@AAEPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetLength@?$CSimpleStringT@D$00@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?AppendFormatV@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?FormatV@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEXPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?LoadStringA@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEHPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CheckImplicitLoad@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAE_NPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindStringResourceInstance@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUHINSTANCE__@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetDefaultManager@?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@SAPAUIAtlStringMgr@ATL@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringCompare@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringCompareIgnore@?$ChTraitsCRT@D@ATL@@SAHPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?StringFindString@?$ChTraitsCRT@D@ATL@@SAPBDPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pubsync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?gptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?egptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?gbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?epptr@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IBEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pbump@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDIIII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?falsename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?truename@?$numpunct@_W@std@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Tidy@?$numpunct@_W@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getifld@?$num_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@2@1HABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getffld@?$num_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAHPADAAV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@2@1ABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ffmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Fput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPBDIIII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ifmt@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Iput@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@AAVios_base@2@_WPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Put@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Rep@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?clear@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$CSimpleStringT@D$00@ATL@@QAE@PBDHPAUIAtlStringMgr@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?AppendChar@?$CSimpleStringT@D$00@ATL@@QAEXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ReleaseBufferSetLength@?$CSimpleStringT@D$00@ATL@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetString@?$CSimpleStringT@D$00@ATL@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetString@?$CSimpleStringT@D$00@ATL@@QAEXPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Attach@?$CSimpleStringT@D$00@ATL@@AAEXPAUCStringData@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?PrepareWrite2@?$CSimpleStringT@D$00@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CloneData@?$CSimpleStringT@D$00@ATL@@CAPAUCStringData@2@PAU32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetFormattedLength@?$ChTraitsCRT@D@ATL@@SAHPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Format@?$ChTraitsCRT@D@ATL@@SAHPADPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBaseTypeLength@?$ChTraitsCRT@D@ATL@@SAHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ConvertToBaseType@?$ChTraitsCRT@D@ATL@@SAXPADHPB_WH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Putgrouped@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?decimal_point@?$numpunct@_W@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?thousands_sep@?$numpunct@_W@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?grouping@?$numpunct@_W@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Putc@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Putgrouped@?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@2@V32@PBDI_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?tie@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBEPAV?$basic_ostream@_WU?$char_traits@_W@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Empty@?$CSimpleStringT@D$00@ATL@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CopyChars@?$CSimpleStringT@D$00@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?CopyCharsOverlapped@?$CSimpleStringT@D$00@ATL@@SAXPADPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ThrowMemoryException@?$CSimpleStringT@D$00@ATL@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Fork@?$CSimpleStringT@D$00@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?Reallocate@?$CSimpleStringT@D$00@ATL@@AAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Myptr@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPA_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@AAE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAE_NPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@_W@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0IPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$use_facet@V?$numpunct@_W@std@@@std@@YAABV?$numpunct@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Getloctxt@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@YAHAAV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0IPB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9DU?$char_traits@D@std@@@std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocbyte@D@std@@YADDABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?9_WU?$char_traits@_W@std@@@std@@YA_NABV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??A?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEAB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getcat@?$numpunct@_W@std@@SAIPAPBVfacet@locale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?fill@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$numpunct@D@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$numpunct@_W@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$numpunct@_W@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMemoryException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBrush@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?buff@?1??gai_strerrorA@@9@4PADA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_7CResourceException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPen@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFont@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_7CListBox@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CGdiObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?buff@?1??gai_strerrorW@@9@4PA_WA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_7CArchiveException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??_7CNoTrackObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_7CComboBox@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CMenu@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CUserException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7CCheckListBox@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CStatic@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CButton@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFileException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CNotSupportedException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CScrollBar@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CObject@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CPalette@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSimpleException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBitmap@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CRgn@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFixedStringMgr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7IFixedStringLog@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CSocketAddr@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_7CWin32Heap@ATL@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CInvalidArgException@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@_W@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7underflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7overflow_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Stz@?$fpos@H@std@@0HA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_S?$codecvt@_WDH@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7bad_exception@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7range_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7domain_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@_W@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CEdit@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_strthunks@ATL@@3U_AtlStringThunks@1@A		; ATL::_strthunks
PUBLIC	?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWThunk
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
PUBLIC	?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z	; ATL::CompareStringWThunk
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWThunk
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?lstrcmpiWThunk@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWThunk
PUBLIC	?CharLowerWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWThunk
PUBLIC	?CharUpperWThunk@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWThunk
PUBLIC	?m_bInitFailed@CAtlBaseModule@ATL@@2_NA		; ATL::CAtlBaseModule::m_bInitFailed
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?g_pfnGetThreadACP@ATL@@3P6GIXZA		; ATL::g_pfnGetThreadACP
PUBLIC	?_AtlGetThreadACPThunk@ATL@@YGIXZ		; ATL::_AtlGetThreadACPThunk
PUBLIC	?Millisecond@CFileTime@ATL@@2_KB		; ATL::CFileTime::Millisecond
PUBLIC	?Second@CFileTime@ATL@@2_KB			; ATL::CFileTime::Second
PUBLIC	?Minute@CFileTime@ATL@@2_KB			; ATL::CFileTime::Minute
PUBLIC	?Hour@CFileTime@ATL@@2_KB			; ATL::CFileTime::Hour
PUBLIC	?Day@CFileTime@ATL@@2_KB			; ATL::CFileTime::Day
PUBLIC	?Week@CFileTime@ATL@@2_KB			; ATL::CFileTime::Week
PUBLIC	?szInvalidDateTime@ATL@@3QBDB			; ATL::szInvalidDateTime
PUBLIC	??_C@_0BB@KEKMKJPM@Invalid?5DateTime?$AA@	; `string'
PUBLIC	?szInvalidDateTimeSpan@ATL@@3QBDB		; ATL::szInvalidDateTimeSpan
PUBLIC	??_C@_0BF@GPPHKJFN@Invalid?5DateTimeSpan?$AA@	; `string'
PUBLIC	?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
PUBLIC	?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A ; ATL::CFixedStringMgr::s_pLog
;	COMDAT ?m_bInitFailed@CAtlBaseModule@ATL@@2_NA
_BSS	SEGMENT
?m_bInitFailed@CAtlBaseModule@ATL@@2_NA DB 01H DUP (?)	; ATL::CAtlBaseModule::m_bInitFailed
_BSS	ENDS
;	COMDAT ?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A
_BSS	SEGMENT
?s_pLog@CFixedStringMgr@ATL@@2PAVIFixedStringLog@2@A DD 01H DUP (?) ; ATL::CFixedStringMgr::s_pLog
_BSS	ENDS
;	COMDAT ?g_pfnGetThreadACP@ATL@@3P6GIXZA
_DATA	SEGMENT
?g_pfnGetThreadACP@ATL@@3P6GIXZA DD FLAT:?_AtlGetThreadACPThunk@ATL@@YGIXZ ; ATL::g_pfnGetThreadACP
_DATA	ENDS
;	COMDAT ?_strthunks@ATL@@3U_AtlStringThunks@1@A
_DATA	SEGMENT
?_strthunks@ATL@@3U_AtlStringThunks@1@A DD FLAT:?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ; ATL::_strthunks
	DD	FLAT:?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
	DD	FLAT:?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
	DD	FLAT:?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
	DD	FLAT:?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_DATA	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB DB 01H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB
CONST	SEGMENT
?c_bIsMFCDLLTraits@?$_MFCDLLTraitsCheck@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@_CSTRING_IMPL_@ATL@@2_NB DB 01H ; ATL::_CSTRING_IMPL_::_MFCDLLTraitsCheck<wchar_t,StrTraitMFC_DLL<wchar_t,ATL::ChTraitsCRT<wchar_t> > >::c_bIsMFCDLLTraits
CONST	ENDS
;	COMDAT ?Millisecond@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Millisecond@CFileTime@ATL@@2_KB DQ 0000000000002710H	; ATL::CFileTime::Millisecond
CONST	ENDS
;	COMDAT ?Second@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Second@CFileTime@ATL@@2_KB DQ 0000000000989680H	; ATL::CFileTime::Second
CONST	ENDS
;	COMDAT ?Minute@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Minute@CFileTime@ATL@@2_KB DQ 0000000023c34600H	; ATL::CFileTime::Minute
CONST	ENDS
;	COMDAT ?Hour@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Hour@CFileTime@ATL@@2_KB DQ 0000000861c46800H		; ATL::CFileTime::Hour
CONST	ENDS
;	COMDAT ?Day@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Day@CFileTime@ATL@@2_KB DQ 000000c92a69c000H		; ATL::CFileTime::Day
CONST	ENDS
;	COMDAT ?Week@CFileTime@ATL@@2_KB
CONST	SEGMENT
?Week@CFileTime@ATL@@2_KB DQ 0000058028e44000H		; ATL::CFileTime::Week
CONST	ENDS
;	COMDAT ??_C@_0BB@KEKMKJPM@Invalid?5DateTime?$AA@
CONST	SEGMENT
??_C@_0BB@KEKMKJPM@Invalid?5DateTime?$AA@ DB 'Invalid DateTime', 00H ; `string'
CONST	ENDS
;	COMDAT ?szInvalidDateTime@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTime@ATL@@3QBDB DD FLAT:??_C@_0BB@KEKMKJPM@Invalid?5DateTime?$AA@ ; ATL::szInvalidDateTime
CONST	ENDS
;	COMDAT ??_C@_0BF@GPPHKJFN@Invalid?5DateTimeSpan?$AA@
CONST	SEGMENT
??_C@_0BF@GPPHKJFN@Invalid?5DateTimeSpan?$AA@ DB 'Invalid DateTimeSpan', 00H ; `string'
CONST	ENDS
;	COMDAT ?szInvalidDateTimeSpan@ATL@@3QBDB
CONST	SEGMENT
?szInvalidDateTimeSpan@ATL@@3QBDB DD FLAT:??_C@_0BF@GPPHKJFN@Invalid?5DateTimeSpan?$AA@ ; ATL::szInvalidDateTimeSpan
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
EXTRN	__imp__malloc:NEAR
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC NEAR		; ATL::CCRTAllocator::Allocate, COMDAT

; 31   : 		return malloc(nBytes);

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__malloc
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
EXTRN	__imp__free:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC NEAR		; ATL::CCRTAllocator::Free, COMDAT

; 36   : 		free(p);

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__free
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
PUBLIC	?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
EXTRN	__imp___resetstkoflw:NEAR
EXTRN	__alloca_probe:NEAR
EXTRN	__except_handler3:NEAR
EXTRN	__except_list:DWORD
;	COMDAT CONST
CONST	SEGMENT
$T66242	DD	0ffffffffH
	DD	FLAT:$L66237
	DD	FLAT:$L66238
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z
_TEXT	SEGMENT
_p$25175 = -28						; size = 4
__$SEHRec$ = -24					; size = 24
_Size$ = 8						; size = 4
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable, COMDAT

; 331  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 OFFSET FLAT:$T66242
  0000a	68 00 00 00 00	 push	 OFFSET FLAT:__except_handler3
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00015	50		 push	 eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp

; 332  :     bool bStackAvailable = true;

  00026	b3 01		 mov	 bl, 1

; 333  : 
; 334  :     __try

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 335  :     {
; 336  :         PVOID p = _alloca(Size + _ATL_STACK_MARGIN);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _Size$[ebp]
  00032	05 03 20 00 00	 add	 eax, 8195		; 00002003H
  00037	83 e0 fc	 and	 eax, -4			; fffffffcH
  0003a	e8 00 00 00 00	 call	 __alloca_probe
  0003f	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00042	8b c4		 mov	 eax, esp
  00044	89 45 e4	 mov	 DWORD PTR _p$25175[ebp], eax
  00047	eb 1f		 jmp	 SHORT $L66247
$L66237:

; 337  :         (p);
; 338  :     }
; 339  :     __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
; 340  :                    EXCEPTION_EXECUTE_HANDLER :
; 341  :                    EXCEPTION_CONTINUE_SEARCH)

  00049	8b 45 ec	 mov	 eax, DWORD PTR __$SEHRec$[ebp+4]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00050	33 d2		 xor	 edx, edx
  00052	3d fd 00 00 c0	 cmp	 eax, -1073741571	; c00000fdH
  00057	0f 94 c2	 sete	 dl
  0005a	8b c2		 mov	 eax, edx
$L66239:
  0005c	c3		 ret	 0
$L66238:
  0005d	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 342  :     {
; 343  :         bStackAvailable = false;

  00060	32 db		 xor	 bl, bl

; 344  :         _resetstkoflw();

  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___resetstkoflw
$L66247:
  00068	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$SEHRec$[ebp+20], -1

; 345  :     }
; 346  :     return bStackAvailable;

  0006f	8a c3		 mov	 al, bl

; 347  : }

  00071	8d 65 d8	 lea	 esp, DWORD PTR [ebp-40]
  00074	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
_TEXT	ENDS
PUBLIC	?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z	; InterlockedExchangePointer
EXTRN	__imp__InterlockedExchange@8:NEAR
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z
_TEXT	SEGMENT
_pp$ = 8						; size = 4
_pNew$ = 12						; size = 4
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z PROC NEAR	; InterlockedExchangePointer, COMDAT

; 92   : 	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__InterlockedExchange@8
?InterlockedExchangePointer@@YGPAXPAPAXPAX@Z ENDP	; InterlockedExchangePointer
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPFake@ATL@@YGIXZ		; ATL::_AtlGetThreadACPFake
EXTRN	__imp__GetACP@0:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
EXTRN	__imp__GetLocaleInfoA@16:NEAR
EXTRN	__imp__GetThreadLocale@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPFake@ATL@@YGIXZ
_TEXT	SEGMENT
_szACP$ = -12						; size = 7
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPFake@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPFake, COMDAT

; 101  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	56		 push	 esi
  00009	89 44 24 0c	 mov	 DWORD PTR __$ArrayPad$[esp+16], eax

; 102  : 	UINT nACP = 0;

  0000d	33 f6		 xor	 esi, esi

; 103  : 
; 104  : 	LCID lcidThread = ::GetThreadLocale();

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetThreadLocale@0

; 105  : 
; 106  : 	char szACP[7];
; 107  : 	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
; 108  : 	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
; 109  : 	// executed on Windows 2000.
; 110  : 	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)

  00015	6a 07		 push	 7
  00017	8d 4c 24 08	 lea	 ecx, DWORD PTR _szACP$[esp+20]
  0001b	51		 push	 ecx
  0001c	68 04 10 00 00	 push	 4100			; 00001004H
  00021	50		 push	 eax
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16
  00028	85 c0		 test	 eax, eax
  0002a	74 21		 je	 SHORT $L66257

; 111  : 	{
; 112  : 		char* pch = szACP;
; 113  : 		while (*pch != '\0')

  0002c	8a 44 24 04	 mov	 al, BYTE PTR _szACP$[esp+16]
  00030	84 c0		 test	 al, al
  00032	8d 4c 24 04	 lea	 ecx, DWORD PTR _szACP$[esp+16]
  00036	74 15		 je	 SHORT $L66257
$L25220:

; 114  : 		{
; 115  : 			nACP *= 10;
; 116  : 			nACP += *pch++ - '0';

  00038	0f be c0	 movsx	 eax, al
  0003b	8d 14 b6	 lea	 edx, DWORD PTR [esi+esi*4]
  0003e	41		 inc	 ecx
  0003f	8d 74 50 d0	 lea	 esi, DWORD PTR [eax+edx*2-48]
  00043	8a 01		 mov	 al, BYTE PTR [ecx]
  00045	84 c0		 test	 al, al
  00047	75 ef		 jne	 SHORT $L25220

; 117  : 		}
; 118  : 	}
; 119  : 	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
; 120  : 	if (nACP == 0)

  00049	85 f6		 test	 esi, esi
  0004b	75 14		 jne	 SHORT $L66258
$L66257:

; 121  : 		nACP = ::GetACP();

  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetACP@0
  00053	5e		 pop	 esi

; 122  : 
; 123  : 	return nACP;
; 124  : }

  00054	8b 4c 24 08	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+12]
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00060	c3		 ret	 0
$L66258:
  00061	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+16]
  00065	8b c6		 mov	 eax, esi
  00067	5e		 pop	 esi
  00068	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00070	c3		 ret	 0
?_AtlGetThreadACPFake@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPFake
_TEXT	ENDS
PUBLIC	?_AtlGetThreadACPReal@ATL@@YGIXZ		; ATL::_AtlGetThreadACPReal
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPReal@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetThreadACPReal@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPReal, COMDAT

; 128  : 	return( CP_THREAD_ACP );

  00000	b8 03 00 00 00	 mov	 eax, 3

; 129  : }

  00005	c3		 ret	 0
?_AtlGetThreadACPReal@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPReal
_TEXT	ENDS
EXTRN	__imp__GetVersionExA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetThreadACPThunk@ATL@@YGIXZ
_TEXT	SEGMENT
_ver$ = -152						; size = 148
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?_AtlGetThreadACPThunk@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetThreadACPThunk, COMDAT

; 134  : {

  00000	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 84 24 94 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+152], eax

; 135  : 	OSVERSIONINFO ver;
; 136  : 	ATLGETTHREADACP pfnGetThreadACP;
; 137  : 
; 138  : 	ver.dwOSVersionInfoSize = sizeof( ver );
; 139  : 	::GetVersionEx( &ver );

  00012	8d 04 24	 lea	 eax, DWORD PTR _ver$[esp+152]
  00015	50		 push	 eax
  00016	c7 44 24 04 94
	00 00 00	 mov	 DWORD PTR _ver$[esp+156], 148 ; 00000094H
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 140  : 	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )

  00024	83 7c 24 10 02	 cmp	 DWORD PTR _ver$[esp+168], 2
  00029	75 0c		 jne	 SHORT $L25230
  0002b	83 7c 24 04 05	 cmp	 DWORD PTR _ver$[esp+156], 5

; 141  : 	{
; 142  : 		// On Win2K, CP_THREAD_ACP is supported
; 143  : 		pfnGetThreadACP = _AtlGetThreadACPReal;

  00030	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPReal@ATL@@YGIXZ ; ATL::_AtlGetThreadACPReal
  00035	73 05		 jae	 SHORT $L25231
$L25230:

; 144  : 	}
; 145  : 	else
; 146  : 	{
; 147  : 		pfnGetThreadACP = _AtlGetThreadACPFake;

  00037	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?_AtlGetThreadACPFake@ATL@@YGIXZ ; ATL::_AtlGetThreadACPFake
$L25231:

; 148  : 	}
; 149  : 	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

  0003c	50		 push	 eax
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 150  : 
; 151  : 	return( g_pfnGetThreadACP() );

  00048	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 152  : }

  0004e	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  00055	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005a	81 c4 98 00 00
	00		 add	 esp, 152		; 00000098H
  00060	c3		 ret	 0
?_AtlGetThreadACPThunk@ATL@@YGIXZ ENDP			; ATL::_AtlGetThreadACPThunk
_TEXT	ENDS
PUBLIC	?_AtlGetConversionACP@ATL@@YGIXZ		; ATL::_AtlGetConversionACP
; Function compile flags: /Ogty
;	COMDAT ?_AtlGetConversionACP@ATL@@YGIXZ
_TEXT	SEGMENT
?_AtlGetConversionACP@ATL@@YGIXZ PROC NEAR		; ATL::_AtlGetConversionACP, COMDAT

; 158  : 	return( g_pfnGetThreadACP() );

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
?_AtlGetConversionACP@ATL@@YGIXZ ENDP			; ATL::_AtlGetConversionACP
_TEXT	ENDS
PUBLIC	?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z		; AtlA2WHelper
EXTRN	__imp__MultiByteToWideChar@24:NEAR
; Function compile flags: /Ogty
;	COMDAT ?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z
_TEXT	SEGMENT
_lpw$ = 8						; size = 4
_lpa$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z PROC NEAR		; AtlA2WHelper, COMDAT

; 554  : {

  00000	56		 push	 esi

; 555  : 	ATLASSERT(lpa != NULL);
; 556  : 	ATLASSERT(lpw != NULL);
; 557  : 	if (lpw == NULL || lpa == NULL)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _lpw$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 2d		 je	 SHORT $L25363
  00009	8b 44 24 0c	 mov	 eax, DWORD PTR _lpa$[esp]
  0000d	85 c0		 test	 eax, eax
  0000f	74 25		 je	 SHORT $L25363

; 559  : 	// verify that no illegal character present
; 560  : 	// since lpw was allocated based on the size of lpa
; 561  : 	// don't worry about the number of chars
; 562  : 	lpw[0] = '\0';
; 563  : 	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);

  00011	8b 4c 24 10	 mov	 ecx, DWORD PTR _nChars$[esp]
  00015	8b 54 24 14	 mov	 edx, DWORD PTR _acp$[esp]
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	6a ff		 push	 -1
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	52		 push	 edx
  00021	66 c7 06 00 00	 mov	 WORD PTR [esi], 0
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 564  : 	if(ret == 0)

  0002c	f7 d8		 neg	 eax
  0002e	1b c0		 sbb	 eax, eax
  00030	23 c6		 and	 eax, esi
  00032	5e		 pop	 esi

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);
; 567  : 		return NULL;
; 568  : 	}		
; 569  : 	return lpw;
; 570  : }

  00033	c2 10 00	 ret	 16			; 00000010H
$L25363:

; 558  : 		return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	5e		 pop	 esi

; 565  : 	{
; 566  : 		ATLASSERT(FALSE);
; 567  : 		return NULL;
; 568  : 	}		
; 569  : 	return lpw;
; 570  : }

  00039	c2 10 00	 ret	 16			; 00000010H
?AtlA2WHelper@@YGPA_WPA_WPBDHI@Z ENDP			; AtlA2WHelper
_TEXT	ENDS
PUBLIC	?AtlW2AHelper@@YGPADPADPB_WHI@Z			; AtlW2AHelper
EXTRN	__imp__WideCharToMultiByte@32:NEAR
; Function compile flags: /Ogty
;	COMDAT ?AtlW2AHelper@@YGPADPADPB_WHI@Z
_TEXT	SEGMENT
_lpa$ = 8						; size = 4
_lpw$ = 12						; size = 4
_nChars$ = 16						; size = 4
_acp$ = 20						; size = 4
?AtlW2AHelper@@YGPADPADPB_WHI@Z PROC NEAR		; AtlW2AHelper, COMDAT

; 573  : {

  00000	56		 push	 esi

; 574  : 	ATLASSERT(lpw != NULL);
; 575  : 	ATLASSERT(lpa != NULL);
; 576  : 	if (lpa == NULL || lpw == NULL)

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _lpa$[esp]
  00005	85 f6		 test	 esi, esi
  00007	74 2f		 je	 SHORT $L25376
  00009	8b 44 24 0c	 mov	 eax, DWORD PTR _lpw$[esp]
  0000d	85 c0		 test	 eax, eax
  0000f	74 27		 je	 SHORT $L25376

; 578  : 	// verify that no illegal character present
; 579  : 	// since lpa was allocated based on the size of lpw
; 580  : 	// don't worry about the number of chars
; 581  : 	lpa[0] = '\0';
; 582  : 	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);

  00011	8b 4c 24 10	 mov	 ecx, DWORD PTR _nChars$[esp]
  00015	8b 54 24 14	 mov	 edx, DWORD PTR _acp$[esp]
  00019	6a 00		 push	 0
  0001b	6a 00		 push	 0
  0001d	51		 push	 ecx
  0001e	56		 push	 esi
  0001f	6a ff		 push	 -1
  00021	50		 push	 eax
  00022	6a 00		 push	 0
  00024	52		 push	 edx
  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 583  : 	if(ret == 0)

  0002e	f7 d8		 neg	 eax
  00030	1b c0		 sbb	 eax, eax
  00032	23 c6		 and	 eax, esi
  00034	5e		 pop	 esi

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);
; 586  : 		return NULL;
; 587  : 	}
; 588  : 	return lpa;
; 589  : }

  00035	c2 10 00	 ret	 16			; 00000010H
$L25376:

; 577  : 		return NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	5e		 pop	 esi

; 584  : 	{
; 585  : 		ATLASSERT(FALSE);
; 586  : 		return NULL;
; 587  : 	}
; 588  : 	return lpa;
; 589  : }

  0003b	c2 10 00	 ret	 16			; 00000010H
?AtlW2AHelper@@YGPADPADPB_WHI@Z ENDP			; AtlW2AHelper
_TEXT	ENDS
PUBLIC	?AtlThrow@ATL@@YGXJ@Z				; ATL::AtlThrow
EXTRN	?AfxThrowMemoryException@@YGXXZ:NEAR		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:NEAR		; AfxThrowOleException
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrow@ATL@@YGXJ@Z
_TEXT	SEGMENT
_hr$ = 8						; size = 4
?AtlThrow@ATL@@YGXJ@Z PROC NEAR				; ATL::AtlThrow, COMDAT

; 62   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );
; 63   : #ifdef _AFX
; 64   : 	if( hr == E_OUTOFMEMORY )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _hr$[esp-4]
  00004	3d 0e 00 07 80	 cmp	 eax, -2147024882	; 8007000eH
  00009	75 05		 jne	 SHORT $L25738

; 65   : 	{
; 66   : 		AfxThrowMemoryException();

  0000b	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException
$L25738:

; 67   : 	}
; 68   : 	else
; 69   : 	{
; 70   : 		AfxThrowOleException( hr );

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$L66280:
  00016	cc		 int	 3
?AtlThrow@ATL@@YGXJ@Z ENDP				; ATL::AtlThrow
_TEXT	ENDS
PUBLIC	?AtlThrowLastWin32@ATL@@YGXXZ			; ATL::AtlThrowLastWin32
EXTRN	__imp__GetLastError@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?AtlThrowLastWin32@ATL@@YGXXZ
_TEXT	SEGMENT
?AtlThrowLastWin32@ATL@@YGXXZ PROC NEAR			; ATL::AtlThrowLastWin32, COMDAT

; 81   : 	DWORD dwError = ::GetLastError();

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 82   : 	AtlThrow( HRESULT_FROM_WIN32( dwError ) );

  00006	85 c0		 test	 eax, eax
  00008	7e 0a		 jle	 SHORT $L66284
  0000a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0000f	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$L66284:
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L66285:
  0001a	cc		 int	 3
?AtlThrowLastWin32@ATL@@YGXXZ ENDP			; ATL::AtlThrowLastWin32
_TEXT	ENDS
PUBLIC	?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z	; ATL::_AtlInstallStringThunk
PUBLIC	?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
PUBLIC	??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
EXTRN	__imp__GetVersion@0:NEAR
;	COMDAT ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
_BSS	SEGMENT
?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA DB 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
_BSS	ENDS
;	COMDAT ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51
_BSS	SEGMENT
??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51 DD 01H DUP (?) ; `ATL::_AtlInstallStringThunk'::`2'::`local static guard'
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
_BSS	ENDS
;	COMDAT ?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z
_TEXT	SEGMENT
_ppThunk$ = 8						; size = 4
_pfnWin9x$ = 12						; size = 4
_pfnNT$ = 16						; size = 4
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z PROC NEAR	; ATL::_AtlInstallStringThunk, COMDAT

; 116  : #pragma warning (push)
; 117  : #pragma warning (disable : 4640)	// construction of local static object is not thread-safe
; 118  : 
; 119  : 	static bool s_bWin9x = (::GetVersion()&0x80000000) != 0;

  00000	f6 05 00 00 00
	00 01		 test	 BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00007	75 19		 jne	 SHORT $L66291
  00009	83 0d 00 00 00
	00 01		 or	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	24 01		 and	 al, 1
  0001b	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  00020	eb 05		 jmp	 SHORT $L26698
$L66291:
  00022	a0 00 00 00 00	 mov	 al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L26698:

; 120  : 	
; 121  : #pragma warning (pop)
; 122  : 
; 123  : 	void* pfn;
; 124  : 	if (s_bWin9x)

  00027	84 c0		 test	 al, al

; 125  : 		pfn = pfnWin9x;

  00029	8b 44 24 08	 mov	 eax, DWORD PTR _pfnWin9x$[esp-4]
  0002d	75 04		 jne	 SHORT $L26701

; 126  : 	else
; 127  : 	{
; 128  : #ifdef _CSTRING_ALWAYS_THUNK
; 129  : 		pfn = pfnWin9x;
; 130  : 		(void)pfnNT;
; 131  : #else
; 132  : 		pfn = pfnNT;

  0002f	8b 44 24 0c	 mov	 eax, DWORD PTR _pfnNT$[esp-4]
$L26701:

; 133  : #endif
; 134  : 	}
; 135  : 	InterlockedExchangePointer(ppThunk, pfn);

  00033	50		 push	 eax
  00034	8b 44 24 08	 mov	 eax, DWORD PTR _ppThunk$[esp]
  00038	50		 push	 eax
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 136  : }

  0003f	c3		 ret	 0
?_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z ENDP	; ATL::_AtlInstallStringThunk
_TEXT	ENDS
PUBLIC	?lstrcmpiWFake@ATL@@YGHPB_W0@Z			; ATL::lstrcmpiWFake
EXTRN	__imp__lstrcmpiA@8:NEAR
EXTRN	__imp__lstrlenW@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?lstrcmpiWFake@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
__acp$ = -4						; size = 4
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWFake@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWFake, COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 248  : 	USES_CONVERSION;

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

  0000d	8b 75 0c	 mov	 esi, DWORD PTR _psz2$[ebp]
  00010	85 f6		 test	 esi, esi
  00012	89 45 fc	 mov	 DWORD PTR __acp$[ebp], eax
  00015	74 40		 je	 SHORT $L66305
  00017	56		 push	 esi
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0001e	8d 5c 00 02	 lea	 ebx, DWORD PTR [eax+eax+2]
  00022	8b c3		 mov	 eax, ebx
  00024	83 c0 03	 add	 eax, 3
  00027	83 e0 fc	 and	 eax, -4			; fffffffcH
  0002a	e8 00 00 00 00	 call	 __alloca_probe
  0002f	8b fc		 mov	 edi, esp
  00031	85 ff		 test	 edi, edi
  00033	74 22		 je	 SHORT $L66305
  00035	8b 45 fc	 mov	 eax, DWORD PTR __acp$[ebp]
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	53		 push	 ebx
  0003d	57		 push	 edi
  0003e	6a ff		 push	 -1
  00040	56		 push	 esi
  00041	6a 00		 push	 0
  00043	50		 push	 eax
  00044	c6 07 00	 mov	 BYTE PTR [edi], 0
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0004d	8b f0		 mov	 esi, eax
  0004f	f7 de		 neg	 esi
  00051	1b f6		 sbb	 esi, esi
  00053	23 f7		 and	 esi, edi
  00055	eb 02		 jmp	 SHORT $L66303
$L66305:
  00057	33 f6		 xor	 esi, esi
$L66303:
  00059	8b 45 08	 mov	 eax, DWORD PTR _psz1$[ebp]
  0005c	85 c0		 test	 eax, eax
  0005e	74 53		 je	 SHORT $L66314
  00060	50		 push	 eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00067	8d 5c 00 02	 lea	 ebx, DWORD PTR [eax+eax+2]
  0006b	8b c3		 mov	 eax, ebx
  0006d	83 c0 03	 add	 eax, 3
  00070	83 e0 fc	 and	 eax, -4			; fffffffcH
  00073	e8 00 00 00 00	 call	 __alloca_probe
  00078	8b fc		 mov	 edi, esp
  0007a	85 ff		 test	 edi, edi
  0007c	74 35		 je	 SHORT $L66314
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _psz1$[ebp]
  00081	8b 55 fc	 mov	 edx, DWORD PTR __acp$[ebp]
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	53		 push	 ebx
  00089	57		 push	 edi
  0008a	6a ff		 push	 -1
  0008c	51		 push	 ecx
  0008d	6a 00		 push	 0
  0008f	52		 push	 edx
  00090	c6 07 00	 mov	 BYTE PTR [edi], 0
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00099	f7 d8		 neg	 eax
  0009b	1b c0		 sbb	 eax, eax
  0009d	23 c7		 and	 eax, edi
  0009f	56		 push	 esi
  000a0	50		 push	 eax
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8

; 251  : }

  000a7	8d 65 f0	 lea	 esp, DWORD PTR [ebp-16]
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 08 00	 ret	 8

; 249  : 
; 250  : 	return ::lstrcmpiA(W2A(psz1), W2A(psz2));

$L66314:
  000b3	33 c0		 xor	 eax, eax
  000b5	56		 push	 esi
  000b6	50		 push	 eax
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrcmpiA@8

; 251  : }

  000bd	8d 65 f0	 lea	 esp, DWORD PTR [ebp-16]
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 08 00	 ret	 8
?lstrcmpiWFake@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWFake
_TEXT	ENDS
EXTRN	__imp__lstrcmpiW@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ?lstrcmpiWThunk@ATL@@YGHPB_W0@Z
_TEXT	SEGMENT
_psz1$ = 8						; size = 4
_psz2$ = 12						; size = 4
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z PROC NEAR		; ATL::lstrcmpiWThunk, COMDAT

; 255  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnlstrcmpiW), lstrcmpiWFake, ::lstrcmpiW);

  00000	f6 05 00 00 00
	00 01		 test	 BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00007	75 19		 jne	 SHORT $L66333
  00009	83 0d 00 00 00
	00 01		 or	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	24 01		 and	 al, 1
  0001b	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  00020	eb 05		 jmp	 SHORT $L66325
$L66333:
  00022	a0 00 00 00 00	 mov	 al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L66325:
  00027	84 c0		 test	 al, al
  00029	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?lstrcmpiWFake@ATL@@YGHPB_W0@Z ; ATL::lstrcmpiWFake
  0002e	75 05		 jne	 SHORT $L66328
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__lstrcmpiW@8
$L66328:
  00035	50		 push	 eax
  00036	68 08 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 256  : 
; 257  : 	return _strthunks.pfnlstrcmpiW(psz1, psz2);

  00041	ff 25 08 00 00
	00		 jmp	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+8
?lstrcmpiWThunk@ATL@@YGHPB_W0@Z ENDP			; ATL::lstrcmpiWThunk
_TEXT	ENDS
PUBLIC	?CharLowerWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharLowerWFake
EXTRN	__imp__wcscpy:NEAR
EXTRN	__imp__lstrlenA@4:NEAR
EXTRN	__imp__CharLowerA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CharLowerWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
__acp$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWFake, COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 262  : 	USES_CONVERSION;

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 263  : 	LPSTR pszA;
; 264  : 
; 265  : 	pszA = W2A(psz);

  0000d	8b 5d 08	 mov	 ebx, DWORD PTR _psz$[ebp]
  00010	85 db		 test	 ebx, ebx
  00012	89 45 fc	 mov	 DWORD PTR __acp$[ebp], eax
  00015	74 40		 je	 SHORT $L66347
  00017	53		 push	 ebx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0001e	8d 74 00 02	 lea	 esi, DWORD PTR [eax+eax+2]
  00022	8b c6		 mov	 eax, esi
  00024	83 c0 03	 add	 eax, 3
  00027	83 e0 fc	 and	 eax, -4			; fffffffcH
  0002a	e8 00 00 00 00	 call	 __alloca_probe
  0002f	8b fc		 mov	 edi, esp
  00031	85 ff		 test	 edi, edi
  00033	74 22		 je	 SHORT $L66347
  00035	8b 45 fc	 mov	 eax, DWORD PTR __acp$[ebp]
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	56		 push	 esi
  0003d	57		 push	 edi
  0003e	6a ff		 push	 -1
  00040	53		 push	 ebx
  00041	6a 00		 push	 0
  00043	50		 push	 eax
  00044	c6 07 00	 mov	 BYTE PTR [edi], 0
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0004d	8b f0		 mov	 esi, eax
  0004f	f7 de		 neg	 esi
  00051	1b f6		 sbb	 esi, esi
  00053	23 f7		 and	 esi, edi
  00055	eb 02		 jmp	 SHORT $L66345
$L66347:
  00057	33 f6		 xor	 esi, esi
$L66345:

; 266  : 	::CharLowerA(pszA);

  00059	56		 push	 esi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharLowerA@4

; 267  : 	wcscpy(psz, A2W(pszA));

  00060	85 f6		 test	 esi, esi
  00062	74 42		 je	 SHORT $L66362
  00064	56		 push	 esi
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0006b	8b d8		 mov	 ebx, eax
  0006d	43		 inc	 ebx
  0006e	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  00071	83 c0 03	 add	 eax, 3
  00074	83 e0 fc	 and	 eax, -4			; fffffffcH
  00077	e8 00 00 00 00	 call	 __alloca_probe
  0007c	8b fc		 mov	 edi, esp
  0007e	85 ff		 test	 edi, edi
  00080	74 21		 je	 SHORT $L66356
  00082	8b 4d fc	 mov	 ecx, DWORD PTR __acp$[ebp]
  00085	53		 push	 ebx
  00086	57		 push	 edi
  00087	6a ff		 push	 -1
  00089	56		 push	 esi
  0008a	6a 00		 push	 0
  0008c	51		 push	 ecx
  0008d	66 c7 07 00 00	 mov	 WORD PTR [edi], 0
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00098	8b 5d 08	 mov	 ebx, DWORD PTR _psz$[ebp]
  0009b	f7 d8		 neg	 eax
  0009d	1b c0		 sbb	 eax, eax
  0009f	23 c7		 and	 eax, edi
  000a1	eb 05		 jmp	 SHORT $L66354
$L66356:
  000a3	8b 5d 08	 mov	 ebx, DWORD PTR _psz$[ebp]
$L66362:
  000a6	33 c0		 xor	 eax, eax
$L66354:
  000a8	50		 push	 eax
  000a9	53		 push	 ebx
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000b0	83 c4 08	 add	 esp, 8

; 268  : 
; 269  : 	return psz;

  000b3	8b c3		 mov	 eax, ebx

; 270  : }

  000b5	8d 65 f0	 lea	 esp, DWORD PTR [ebp-16]
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 04 00	 ret	 4
?CharLowerWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWFake
_TEXT	ENDS
EXTRN	__imp__CharLowerW@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CharLowerWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharLowerWThunk, COMDAT

; 274  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharLowerW), CharLowerWFake, ::CharLowerW);

  00000	f6 05 00 00 00
	00 01		 test	 BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00007	75 19		 jne	 SHORT $L66377
  00009	83 0d 00 00 00
	00 01		 or	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	24 01		 and	 al, 1
  0001b	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  00020	eb 05		 jmp	 SHORT $L66369
$L66377:
  00022	a0 00 00 00 00	 mov	 al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L66369:
  00027	84 c0		 test	 al, al
  00029	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?CharLowerWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharLowerWFake
  0002e	75 05		 jne	 SHORT $L66372
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharLowerW@4
$L66372:
  00035	50		 push	 eax
  00036	68 0c 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 275  : 
; 276  : 	return _strthunks.pfnCharLowerW(psz);

  00041	ff 25 0c 00 00
	00		 jmp	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+12
?CharLowerWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharLowerWThunk
_TEXT	ENDS
PUBLIC	?CharUpperWFake@ATL@@YGPA_WPA_W@Z		; ATL::CharUpperWFake
EXTRN	__imp__CharUpperA@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CharUpperWFake@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
__acp$ = -4						; size = 4
_psz$ = 8						; size = 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWFake, COMDAT

; 280  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 281  : 	USES_CONVERSION;

  00007	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP

; 282  : 	LPSTR pszA;
; 283  : 
; 284  : 	pszA = W2A(psz);

  0000d	8b 5d 08	 mov	 ebx, DWORD PTR _psz$[ebp]
  00010	85 db		 test	 ebx, ebx
  00012	89 45 fc	 mov	 DWORD PTR __acp$[ebp], eax
  00015	74 40		 je	 SHORT $L66391
  00017	53		 push	 ebx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0001e	8d 74 00 02	 lea	 esi, DWORD PTR [eax+eax+2]
  00022	8b c6		 mov	 eax, esi
  00024	83 c0 03	 add	 eax, 3
  00027	83 e0 fc	 and	 eax, -4			; fffffffcH
  0002a	e8 00 00 00 00	 call	 __alloca_probe
  0002f	8b fc		 mov	 edi, esp
  00031	85 ff		 test	 edi, edi
  00033	74 22		 je	 SHORT $L66391
  00035	8b 45 fc	 mov	 eax, DWORD PTR __acp$[ebp]
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	56		 push	 esi
  0003d	57		 push	 edi
  0003e	6a ff		 push	 -1
  00040	53		 push	 ebx
  00041	6a 00		 push	 0
  00043	50		 push	 eax
  00044	c6 07 00	 mov	 BYTE PTR [edi], 0
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0004d	8b f0		 mov	 esi, eax
  0004f	f7 de		 neg	 esi
  00051	1b f6		 sbb	 esi, esi
  00053	23 f7		 and	 esi, edi
  00055	eb 02		 jmp	 SHORT $L66389
$L66391:
  00057	33 f6		 xor	 esi, esi
$L66389:

; 285  : 	::CharUpperA(pszA);

  00059	56		 push	 esi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharUpperA@4

; 286  : 	wcscpy(psz, A2W(pszA));

  00060	85 f6		 test	 esi, esi
  00062	74 42		 je	 SHORT $L66406
  00064	56		 push	 esi
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenA@4
  0006b	8b d8		 mov	 ebx, eax
  0006d	43		 inc	 ebx
  0006e	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  00071	83 c0 03	 add	 eax, 3
  00074	83 e0 fc	 and	 eax, -4			; fffffffcH
  00077	e8 00 00 00 00	 call	 __alloca_probe
  0007c	8b fc		 mov	 edi, esp
  0007e	85 ff		 test	 edi, edi
  00080	74 21		 je	 SHORT $L66400
  00082	8b 4d fc	 mov	 ecx, DWORD PTR __acp$[ebp]
  00085	53		 push	 ebx
  00086	57		 push	 edi
  00087	6a ff		 push	 -1
  00089	56		 push	 esi
  0008a	6a 00		 push	 0
  0008c	51		 push	 ecx
  0008d	66 c7 07 00 00	 mov	 WORD PTR [edi], 0
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00098	8b 5d 08	 mov	 ebx, DWORD PTR _psz$[ebp]
  0009b	f7 d8		 neg	 eax
  0009d	1b c0		 sbb	 eax, eax
  0009f	23 c7		 and	 eax, edi
  000a1	eb 05		 jmp	 SHORT $L66398
$L66400:
  000a3	8b 5d 08	 mov	 ebx, DWORD PTR _psz$[ebp]
$L66406:
  000a6	33 c0		 xor	 eax, eax
$L66398:
  000a8	50		 push	 eax
  000a9	53		 push	 ebx
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000b0	83 c4 08	 add	 esp, 8

; 287  : 
; 288  : 	return psz;

  000b3	8b c3		 mov	 eax, ebx

; 289  : }

  000b5	8d 65 f0	 lea	 esp, DWORD PTR [ebp-16]
  000b8	5f		 pop	 edi
  000b9	5e		 pop	 esi
  000ba	5b		 pop	 ebx
  000bb	8b e5		 mov	 esp, ebp
  000bd	5d		 pop	 ebp
  000be	c2 04 00	 ret	 4
?CharUpperWFake@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWFake
_TEXT	ENDS
EXTRN	__imp__CharUpperW@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CharUpperWThunk@ATL@@YGPA_WPA_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z PROC NEAR		; ATL::CharUpperWThunk, COMDAT

; 293  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCharUpperW), CharUpperWFake, ::CharUpperW);

  00000	f6 05 00 00 00
	00 01		 test	 BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00007	75 19		 jne	 SHORT $L66421
  00009	83 0d 00 00 00
	00 01		 or	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	24 01		 and	 al, 1
  0001b	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  00020	eb 05		 jmp	 SHORT $L66413
$L66421:
  00022	a0 00 00 00 00	 mov	 al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L66413:
  00027	84 c0		 test	 al, al
  00029	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?CharUpperWFake@ATL@@YGPA_WPA_W@Z ; ATL::CharUpperWFake
  0002e	75 05		 jne	 SHORT $L66416
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CharUpperW@4
$L66416:
  00035	50		 push	 eax
  00036	68 10 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 294  : 
; 295  : 	return _strthunks.pfnCharUpperW(psz);

  00041	ff 25 10 00 00
	00		 jmp	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+16
?CharUpperWThunk@ATL@@YGPA_WPA_W@Z ENDP			; ATL::CharUpperWThunk
_TEXT	ENDS
PUBLIC	?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z	; ATL::CTime::GetLocalTm
EXTRN	__imp___localtime64:NEAR
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
;	COMDAT ?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z
_TEXT	SEGMENT
_ptm$ = 8						; size = 4
?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z PROC NEAR	; ATL::CTime::GetLocalTm, COMDAT
; _this$ = ecx

; 320  : {

  00000	53		 push	 ebx

; 321  : 	if (ptm != NULL)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _ptm$[esp]

; 322  : 	{
; 323  : 		struct tm* ptmTemp = _localtime64(&m_time);

  00005	51		 push	 ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  0000c	83 c4 04	 add	 esp, 4
  0000f	85 db		 test	 ebx, ebx
  00011	74 19		 je	 SHORT $L29721

; 324  : 		if (ptmTemp == NULL)

  00013	85 c0		 test	 eax, eax
  00015	75 04		 jne	 SHORT $L29720
  00017	5b		 pop	 ebx

; 329  : 	}
; 330  : 	else
; 331  : 		return _localtime64(&m_time);
; 332  : }

  00018	c2 04 00	 ret	 4
$L29720:
  0001b	56		 push	 esi
  0001c	57		 push	 edi

; 325  : 			return NULL;    // indicates the m_time was not initialized!
; 326  : 
; 327  : 		*ptm = *ptmTemp;

  0001d	8b f0		 mov	 esi, eax
  0001f	b9 09 00 00 00	 mov	 ecx, 9
  00024	8b fb		 mov	 edi, ebx
  00026	f3 a5		 rep movsd
  00028	5f		 pop	 edi

; 328  : 		return ptm;

  00029	8b c3		 mov	 eax, ebx
  0002b	5e		 pop	 esi
$L29721:
  0002c	5b		 pop	 ebx

; 329  : 	}
; 330  : 	else
; 331  : 		return _localtime64(&m_time);
; 332  : }

  0002d	c2 04 00	 ret	 4
?GetLocalTm@CTime@ATL@@QBEPAUtm@@PAU3@@Z ENDP		; ATL::CTime::GetLocalTm
_TEXT	ENDS
PUBLIC	?GetYear@CTime@ATL@@QBEHXZ			; ATL::CTime::GetYear
; Function compile flags: /Ogty
;	COMDAT ?GetYear@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetYear@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetYear, COMDAT
; _this$ = ecx

; 359  : 	struct tm * ptm;
; 360  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  00007	83 c4 04	 add	 esp, 4

; 361  : 	return ptm ? (ptm->tm_year) + 1900 : 0 ; 

  0000a	85 c0		 test	 eax, eax
  0000c	74 09		 je	 SHORT $L66427
  0000e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00011	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH

; 362  : }

  00016	c3		 ret	 0
$L66427:

; 361  : 	return ptm ? (ptm->tm_year) + 1900 : 0 ; 

  00017	33 c0		 xor	 eax, eax

; 362  : }

  00019	c3		 ret	 0
?GetYear@CTime@ATL@@QBEHXZ ENDP				; ATL::CTime::GetYear
_TEXT	ENDS
PUBLIC	?GetMonth@CTime@ATL@@QBEHXZ			; ATL::CTime::GetMonth
; Function compile flags: /Ogty
;	COMDAT ?GetMonth@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetMonth@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetMonth, COMDAT
; _this$ = ecx

; 366  : 	struct tm * ptm;
; 367  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  00007	83 c4 04	 add	 esp, 4

; 368  : 	return ptm ? ptm->tm_mon + 1 : 0;

  0000a	85 c0		 test	 eax, eax
  0000c	74 05		 je	 SHORT $L66439
  0000e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00011	40		 inc	 eax

; 369  : }

  00012	c3		 ret	 0
$L66439:

; 368  : 	return ptm ? ptm->tm_mon + 1 : 0;

  00013	33 c0		 xor	 eax, eax

; 369  : }

  00015	c3		 ret	 0
?GetMonth@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetMonth
_TEXT	ENDS
PUBLIC	?GetDay@CTime@ATL@@QBEHXZ			; ATL::CTime::GetDay
; Function compile flags: /Ogty
;	COMDAT ?GetDay@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetDay@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetDay, COMDAT
; _this$ = ecx

; 373  : 	struct tm * ptm;
; 374  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  00007	83 c4 04	 add	 esp, 4

; 375  : 	return ptm ? ptm->tm_mday : 0 ; 

  0000a	85 c0		 test	 eax, eax
  0000c	74 04		 je	 SHORT $L66451
  0000e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 376  : }

  00011	c3		 ret	 0
$L66451:

; 375  : 	return ptm ? ptm->tm_mday : 0 ; 

  00012	33 c0		 xor	 eax, eax

; 376  : }

  00014	c3		 ret	 0
?GetDay@CTime@ATL@@QBEHXZ ENDP				; ATL::CTime::GetDay
_TEXT	ENDS
PUBLIC	?GetHour@CTime@ATL@@QBEHXZ			; ATL::CTime::GetHour
; Function compile flags: /Ogty
;	COMDAT ?GetHour@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetHour@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetHour, COMDAT
; _this$ = ecx

; 380  : 	struct tm * ptm;
; 381  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  00007	83 c4 04	 add	 esp, 4

; 382  : 	return ptm ? ptm->tm_hour : -1 ; 

  0000a	85 c0		 test	 eax, eax
  0000c	74 04		 je	 SHORT $L66463
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 383  : }

  00011	c3		 ret	 0
$L66463:

; 382  : 	return ptm ? ptm->tm_hour : -1 ; 

  00012	83 c8 ff	 or	 eax, -1

; 383  : }

  00015	c3		 ret	 0
?GetHour@CTime@ATL@@QBEHXZ ENDP				; ATL::CTime::GetHour
_TEXT	ENDS
PUBLIC	?GetMinute@CTime@ATL@@QBEHXZ			; ATL::CTime::GetMinute
; Function compile flags: /Ogty
;	COMDAT ?GetMinute@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetMinute@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetMinute, COMDAT
; _this$ = ecx

; 387  : 	struct tm * ptm;
; 388  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  00007	83 c4 04	 add	 esp, 4

; 389  : 	return ptm ? ptm->tm_min : -1 ; 

  0000a	85 c0		 test	 eax, eax
  0000c	74 04		 je	 SHORT $L66475
  0000e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 390  : }

  00011	c3		 ret	 0
$L66475:

; 389  : 	return ptm ? ptm->tm_min : -1 ; 

  00012	83 c8 ff	 or	 eax, -1

; 390  : }

  00015	c3		 ret	 0
?GetMinute@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetMinute
_TEXT	ENDS
PUBLIC	?GetSecond@CTime@ATL@@QBEHXZ			; ATL::CTime::GetSecond
; Function compile flags: /Ogty
;	COMDAT ?GetSecond@CTime@ATL@@QBEHXZ
_TEXT	SEGMENT
?GetSecond@CTime@ATL@@QBEHXZ PROC NEAR			; ATL::CTime::GetSecond, COMDAT
; _this$ = ecx

; 394  : 	struct tm * ptm;
; 395  : 	ptm = GetLocalTm();

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  00007	83 c4 04	 add	 esp, 4

; 396  : 	return ptm ? ptm->tm_sec : -1 ;

  0000a	85 c0		 test	 eax, eax
  0000c	74 03		 je	 SHORT $L66487
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]

; 397  : }

  00010	c3		 ret	 0
$L66487:

; 396  : 	return ptm ? ptm->tm_sec : -1 ;

  00011	83 c8 ff	 or	 eax, -1

; 397  : }

  00014	c3		 ret	 0
?GetSecond@CTime@ATL@@QBEHXZ ENDP			; ATL::CTime::GetSecond
_TEXT	ENDS
PUBLIC	?GetCount@CStringList@@QBEHXZ			; CStringList::GetCount
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\afxcoll.inl
;	COMDAT ?GetCount@CStringList@@QBEHXZ
_TEXT	SEGMENT
?GetCount@CStringList@@QBEHXZ PROC NEAR			; CStringList::GetCount, COMDAT
; _this$ = ecx

; 481  : 	{ return m_nCount; }

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	c3		 ret	 0
?GetCount@CStringList@@QBEHXZ ENDP			; CStringList::GetCount
_TEXT	ENDS
PUBLIC	?GetHeadPosition@CStringList@@QBEPAU__POSITION@@XZ ; CStringList::GetHeadPosition
; Function compile flags: /Ogty
;	COMDAT ?GetHeadPosition@CStringList@@QBEPAU__POSITION@@XZ
_TEXT	SEGMENT
?GetHeadPosition@CStringList@@QBEPAU__POSITION@@XZ PROC NEAR ; CStringList::GetHeadPosition, COMDAT
; _this$ = ecx

; 499  : 	{ return (POSITION) m_pNodeHead; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetHeadPosition@CStringList@@QBEPAU__POSITION@@XZ ENDP	; CStringList::GetHeadPosition
_TEXT	ENDS
PUBLIC	?GetNext@CStringList@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAPAU__POSITION@@@Z ; CStringList::GetNext
EXTRN	?AfxThrowInvalidArgException@@YGXXZ:NEAR	; AfxThrowInvalidArgException
; Function compile flags: /Ogty
;	COMDAT ?GetNext@CStringList@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAPAU__POSITION@@@Z
_TEXT	SEGMENT
_rPosition$ = 8						; size = 4
?GetNext@CStringList@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAPAU__POSITION@@@Z PROC NEAR ; CStringList::GetNext, COMDAT
; _this$ = ecx

; 503  : 	{ CNode* pNode = (CNode*) rPosition;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _rPosition$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 504  : 		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
; 505  : 		if( pNode == NULL )

  00006	85 c0		 test	 eax, eax
  00008	75 05		 jne	 SHORT $L33786

; 506  : 			AfxThrowInvalidArgException();

  0000a	e8 00 00 00 00	 call	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L33786:

; 507  : 		rPosition = (POSITION) pNode->pNext;

  0000f	8b 10		 mov	 edx, DWORD PTR [eax]
  00011	89 11		 mov	 DWORD PTR [ecx], edx

; 508  : 		return pNode->data; }

  00013	83 c0 08	 add	 eax, 8
  00016	c2 04 00	 ret	 4
$L66503:
?GetNext@CStringList@@QAEAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAPAU__POSITION@@@Z ENDP ; CStringList::GetNext
_TEXT	ENDS
PUBLIC	?CheckTempPath@@YAXXZ				; CheckTempPath
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
;	COMDAT ?CheckTempPath@@YAXXZ
_TEXT	SEGMENT
?CheckTempPath@@YAXXZ PROC NEAR				; CheckTempPath, COMDAT

; 24   : }

  00000	c3		 ret	 0
?CheckTempPath@@YAXXZ ENDP				; CheckTempPath
_TEXT	ENDS
PUBLIC	?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z:NEAR
EXTRN	__imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z:NEAR
EXTRN	__imp_?GetSiteViewRootPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:NEAR
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T66534	DD	0ffffffffH
	DD	FLAT:$L66509
	DD	00H
	DD	FLAT:$L66510
$T66532	DD	019930520H
	DD	02H
	DD	FLAT:$T66534
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
$T66512 = -44						; size = 4
_strRet$ = -44						; size = 4
$T66508 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; FuncGetInstallPath, COMDAT

; 27   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 28   : 	CString strRet = _T("");

  00018	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0001d	8d 4c 24 04	 lea	 ecx, DWORD PTR _strRet$[esp+48]
  00021	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR $T66512[esp+48], 0
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 29   : 	strRet= GetSiteViewRootPath().c_str();

  0002f	8d 44 24 04	 lea	 eax, DWORD PTR $T66508[esp+44]
  00033	50		 push	 eax
  00034	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+56], 0
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetSiteViewRootPath@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  00042	83 c4 04	 add	 esp, 4
  00045	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00049	c6 44 24 28 01	 mov	 BYTE PTR __$EHRec$[esp+52], 1
  0004e	72 05		 jb	 SHORT $L66526
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	eb 03		 jmp	 SHORT $L66527
$L66526:
  00055	83 c0 04	 add	 eax, 4
$L66527:
  00058	56		 push	 esi
  00059	50		 push	 eax
  0005a	8d 4c 24 08	 lea	 ecx, DWORD PTR _strRet$[esp+52]
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z
  00064	8d 4c 24 08	 lea	 ecx, DWORD PTR $T66508[esp+48]
  00068	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 30   : 	return strRet;

  00073	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  00077	8d 4c 24 04	 lea	 ecx, DWORD PTR _strRet$[esp+48]
  0007b	51		 push	 ecx
  0007c	8b ce		 mov	 ecx, esi
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00084	8d 4c 24 04	 lea	 ecx, DWORD PTR _strRet$[esp+48]
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 31   : }

  0008e	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  00092	8b c6		 mov	 eax, esi
  00094	5e		 pop	 esi
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009c	83 c4 2c	 add	 esp, 44			; 0000002cH
  0009f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66509:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _strRet$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66510:
  00009	8d 4d d8	 lea	 ecx, DWORD PTR $T66508[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ:
  00012	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66532
  00017	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; FuncGetInstallPath
PUBLIC	?FuncGetInstallRootSCPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallRootSCPath
; Function compile flags: /Ogty
;	COMDAT ?FuncGetInstallRootSCPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
$T66541 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?FuncGetInstallRootSCPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; FuncGetInstallRootSCPath, COMDAT

; 34   : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 35   : 	return  FuncGetInstallPath();

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+4]
  00006	56		 push	 esi
  00007	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T66541[esp+12], 0
  0000f	e8 00 00 00 00	 call	 ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
  00014	83 c4 04	 add	 esp, 4
  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 36   : }

  0001a	59		 pop	 ecx
  0001b	c3		 ret	 0
?FuncGetInstallRootSCPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; FuncGetInstallRootSCPath
_TEXT	ENDS
PUBLIC	??_C@_0M@NLJHBKOA@HTTP_COOKIE?$AA@		; `string'
PUBLIC	??_C@_04IEFHJGLE@cid?$DN?$AA@			; `string'
PUBLIC	??_C@_01ICJEACDI@?$DL?$AA@			; `string'
PUBLIC	?GetCIDFromCookie@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; GetCIDFromCookie
EXTRN	__imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z:NEAR
EXTRN	__imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z:NEAR
EXTRN	__imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z:NEAR
EXTRN	__imp_?Right@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z:NEAR
EXTRN	__imp__getenv:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T66568	DD	0ffffffffH
	DD	FLAT:$L66546
	DD	00H
	DD	FLAT:$L66550
	DD	01H
	DD	FLAT:$L66551
	DD	01H
	DD	FLAT:$L66552
$T66563	DD	019930520H
	DD	04H
	DD	FLAT:$T66568
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0M@NLJHBKOA@HTTP_COOKIE?$AA@
CONST	SEGMENT
??_C@_0M@NLJHBKOA@HTTP_COOKIE?$AA@ DB 'HTTP_COOKIE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEFHJGLE@cid?$DN?$AA@
CONST	SEGMENT
??_C@_04IEFHJGLE@cid?$DN?$AA@ DB 'cid=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01ICJEACDI@?$DL?$AA@
CONST	SEGMENT
??_C@_01ICJEACDI@?$DL?$AA@ DB ';', 00H			; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?GetCIDFromCookie@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
_strCid$ = -28						; size = 4
_strSource$ = -24					; size = 4
$T66548 = -20						; size = 4
_str$ = -20						; size = 4
$T66545 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?GetCIDFromCookie@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; GetCIDFromCookie, COMDAT

; 87   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GetCIDFromCookie@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	56		 push	 esi
  00019	33 f6		 xor	 esi, esi

; 88   : 	CString strCid= _T("");

  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00020	8d 4c 24 08	 lea	 ecx, DWORD PTR _strCid$[esp+36]
  00024	89 74 24 10	 mov	 DWORD PTR $T66548[esp+36], esi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 89   : 	char *hc=getenv("HTTP_COOKIE"); 

  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@NLJHBKOA@HTTP_COOKIE?$AA@
  00033	89 74 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], esi
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getenv
  0003d	83 c4 04	 add	 esp, 4

; 90   : 	if (hc == NULL) 

  00040	3b c6		 cmp	 eax, esi
  00042	75 16		 jne	 SHORT $L60523

; 91   : 		return strCid;

  00044	8b 74 24 24	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+28]
  00048	8d 44 24 04	 lea	 eax, DWORD PTR _strCid$[esp+32]
  0004c	50		 push	 eax
  0004d	8b ce		 mov	 ecx, esi
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00055	e9 d8 00 00 00	 jmp	 $L66565
$L60523:

; 92   : 
; 93   : 	CString strSource = hc;

  0005a	50		 push	 eax
  0005b	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strSource$[esp+36]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 94   : 
; 95   : 	int nLeftIndex = strSource.Find("cid=", 0);

  00065	56		 push	 esi
  00066	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04IEFHJGLE@cid?$DN?$AA@
  0006b	8d 4c 24 10	 lea	 ecx, DWORD PTR _strSource$[esp+40]
  0006f	c6 44 24 24 01	 mov	 BYTE PTR __$EHRec$[esp+48], 1
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z
  0007a	8b f0		 mov	 esi, eax

; 96   : 	if (nLeftIndex == -1)

  0007c	83 fe ff	 cmp	 esi, -1

; 97   : 		return strCid;

  0007f	74 50		 je	 SHORT $L66567

; 98   : 
; 99   : 	int nRightIndex = strSource.Find(";", nLeftIndex);

  00081	56		 push	 esi
  00082	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01ICJEACDI@?$DL?$AA@
  00087	8d 4c 24 10	 lea	 ecx, DWORD PTR _strSource$[esp+40]
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z

; 100  : 	if (nRightIndex == -1) {// may be only two cookies.

  00091	83 f8 ff	 cmp	 eax, -1

; 101  : 		strCid = strSource.Right(strSource.GetLength() - nLeftIndex - 4);

  00094	8d 4c 24 08	 lea	 ecx, DWORD PTR _strSource$[esp+32]
  00098	75 4a		 jne	 SHORT $L60530
  0009a	8b 54 24 08	 mov	 edx, DWORD PTR _strSource$[esp+32]
  0009e	8b 42 f4	 mov	 eax, DWORD PTR [edx-12]
  000a1	2b c6		 sub	 eax, esi
  000a3	83 e8 04	 sub	 eax, 4
  000a6	50		 push	 eax
  000a7	8d 44 24 14	 lea	 eax, DWORD PTR $T66545[esp+36]
  000ab	50		 push	 eax
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Right@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  000b2	50		 push	 eax
  000b3	8d 4c 24 08	 lea	 ecx, DWORD PTR _strCid$[esp+36]
  000b7	c6 44 24 20 02	 mov	 BYTE PTR __$EHRec$[esp+44], 2
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000c2	8d 4c 24 10	 lea	 ecx, DWORD PTR $T66545[esp+32]
  000c6	c6 44 24 1c 01	 mov	 BYTE PTR __$EHRec$[esp+40], 1
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66567:

; 102  : 		return strCid;

  000d1	8b 74 24 24	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+28]
  000d5	8d 4c 24 04	 lea	 ecx, DWORD PTR _strCid$[esp+32]
  000d9	51		 push	 ecx
  000da	8b ce		 mov	 ecx, esi
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  000e2	eb 44		 jmp	 SHORT $L66566
$L60530:

; 103  : 	}
; 104  : 
; 105  : 	int nLength = static_cast<int>(strlen("cid="));
; 106  : 
; 107  : 	CString str = strSource.Mid(nLeftIndex + nLength , nRightIndex - nLeftIndex - nLength);

  000e4	2b c6		 sub	 eax, esi
  000e6	83 e8 04	 sub	 eax, 4
  000e9	50		 push	 eax
  000ea	83 c6 04	 add	 esi, 4
  000ed	56		 push	 esi
  000ee	8d 54 24 14	 lea	 edx, DWORD PTR _str$[esp+40]
  000f2	52		 push	 edx
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Mid@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@HH@Z

; 108  : 	strCid = str;

  000f9	8d 44 24 0c	 lea	 eax, DWORD PTR _str$[esp+32]
  000fd	50		 push	 eax
  000fe	8d 4c 24 08	 lea	 ecx, DWORD PTR _strCid$[esp+36]
  00102	c6 44 24 20 03	 mov	 BYTE PTR __$EHRec$[esp+44], 3
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 109  : 
; 110  : 	return strCid;

  0010d	8b 74 24 24	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+28]
  00111	8d 4c 24 04	 lea	 ecx, DWORD PTR _strCid$[esp+32]
  00115	51		 push	 ecx
  00116	8b ce		 mov	 ecx, esi
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0011e	8d 4c 24 0c	 lea	 ecx, DWORD PTR _str$[esp+32]
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66566:
  00128	8d 4c 24 08	 lea	 ecx, DWORD PTR _strSource$[esp+32]
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66565:
  00132	8d 4c 24 04	 lea	 ecx, DWORD PTR _strCid$[esp+32]
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 111  : }

  0013c	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  00140	8b c6		 mov	 eax, esi
  00142	5e		 pop	 esi
  00143	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0014a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0014d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66546:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _strCid$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66550:
  00009	8d 4d e8	 lea	 ecx, DWORD PTR _strSource$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66551:
  00012	8d 4d f0	 lea	 ecx, DWORD PTR $T66545[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66552:
  0001b	8d 4d ec	 lea	 ecx, DWORD PTR _str$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?GetCIDFromCookie@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ:
  00024	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66563
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetCIDFromCookie@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; GetCIDFromCookie
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BO@JOODGAEE@SOFTWARE?2siteview?2siteviewecc?$AA@ ; `string'
PUBLIC	??_C@_0M@KEDFDEMF@root_path_7?$AA@		; `string'
PUBLIC	?FuncGetInstallRootPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallRootPath
EXTRN	__imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z:NEAR
EXTRN	__imp_?CompareNoCase@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z:NEAR
EXTRN	__imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ:NEAR
EXTRN	__imp__RegCloseKey@4:NEAR
EXTRN	__imp__RegEnumValueA@32:NEAR
EXTRN	__imp__RegOpenKeyExA@20:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T66595	DD	0ffffffffH
	DD	FLAT:$L66575
	DD	00H
	DD	FLAT:$L66579
	DD	01H
	DD	FLAT:$L66580
$T66585	DD	019930520H
	DD	03H
	DD	FLAT:$T66595
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BO@JOODGAEE@SOFTWARE?2siteview?2siteviewecc?$AA@
CONST	SEGMENT
??_C@_0BO@JOODGAEE@SOFTWARE?2siteview?2siteviewecc?$AA@ DB 'SOFTWARE\site'
	DB	'view\siteviewecc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KEDFDEMF@root_path_7?$AA@
CONST	SEGMENT
??_C@_0M@KEDFDEMF@root_path_7?$AA@ DB 'root_path_7', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?FuncGetInstallRootPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
_TEXT	SEGMENT
_strRet$ = -312						; size = 4
_strValKey$ = -308					; size = 4
_strSubKey$ = -304					; size = 4
_dwS2$ = -300						; size = 4
_dwS1$ = -296						; size = 4
_hKey$ = -292						; size = 4
_bFindFlag$ = -288					; size = 4
$T66577 = -284						; size = 4
_dwType$ = -284						; size = 4
_szAppRoot$ = -280					; size = 255
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?FuncGetInstallRootPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ PROC NEAR ; FuncGetInstallRootPath, COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?FuncGetInstallRootPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi

; 132  : 	{
; 133  : 		lpName = strSubKey.GetBuffer(dwS1);

  00029	33 db		 xor	 ebx, ebx
  0002b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00030	8d 4c 24 14	 lea	 ecx, DWORD PTR _strRet$[esp+332]
  00034	89 84 24 38 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+332], eax
  0003b	89 5c 24 30	 mov	 DWORD PTR $T66577[esp+332], ebx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00045	8d 44 24 24	 lea	 eax, DWORD PTR _hKey$[esp+328]
  00049	50		 push	 eax
  0004a	68 19 00 02 00	 push	 131097			; 00020019H
  0004f	53		 push	 ebx
  00050	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BO@JOODGAEE@SOFTWARE?2siteview?2siteviewecc?$AA@
  00055	68 02 00 00 80	 push	 -2147483646		; 80000002H
  0005a	89 9c 24 58 01
	00 00		 mov	 DWORD PTR __$EHRec$[esp+356], ebx
  00061	89 5c 24 38	 mov	 DWORD PTR _hKey$[esp+348], ebx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  0006b	3b c3		 cmp	 eax, ebx
  0006d	74 15		 je	 SHORT $L60546
  0006f	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00072	8d 4c 24 10	 lea	 ecx, DWORD PTR _strRet$[esp+328]
  00076	51		 push	 ecx
  00077	8b ce		 mov	 ecx, esi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0007f	e9 38 01 00 00	 jmp	 $L66594
$L60546:

; 115  : 	CString strRet = _T("");
; 116  : 	HKEY hKey = NULL;
; 117  : 	LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,KEY_PATH,0,KEY_READ,&hKey);
; 118  : 	if(lRet != ERROR_SUCCESS)
; 119  : 		return strRet;
; 120  : 	
; 121  : 	LPTSTR  lpName = NULL,
; 122  :  			lpValue = NULL;
; 123  : 	CString strSubKey = _T(""),

  00084	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00089	8d 4c 24 1c	 lea	 ecx, DWORD PTR _strSubKey$[esp+332]
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 124  :  			strValKey = _T("");

  00093	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00098	8d 4c 24 18	 lea	 ecx, DWORD PTR _strValKey$[esp+332]
  0009c	c6 84 24 48 01
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+340], 1
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 125  : 	DWORD   dwIndex = 0,
; 126  : 			dwS1 = 255,

  000aa	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000af	89 44 24 20	 mov	 DWORD PTR _dwS1$[esp+328], eax

; 127  : 			dwS2 = 255,

  000b3	89 44 24 1c	 mov	 DWORD PTR _dwS2$[esp+328], eax

; 128  : 			dwType = REG_SZ;
; 129  : 	BOOL    bFindFlag = FALSE;
; 130  : 	char szAppRoot[255] = {0};

  000b7	c6 44 24 30 00	 mov	 BYTE PTR _szAppRoot$[esp+328], 0
  000bc	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  000c1	33 c0		 xor	 eax, eax
  000c3	8d 7c 24 31	 lea	 edi, DWORD PTR _szAppRoot$[esp+329]
  000c7	f3 ab		 rep stosd
  000c9	66 ab		 stosw
  000cb	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__RegEnumValueA@32
  000d1	c6 84 24 44 01
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+336], 2
  000d9	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR _dwType$[esp+328], 1
  000e1	89 5c 24 28	 mov	 DWORD PTR _bFindFlag$[esp+328], ebx
$L60558:

; 132  : 	{
; 133  : 		lpName = strSubKey.GetBuffer(dwS1);

  000e5	8b 54 24 20	 mov	 edx, DWORD PTR _dwS1$[esp+328]
  000e9	52		 push	 edx
  000ea	8d 4c 24 1c	 lea	 ecx, DWORD PTR _strSubKey$[esp+332]
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  000f4	8b f0		 mov	 esi, eax

; 134  : 		lpValue = strValKey.GetBuffer(dwS2);

  000f6	8b 44 24 1c	 mov	 eax, DWORD PTR _dwS2$[esp+328]
  000fa	50		 push	 eax
  000fb	8d 4c 24 18	 lea	 ecx, DWORD PTR _strValKey$[esp+332]
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z

; 135  : 		lRet = RegEnumValue(hKey, dwIndex++, lpName , &dwS1,NULL, &dwType ,(LPBYTE)lpValue, &dwS2);

  00105	8d 4c 24 1c	 lea	 ecx, DWORD PTR _dwS2$[esp+328]
  00109	51		 push	 ecx
  0010a	8b 4c 24 28	 mov	 ecx, DWORD PTR _hKey$[esp+332]
  0010e	50		 push	 eax
  0010f	8d 54 24 34	 lea	 edx, DWORD PTR _dwType$[esp+336]
  00113	52		 push	 edx
  00114	6a 00		 push	 0
  00116	8d 44 24 30	 lea	 eax, DWORD PTR _dwS1$[esp+344]
  0011a	50		 push	 eax
  0011b	56		 push	 esi
  0011c	53		 push	 ebx
  0011d	51		 push	 ecx
  0011e	ff d7		 call	 edi
  00120	8b f0		 mov	 esi, eax

; 136  : 		dwS1 = 255;

  00122	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00127	43		 inc	 ebx

; 137  : 		dwS2 = 255;
; 138  : 		if(lRet == ERROR_NO_MORE_ITEMS)

  00128	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  0012e	89 44 24 20	 mov	 DWORD PTR _dwS1$[esp+328], eax
  00132	89 44 24 1c	 mov	 DWORD PTR _dwS2$[esp+328], eax
  00136	74 35		 je	 SHORT $L60559

; 139  : 			break;
; 140  : 		if(strSubKey.CompareNoCase(KEY_NAME) == 0)

  00138	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@KEDFDEMF@root_path_7?$AA@
  0013d	8d 4c 24 1c	 lea	 ecx, DWORD PTR _strSubKey$[esp+332]
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?CompareNoCase@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00147	85 c0		 test	 eax, eax
  00149	74 06		 je	 SHORT $L66589

; 131  : 	while(lRet == ERROR_SUCCESS)

  0014b	85 f6		 test	 esi, esi
  0014d	74 96		 je	 SHORT $L60558

; 139  : 			break;
; 140  : 		if(strSubKey.CompareNoCase(KEY_NAME) == 0)

  0014f	eb 1c		 jmp	 SHORT $L60559
$L66589:

; 141  : 		{
; 142  : 			bFindFlag = TRUE;
; 143  : 			strcpy(szAppRoot,strValKey);

  00151	8b 44 24 14	 mov	 eax, DWORD PTR _strValKey$[esp+328]
  00155	8d 54 24 30	 lea	 edx, DWORD PTR _szAppRoot$[esp+328]
  00159	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR _bFindFlag$[esp+328], 1
  00161	2b d0		 sub	 edx, eax
$L66574:
  00163	8a 08		 mov	 cl, BYTE PTR [eax]
  00165	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00168	40		 inc	 eax
  00169	84 c9		 test	 cl, cl
  0016b	75 f6		 jne	 SHORT $L66574
$L60559:

; 144  : 			break;
; 145  : 		}
; 146  : 	}
; 147  : 
; 148  : 	RegCloseKey(hKey);

  0016d	8b 54 24 24	 mov	 edx, DWORD PTR _hKey$[esp+328]
  00171	52		 push	 edx
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 149  : 	
; 150  : 	if(bFindFlag)

  00178	8b 44 24 28	 mov	 eax, DWORD PTR _bFindFlag$[esp+328]
  0017c	85 c0		 test	 eax, eax
  0017e	74 18		 je	 SHORT $L60564

; 151  : 	{
; 152  : 		strRet.Format("%s",szAppRoot);

  00180	8d 44 24 30	 lea	 eax, DWORD PTR _szAppRoot$[esp+328]
  00184	50		 push	 eax
  00185	8d 4c 24 14	 lea	 ecx, DWORD PTR _strRet$[esp+332]
  00189	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  0018e	51		 push	 ecx
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00195	83 c4 0c	 add	 esp, 12			; 0000000cH
$L60564:

; 153  : 	}
; 154  : 
; 155  : 	return strRet;

  00198	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0019b	8d 54 24 10	 lea	 edx, DWORD PTR _strRet$[esp+328]
  0019f	52		 push	 edx
  001a0	8b ce		 mov	 ecx, esi
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  001a8	8d 4c 24 14	 lea	 ecx, DWORD PTR _strValKey$[esp+328]
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001b2	8d 4c 24 18	 lea	 ecx, DWORD PTR _strSubKey$[esp+328]
  001b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66594:
  001bc	8d 4c 24 10	 lea	 ecx, DWORD PTR _strRet$[esp+328]
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 156  : }

  001c6	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+328]
  001cd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001d4	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+328]
  001db	8b c6		 mov	 eax, esi
  001dd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e2	5f		 pop	 edi
  001e3	5e		 pop	 esi
  001e4	5b		 pop	 ebx
  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66575:
  00000	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR _strRet$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66579:
  0000c	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR _strSubKey$[ebp]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66580:
  00018	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _strValKey$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FuncGetInstallRootPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ:
  00024	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66585
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetInstallRootPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ENDP ; FuncGetInstallRootPath
PUBLIC	?WSA_Init@@YAHXZ				; WSA_Init
EXTRN	__imp__WSAStartup@8:NEAR
EXTRN	__imp__WSACleanup@0:NEAR
; Function compile flags: /Ogty
;	COMDAT ?WSA_Init@@YAHXZ
_TEXT	SEGMENT
_wsaData$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
?WSA_Init@@YAHXZ PROC NEAR				; WSA_Init, COMDAT

; 159  : {

  00000	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	89 84 24 90 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+404], eax

; 160  :     //return 0;
; 161  : 	WORD wVersionRequested;  
; 162  : 	WSADATA wsaData; 
; 163  : 	int err; 
; 164  : 	wVersionRequested = MAKEWORD(1, 1); 
; 165  :     
; 166  : 	err = WSAStartup(wVersionRequested, &wsaData); 

  00012	8d 04 24	 lea	 eax, DWORD PTR _wsaData$[esp+404]
  00015	50		 push	 eax
  00016	68 01 01 00 00	 push	 257			; 00000101H
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAStartup@8

; 167  :     
; 168  : 	if (err != 0) 

  00021	85 c0		 test	 eax, eax
  00023	74 16		 je	 SHORT $L60576

; 169  : 		return -1; 

  00025	83 c8 ff	 or	 eax, -1

; 179  : }

  00028	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  0003a	c3		 ret	 0
$L60576:

; 170  :     
; 171  : 	if ( LOBYTE( wsaData.wVersion ) != 1 || 
; 172  : 		HIBYTE( wsaData.wVersion ) != 1 ) 

  0003b	66 8b 04 24	 mov	 ax, WORD PTR _wsaData$[esp+404]
  0003f	3c 01		 cmp	 al, 1
  00041	75 19		 jne	 SHORT $L60582
  00043	3a e0		 cmp	 ah, al
  00045	75 15		 jne	 SHORT $L60582

; 175  : 		return -2;
; 176  : 	}
; 177  : 	
; 178  : 	return 0;

  00047	33 c0		 xor	 eax, eax

; 179  : }

  00049	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  0005b	c3		 ret	 0
$L60582:

; 173  : 	{ 
; 174  : 		WSACleanup(); 

  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSACleanup@0

; 179  : }

  00062	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+404]
  00069	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  00079	c3		 ret	 0
?WSA_Init@@YAHXZ ENDP					; WSA_Init
_TEXT	ENDS
PUBLIC	?WSA_Free@@YAXXZ				; WSA_Free
; Function compile flags: /Ogty
;	COMDAT ?WSA_Free@@YAXXZ
_TEXT	SEGMENT
?WSA_Free@@YAXXZ PROC NEAR				; WSA_Free, COMDAT

; 183  :     //return;
; 184  : 	WSACleanup();

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__WSACleanup@0
?WSA_Free@@YAXXZ ENDP					; WSA_Free
_TEXT	ENDS
PUBLIC	??_C@_0BG@KFDBAEJB@?$CFs?2data?2TmpIniFile?2?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0M@ELOFBODM@?6info?5path?3?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z	; DFN_GetPrivateProfileString
EXTRN	__imp__GetPrivateProfileStringA@24:NEAR
EXTRN	__imp__sprintf:NEAR
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
EXTRN	__imp__OutputDebugStringA@4:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T66651	DD	0ffffffffH
	DD	FLAT:$L66608
	DD	00H
	DD	FLAT:$L66609
	DD	01H
	DD	FLAT:$L66610
	DD	02H
	DD	FLAT:$L66611
	DD	03H
	DD	FLAT:$L66612
	DD	04H
	DD	FLAT:$L66613
$T66648	DD	019930520H
	DD	06H
	DD	FLAT:$T66651
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BG@KFDBAEJB@?$CFs?2data?2TmpIniFile?2?$CFs?$AA@
CONST	SEGMENT
??_C@_0BG@KFDBAEJB@?$CFs?2data?2TmpIniFile?2?$CFs?$AA@ DB '%s\data\TmpIni'
	DB	'File\%s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ELOFBODM@?6info?5path?3?$AA@
CONST	SEGMENT
??_C@_0M@ELOFBODM@?6info?5path?3?$AA@ DB 0aH, 'info path:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z
_TEXT	SEGMENT
$T66606 = -1192						; size = 4
_dfn_File$ = -1188					; size = 28
_dfn_Key$ = -1160					; size = 28
_dfn_Section$ = -1132					; size = 28
_dfn_Default$ = -1104					; size = 28
_dfn_Val$ = -1076					; size = 28
_configpath$ = -1048					; size = 1024
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lpAppName$ = 8						; size = 4
_lpKeyName$ = 12					; size = 4
_lpDefault$ = 16					; size = 4
_lpReturnedString$ = 20					; size = 4
_nSize$ = 24						; size = 4
_lpFileName$ = 28					; size = 4
?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z PROC NEAR	; DFN_GetPrivateProfileString, COMDAT

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec a0 04 00
	00		 sub	 esp, 1184		; 000004a0H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi

; 218  : 	std::string dfn_Section;

  00029	8d 4c 24 4c	 lea	 ecx, DWORD PTR _dfn_Section$[esp+1208]
  0002d	89 84 24 a4 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1208], eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 219  : 	std::string dfn_Key;

  0003a	8d 4c 24 30	 lea	 ecx, DWORD PTR _dfn_Key$[esp+1208]
  0003e	c7 84 24 b4 04
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1216], 0
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 220  : 	std::string dfn_Default;

  0004f	8d 4c 24 68	 lea	 ecx, DWORD PTR _dfn_Default$[esp+1208]
  00053	c6 84 24 b4 04
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+1216], 1
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 221  : 	std::string dfn_File;

  00061	8d 4c 24 14	 lea	 ecx, DWORD PTR _dfn_File$[esp+1208]
  00065	c6 84 24 b4 04
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+1216], 2
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 222  : 	dfn_Section =lpAppName;

  00073	8b 5d 08	 mov	 ebx, DWORD PTR _lpAppName$[ebp]
  00076	53		 push	 ebx
  00077	8d 4c 24 50	 lea	 ecx, DWORD PTR _dfn_Section$[esp+1212]
  0007b	c6 84 24 b8 04
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+1220], 3
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 	dfn_Key   = lpKeyName;

  00089	8b 45 0c	 mov	 eax, DWORD PTR _lpKeyName$[ebp]
  0008c	50		 push	 eax
  0008d	8d 4c 24 34	 lea	 ecx, DWORD PTR _dfn_Key$[esp+1212]
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 224  : 	dfn_Default= lpDefault;

  00097	8b 4d 10	 mov	 ecx, DWORD PTR _lpDefault$[ebp]
  0009a	51		 push	 ecx
  0009b	8d 4c 24 6c	 lea	 ecx, DWORD PTR _dfn_Default$[esp+1212]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 225  : 	dfn_File = lpFileName;

  000a5	8b 55 1c	 mov	 edx, DWORD PTR _lpFileName$[ebp]
  000a8	52		 push	 edx
  000a9	8d 4c 24 18	 lea	 ecx, DWORD PTR _dfn_File$[esp+1212]
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 226  : 
; 227  : 	std::string dfn_Val;

  000b3	8d 8c 24 84 00
	00 00		 lea	 ecx, DWORD PTR _dfn_Val$[esp+1208]
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 228  : 
; 229  : 	if(gRoot_path=="")

  000c0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000c5	68 00 00 00 00	 push	 OFFSET FLAT:_gRoot_path
  000ca	c6 84 24 bc 04
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+1224], 4
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  000d8	83 c4 08	 add	 esp, 8
  000db	84 c0		 test	 al, al
  000dd	74 2d		 je	 SHORT $L60609

; 230  : 			gRoot_path =FuncGetInstallPath();

  000df	8d 44 24 10	 lea	 eax, DWORD PTR $T66606[esp+1208]
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
  000e9	83 c4 04	 add	 esp, 4
  000ec	8b 00		 mov	 eax, DWORD PTR [eax]
  000ee	50		 push	 eax
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_gRoot_path
  000f4	c6 84 24 b8 04
	00 00 05	 mov	 BYTE PTR __$EHRec$[esp+1220], 5
  000fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  00102	8d 4c 24 10	 lea	 ecx, DWORD PTR $T66606[esp+1208]
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L60609:

; 231  : 	
; 232  : 	//dfn_Val=GetIniFileString(dfn_Section, dfn_Key,dfn_Default,dfn_File);
; 233  : 
; 234  : 	char configpath[1024]={0};

  0010c	33 c0		 xor	 eax, eax
  0010e	c6 84 24 a0 00
	00 00 00	 mov	 BYTE PTR _configpath$[esp+1208], 0
  00116	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0011b	8d bc 24 a1 00
	00 00		 lea	 edi, DWORD PTR _configpath$[esp+1209]
  00122	f3 ab		 rep stosd

; 235  : 
; 236  : 	sprintf(configpath,"%s\\data\\TmpIniFile\\%s",gRoot_path.c_str(),dfn_File.c_str());

  00124	8b 4c 24 2c	 mov	 ecx, DWORD PTR _dfn_File$[esp+1232]
  00128	66 ab		 stosw
  0012a	aa		 stosb
  0012b	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00130	3b c8		 cmp	 ecx, eax
  00132	8b 4c 24 18	 mov	 ecx, DWORD PTR _dfn_File$[esp+1212]
  00136	73 04		 jae	 SHORT $L66630
  00138	8d 4c 24 18	 lea	 ecx, DWORD PTR _dfn_File$[esp+1212]
$L66630:
  0013c	39 05 18 00 00
	00		 cmp	 DWORD PTR _gRoot_path+24, eax
  00142	a1 04 00 00 00	 mov	 eax, DWORD PTR _gRoot_path+4
  00147	73 05		 jae	 SHORT $L66645
  00149	b8 04 00 00 00	 mov	 eax, OFFSET FLAT:_gRoot_path+4
$L66645:
  0014e	51		 push	 ecx
  0014f	50		 push	 eax
  00150	8d 8c 24 a8 00
	00 00		 lea	 ecx, DWORD PTR _configpath$[esp+1216]
  00157	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@KFDBAEJB@?$CFs?2data?2TmpIniFile?2?$CFs?$AA@
  0015c	51		 push	 ecx
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 237  : //	printf("configpath=%s\n",configpath);
; 238  : 
; 239  : 	OutputDebugString("\ninfo path:");

  00163	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__OutputDebugStringA@4
  00169	83 c4 10	 add	 esp, 16			; 00000010H
  0016c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@ELOFBODM@?6info?5path?3?$AA@
  00171	ff d6		 call	 esi

; 240  : 	OutputDebugString( configpath );

  00173	8d 94 24 a0 00
	00 00		 lea	 edx, DWORD PTR _configpath$[esp+1208]
  0017a	52		 push	 edx
  0017b	ff d6		 call	 esi

; 241  : 	OutputDebugString("\n");

  0017d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00182	ff d6		 call	 esi

; 242  : 
; 243  : 	//puts(configpath);
; 244  : 	return GetPrivateProfileString(lpAppName,lpKeyName,lpDefault,lpReturnedString,nSize,configpath);

  00184	8b 4d 18	 mov	 ecx, DWORD PTR _nSize$[ebp]
  00187	8b 55 14	 mov	 edx, DWORD PTR _lpReturnedString$[ebp]
  0018a	8d 84 24 a0 00
	00 00		 lea	 eax, DWORD PTR _configpath$[esp+1208]
  00191	50		 push	 eax
  00192	8b 45 10	 mov	 eax, DWORD PTR _lpDefault$[ebp]
  00195	51		 push	 ecx
  00196	8b 4d 0c	 mov	 ecx, DWORD PTR _lpKeyName$[ebp]
  00199	52		 push	 edx
  0019a	50		 push	 eax
  0019b	51		 push	 ecx
  0019c	53		 push	 ebx
  0019d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24
  001a3	8d 8c 24 84 00
	00 00		 lea	 ecx, DWORD PTR _dfn_Val$[esp+1208]
  001aa	8b f0		 mov	 esi, eax
  001ac	c6 84 24 b4 04
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+1216], 3
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001ba	8d 4c 24 14	 lea	 ecx, DWORD PTR _dfn_File$[esp+1208]
  001be	c6 84 24 b4 04
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+1216], 2
  001c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001cc	8d 4c 24 68	 lea	 ecx, DWORD PTR _dfn_Default$[esp+1208]
  001d0	c6 84 24 b4 04
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+1216], 1
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001de	8d 4c 24 30	 lea	 ecx, DWORD PTR _dfn_Key$[esp+1208]
  001e2	c6 84 24 b4 04
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+1216], 0
  001ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001f0	8d 4c 24 4c	 lea	 ecx, DWORD PTR _dfn_Section$[esp+1208]
  001f4	c7 84 24 b4 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1216], -1
  001ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 245  : 
; 246  : }

  00205	8b 8c 24 ac 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1208]
  0020c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00213	8b 8c 24 a4 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1208]
  0021a	8b c6		 mov	 eax, esi
  0021c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	5b		 pop	 ebx
  00224	8b e5		 mov	 esp, ebp
  00226	5d		 pop	 ebp
  00227	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66608:
  00000	8d 8d 94 fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_Section$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66609:
  0000c	8d 8d 78 fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_Key$[ebp]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66610:
  00018	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_Default$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66611:
  00024	8d 8d 5c fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_File$[ebp]
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66612:
  00030	8d 8d cc fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_Val$[ebp]
  00036	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66613:
  0003c	8d 8d 58 fb ff
	ff		 lea	 ecx, DWORD PTR $T66606[ebp]
  00042	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z:
  00048	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66648
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z ENDP	; DFN_GetPrivateProfileString
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?DFN_GetPrivateProfileInt@@YAHPBD0H0@Z		; DFN_GetPrivateProfileInt
EXTRN	__imp__atoi:NEAR
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DFN_GetPrivateProfileInt@@YAHPBD0H0@Z
_TEXT	SEGMENT
_strDefault$ = -68					; size = 30
_strGet$ = -36						; size = 30
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpAppName$ = 8						; size = 4
_lpKeyName$ = 12					; size = 4
_nDefault$ = 16						; size = 4
_lpFileName$ = 20					; size = 4
?DFN_GetPrivateProfileInt@@YAHPBD0H0@Z PROC NEAR	; DFN_GetPrivateProfileInt, COMDAT

; 267  : {

  00000	83 ec 44	 sub	 esp, 68			; 00000044H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 268  : 	int Result;
; 269  : 	char strDefault[30]={0};

  00008	33 c9		 xor	 ecx, ecx
  0000a	89 4c 24 01	 mov	 DWORD PTR _strDefault$[esp+69], ecx

; 270  : 	char strGet[30]={0};

  0000e	33 d2		 xor	 edx, edx
  00010	89 4c 24 05	 mov	 DWORD PTR _strDefault$[esp+73], ecx
  00014	89 54 24 21	 mov	 DWORD PTR _strGet$[esp+69], edx
  00018	89 4c 24 09	 mov	 DWORD PTR _strDefault$[esp+77], ecx
  0001c	89 54 24 25	 mov	 DWORD PTR _strGet$[esp+73], edx
  00020	89 4c 24 0d	 mov	 DWORD PTR _strDefault$[esp+81], ecx
  00024	89 44 24 40	 mov	 DWORD PTR __$ArrayPad$[esp+68], eax
  00028	89 54 24 29	 mov	 DWORD PTR _strGet$[esp+77], edx
  0002c	32 c0		 xor	 al, al
  0002e	89 4c 24 11	 mov	 DWORD PTR _strDefault$[esp+85], ecx
  00032	89 54 24 2d	 mov	 DWORD PTR _strGet$[esp+81], edx
  00036	89 4c 24 15	 mov	 DWORD PTR _strDefault$[esp+89], ecx
  0003a	88 04 24	 mov	 BYTE PTR _strDefault$[esp+68], al
  0003d	88 44 24 20	 mov	 BYTE PTR _strGet$[esp+68], al

; 271  : 	sprintf(strDefault,"%d",nDefault);

  00041	8b 44 24 50	 mov	 eax, DWORD PTR _nDefault$[esp+64]
  00045	89 4c 24 19	 mov	 DWORD PTR _strDefault$[esp+93], ecx
  00049	89 54 24 31	 mov	 DWORD PTR _strGet$[esp+85], edx
  0004d	50		 push	 eax
  0004e	88 4c 24 21	 mov	 BYTE PTR _strDefault$[esp+101], cl
  00052	89 54 24 39	 mov	 DWORD PTR _strGet$[esp+93], edx
  00056	8d 4c 24 04	 lea	 ecx, DWORD PTR _strDefault$[esp+72]
  0005a	89 54 24 3d	 mov	 DWORD PTR _strGet$[esp+97], edx
  0005e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00063	51		 push	 ecx
  00064	88 54 24 49	 mov	 BYTE PTR _strGet$[esp+109], dl
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 272  : 	int nSize;
; 273  : 	nSize =29;
; 274  : 	DFN_GetPrivateProfileString(lpAppName,lpKeyName,strDefault,strGet,nSize,lpFileName);

  0006e	8b 54 24 60	 mov	 edx, DWORD PTR _lpFileName$[esp+76]
  00072	52		 push	 edx
  00073	8b 54 24 5c	 mov	 edx, DWORD PTR _lpKeyName$[esp+80]
  00077	6a 1d		 push	 29			; 0000001dH
  00079	8d 44 24 34	 lea	 eax, DWORD PTR _strGet$[esp+88]
  0007d	50		 push	 eax
  0007e	8b 44 24 60	 mov	 eax, DWORD PTR _lpAppName$[esp+88]
  00082	8d 4c 24 18	 lea	 ecx, DWORD PTR _strDefault$[esp+92]
  00086	51		 push	 ecx
  00087	52		 push	 edx
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z ; DFN_GetPrivateProfileString

; 275  : 	if(nSize>-1)
; 276  : 	{
; 277  : 		Result=atoi(strGet);

  0008e	8d 4c 24 44	 lea	 ecx, DWORD PTR _strGet$[esp+104]
  00092	51		 push	 ecx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi

; 278  : 	}
; 279  : 	else Result =nDefault;
; 280  : 	
; 281  : 	return Result;
; 282  : }

  00099	8b 4c 24 68	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+108]
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	83 c4 6c	 add	 esp, 108		; 0000006cH
  000a5	c3		 ret	 0
?DFN_GetPrivateProfileInt@@YAHPBD0H0@Z ENDP		; DFN_GetPrivateProfileInt
_TEXT	ENDS
PUBLIC	?DFN_WritePrivateProfileString@@YAHPBD000@Z	; DFN_WritePrivateProfileString
EXTRN	__imp__WritePrivateProfileStringA@16:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T66706	DD	0ffffffffH
	DD	FLAT:$L66662
	DD	00H
	DD	FLAT:$L66663
	DD	01H
	DD	FLAT:$L66664
	DD	02H
	DD	FLAT:$L66665
	DD	03H
	DD	FLAT:$L66666
	DD	04H
	DD	FLAT:$L66667
	DD	05H
	DD	FLAT:$L66668
$T66703	DD	019930520H
	DD	07H
	DD	FLAT:$T66706
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	ENDS
;	COMDAT ?DFN_WritePrivateProfileString@@YAHPBD000@Z
_TEXT	SEGMENT
$T66660 = -1220						; size = 4
_dfn_File$ = -1216					; size = 28
_dfn_Key$ = -1188					; size = 28
_dfn_Default$ = -1160					; size = 28
_dfn_Section$ = -1132					; size = 28
_strInt$ = -1104					; size = 28
_dfn_Val$ = -1076					; size = 28
_szPath$ = -1048					; size = 1024
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lpAppName$ = 8						; size = 4
_lpKeyName$ = 12					; size = 4
_lpString$ = 16						; size = 4
_lpFileName$ = 20					; size = 4
?DFN_WritePrivateProfileString@@YAHPBD000@Z PROC NEAR	; DFN_WritePrivateProfileString, COMDAT

; 292  : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?DFN_WritePrivateProfileString@@YAHPBD000@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec b8 04 00
	00		 sub	 esp, 1208		; 000004b8H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	57		 push	 edi

; 293  : 	BOOL Result = TRUE;
; 294  : 
; 295  : 	std::string dfn_Section;

  00029	8d 4c 24 64	 lea	 ecx, DWORD PTR _dfn_Section$[esp+1232]
  0002d	89 84 24 bc 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1232], eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 296  : 	std::string dfn_Key;

  0003a	8d 4c 24 2c	 lea	 ecx, DWORD PTR _dfn_Key$[esp+1232]
  0003e	c7 84 24 cc 04
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1240], 0
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 297  : 	std::string dfn_Default;

  0004f	8d 4c 24 48	 lea	 ecx, DWORD PTR _dfn_Default$[esp+1232]
  00053	c6 84 24 cc 04
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+1240], 1
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 298  : 	std::string dfn_File;

  00061	8d 4c 24 10	 lea	 ecx, DWORD PTR _dfn_File$[esp+1232]
  00065	c6 84 24 cc 04
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+1240], 2
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 299  : 	dfn_Section =lpAppName;

  00073	8b 75 08	 mov	 esi, DWORD PTR _lpAppName$[ebp]
  00076	56		 push	 esi
  00077	8d 4c 24 68	 lea	 ecx, DWORD PTR _dfn_Section$[esp+1236]
  0007b	c6 84 24 d0 04
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+1244], 3
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 300  : 	dfn_Key   = lpKeyName;

  00089	8b 5d 0c	 mov	 ebx, DWORD PTR _lpKeyName$[ebp]
  0008c	53		 push	 ebx
  0008d	8d 4c 24 30	 lea	 ecx, DWORD PTR _dfn_Key$[esp+1236]
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 301  : 	dfn_File = lpFileName;

  00097	8b 45 14	 mov	 eax, DWORD PTR _lpFileName$[ebp]
  0009a	50		 push	 eax
  0009b	8d 4c 24 14	 lea	 ecx, DWORD PTR _dfn_File$[esp+1236]
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 302  : 	dfn_Default = lpString;

  000a5	8b 4d 10	 mov	 ecx, DWORD PTR _lpString$[ebp]
  000a8	51		 push	 ecx
  000a9	8d 4c 24 4c	 lea	 ecx, DWORD PTR _dfn_Default$[esp+1236]
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 303  : 	
; 304  : 	std::string dfn_Val;

  000b3	8d 8c 24 9c 00
	00 00		 lea	 ecx, DWORD PTR _dfn_Val$[esp+1232]
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 305  : 	std::string strInt ;

  000c0	8d 8c 24 80 00
	00 00		 lea	 ecx, DWORD PTR _strInt$[esp+1232]
  000c7	c6 84 24 cc 04
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+1240], 4
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 306  : 	if(gRoot_path=="")

  000d5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000da	68 00 00 00 00	 push	 OFFSET FLAT:_gRoot_path
  000df	c6 84 24 d4 04
	00 00 05	 mov	 BYTE PTR __$EHRec$[esp+1248], 5
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
  000ed	83 c4 08	 add	 esp, 8
  000f0	84 c0		 test	 al, al
  000f2	74 2d		 je	 SHORT $L60649

; 307  : 			gRoot_path =FuncGetInstallPath();

  000f4	8d 54 24 0c	 lea	 edx, DWORD PTR $T66660[esp+1232]
  000f8	52		 push	 edx
  000f9	e8 00 00 00 00	 call	 ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
  000fe	83 c4 04	 add	 esp, 4
  00101	8b 00		 mov	 eax, DWORD PTR [eax]
  00103	50		 push	 eax
  00104	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_gRoot_path
  00109	c6 84 24 d0 04
	00 00 06	 mov	 BYTE PTR __$EHRec$[esp+1244], 6
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  00117	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T66660[esp+1232]
  0011b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L60649:

; 308  : 	char szPath[1024]={0};

  00121	33 c0		 xor	 eax, eax
  00123	c6 84 24 b8 00
	00 00 00	 mov	 BYTE PTR _szPath$[esp+1232], 0
  0012b	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00130	8d bc 24 b9 00
	00 00		 lea	 edi, DWORD PTR _szPath$[esp+1233]
  00137	f3 ab		 rep stosd

; 309  : 	sprintf(szPath,"%s\\data\\TmpIniFile\\%s",gRoot_path.c_str(),dfn_File.c_str());

  00139	8b 4c 24 28	 mov	 ecx, DWORD PTR _dfn_File$[esp+1256]
  0013d	66 ab		 stosw
  0013f	aa		 stosb
  00140	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00145	3b c8		 cmp	 ecx, eax
  00147	8b 4c 24 14	 mov	 ecx, DWORD PTR _dfn_File$[esp+1236]
  0014b	73 04		 jae	 SHORT $L66686
  0014d	8d 4c 24 14	 lea	 ecx, DWORD PTR _dfn_File$[esp+1236]
$L66686:
  00151	39 05 18 00 00
	00		 cmp	 DWORD PTR _gRoot_path+24, eax
  00157	a1 04 00 00 00	 mov	 eax, DWORD PTR _gRoot_path+4
  0015c	73 05		 jae	 SHORT $L66700
  0015e	b8 04 00 00 00	 mov	 eax, OFFSET FLAT:_gRoot_path+4
$L66700:
  00163	51		 push	 ecx
  00164	50		 push	 eax
  00165	8d 84 24 c0 00
	00 00		 lea	 eax, DWORD PTR _szPath$[esp+1240]
  0016c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@KFDBAEJB@?$CFs?2data?2TmpIniFile?2?$CFs?$AA@
  00171	50		 push	 eax
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 310  : 	//puts(szPath);
; 311  : 	WritePrivateProfileString(lpAppName,lpKeyName,lpString,szPath);

  00178	8b 55 10	 mov	 edx, DWORD PTR _lpString$[ebp]
  0017b	83 c4 10	 add	 esp, 16			; 00000010H
  0017e	8d 8c 24 b8 00
	00 00		 lea	 ecx, DWORD PTR _szPath$[esp+1232]
  00185	51		 push	 ecx
  00186	52		 push	 edx
  00187	53		 push	 ebx
  00188	56		 push	 esi
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WritePrivateProfileStringA@16

; 312  :     return Result;

  0018f	8d 8c 24 80 00
	00 00		 lea	 ecx, DWORD PTR _strInt$[esp+1232]
  00196	c6 84 24 cc 04
	00 00 04	 mov	 BYTE PTR __$EHRec$[esp+1240], 4
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001a4	8d 8c 24 9c 00
	00 00		 lea	 ecx, DWORD PTR _dfn_Val$[esp+1232]
  001ab	c6 84 24 cc 04
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+1240], 3
  001b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001b9	8d 4c 24 10	 lea	 ecx, DWORD PTR _dfn_File$[esp+1232]
  001bd	c6 84 24 cc 04
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+1240], 2
  001c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001cb	8d 4c 24 48	 lea	 ecx, DWORD PTR _dfn_Default$[esp+1232]
  001cf	c6 84 24 cc 04
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+1240], 1
  001d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001dd	8d 4c 24 2c	 lea	 ecx, DWORD PTR _dfn_Key$[esp+1232]
  001e1	c6 84 24 cc 04
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+1240], 0
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  001ef	8d 4c 24 64	 lea	 ecx, DWORD PTR _dfn_Section$[esp+1232]
  001f3	c7 84 24 cc 04
	00 00 ff ff ff
	ff		 mov	 DWORD PTR __$EHRec$[esp+1240], -1
  001fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 313  : }

  00204	8b 8c 24 c4 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1232]
  0020b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00212	8b 8c 24 bc 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1232]
  00219	b8 01 00 00 00	 mov	 eax, 1
  0021e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00223	5f		 pop	 edi
  00224	5e		 pop	 esi
  00225	5b		 pop	 ebx
  00226	8b e5		 mov	 esp, ebp
  00228	5d		 pop	 ebp
  00229	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66662:
  00000	8d 8d 94 fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_Section$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66663:
  0000c	8d 8d 5c fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_Key$[ebp]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66664:
  00018	8d 8d 78 fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_Default$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66665:
  00024	8d 8d 40 fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_File$[ebp]
  0002a	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66666:
  00030	8d 8d cc fb ff
	ff		 lea	 ecx, DWORD PTR _dfn_Val$[ebp]
  00036	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66667:
  0003c	8d 8d b0 fb ff
	ff		 lea	 ecx, DWORD PTR _strInt$[ebp]
  00042	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L66668:
  00048	8d 8d 3c fb ff
	ff		 lea	 ecx, DWORD PTR $T66660[ebp]
  0004e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?DFN_WritePrivateProfileString@@YAHPBD000@Z:
  00054	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66703
  00059	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?DFN_WritePrivateProfileString@@YAHPBD000@Z ENDP	; DFN_WritePrivateProfileString
PUBLIC	?FuncGetCountByMark@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ; FuncGetCountByMark
EXTRN	__imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T66745	DD	0ffffffffH
	DD	FLAT:$L66711
	DD	00H
	DD	FLAT:$L66712
	DD	01H
	DD	FLAT:$L66713
	DD	02H
	DD	FLAT:$L66714
	DD	03H
	DD	FLAT:$L66715
	DD	04H
	DD	FLAT:$L66716
$T66741	DD	019930520H
	DD	06H
	DD	FLAT:$T66745
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	ENDS
;	COMDAT ?FuncGetCountByMark@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z
_TEXT	SEGMENT
_strTemp$ = -28						; size = 4
_strRight$60667 = -24					; size = 4
_strLeft$60665 = -20					; size = 4
_strReturn$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_strWholeString$ = 8					; size = 4
_strMark$ = 12						; size = 4
?FuncGetCountByMark@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z PROC NEAR ; FuncGetCountByMark, COMDAT

; 317  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?FuncGetCountByMark@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	55		 push	 ebp
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 318  : 	CString strTemp = _T("");

  0001b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00020	8d 4c 24 10	 lea	 ecx, DWORD PTR _strTemp$[esp+44]
  00024	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+52], 1
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 319  : 	strTemp = strWholeString;

  00032	8d 44 24 2c	 lea	 eax, DWORD PTR _strWholeString$[esp+36]
  00036	50		 push	 eax
  00037	8d 4c 24 10	 lea	 ecx, DWORD PTR _strTemp$[esp+44]
  0003b	c6 44 24 28 02	 mov	 BYTE PTR __$EHRec$[esp+52], 2
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 320  : 
; 321  : 	int nIndex1 = strTemp.Find(strMark, 0);

  00046	8b 4c 24 30	 mov	 ecx, DWORD PTR _strMark$[esp+36]
  0004a	6a 00		 push	 0
  0004c	51		 push	 ecx
  0004d	8d 4c 24 14	 lea	 ecx, DWORD PTR _strTemp$[esp+48]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z

; 322  : 	int i = 0;
; 323  : 	CString strReturn = _T("");

  00057	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0005c	8d 4c 24 1c	 lea	 ecx, DWORD PTR _strReturn$[esp+44]
  00060	8b f0		 mov	 esi, eax
  00062	33 ff		 xor	 edi, edi
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 324  : 
; 325  : 	int nMarkByte = 0;
; 326  : 	nMarkByte = strMark.GetLength();
; 327  : 
; 328  : 	while (nIndex1!=-1) 

  0006a	83 fe ff	 cmp	 esi, -1
  0006d	8b 54 24 30	 mov	 edx, DWORD PTR _strMark$[esp+36]
  00071	8b 6a f4	 mov	 ebp, DWORD PTR [edx-12]
  00074	c6 44 24 24 03	 mov	 BYTE PTR __$EHRec$[esp+48], 3
  00079	74 7b		 je	 SHORT $L60664
  0007b	eb 03 8d 49 00	 npad	 5
$L60663:

; 329  : 	{
; 330  : 		i++;
; 331  : 		
; 332  : 		CString strLeft = strTemp.Left(nIndex1);

  00080	56		 push	 esi
  00081	8d 44 24 18	 lea	 eax, DWORD PTR _strLeft$60665[esp+44]
  00085	50		 push	 eax
  00086	8d 4c 24 14	 lea	 ecx, DWORD PTR _strTemp$[esp+48]
  0008a	47		 inc	 edi
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z

; 333  : 		CString strRight = strTemp.Right(strTemp.GetLength()-nIndex1-nMarkByte);

  00091	8b 4c 24 0c	 mov	 ecx, DWORD PTR _strTemp$[esp+40]
  00095	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
  00098	2b c5		 sub	 eax, ebp
  0009a	2b c6		 sub	 eax, esi
  0009c	50		 push	 eax
  0009d	8d 54 24 14	 lea	 edx, DWORD PTR _strRight$60667[esp+44]
  000a1	52		 push	 edx
  000a2	8d 4c 24 14	 lea	 ecx, DWORD PTR _strTemp$[esp+48]
  000a6	c6 44 24 2c 04	 mov	 BYTE PTR __$EHRec$[esp+56], 4
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Right@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z

; 334  : 		
; 335  : 		nIndex1 = strRight.Find(strMark, 0);

  000b1	8b 44 24 30	 mov	 eax, DWORD PTR _strMark$[esp+36]
  000b5	6a 00		 push	 0
  000b7	50		 push	 eax
  000b8	8d 4c 24 18	 lea	 ecx, DWORD PTR _strRight$60667[esp+48]
  000bc	c6 44 24 2c 05	 mov	 BYTE PTR __$EHRec$[esp+56], 5
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z

; 336  : 		strTemp = strRight;	

  000c7	8d 4c 24 10	 lea	 ecx, DWORD PTR _strRight$60667[esp+40]
  000cb	51		 push	 ecx
  000cc	8d 4c 24 10	 lea	 ecx, DWORD PTR _strTemp$[esp+44]
  000d0	8b f0		 mov	 esi, eax
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 337  : 	}

  000d8	8d 4c 24 10	 lea	 ecx, DWORD PTR _strRight$60667[esp+40]
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000e2	8d 4c 24 14	 lea	 ecx, DWORD PTR _strLeft$60665[esp+40]
  000e6	c6 44 24 24 03	 mov	 BYTE PTR __$EHRec$[esp+48], 3
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f1	83 fe ff	 cmp	 esi, -1
  000f4	75 8a		 jne	 SHORT $L60663
$L60664:

; 338  : 
; 339  : 	return i;

  000f6	8d 4c 24 18	 lea	 ecx, DWORD PTR _strReturn$[esp+40]
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00100	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strTemp$[esp+40]
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0010a	8d 4c 24 2c	 lea	 ecx, DWORD PTR _strWholeString$[esp+36]
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00114	8d 4c 24 30	 lea	 ecx, DWORD PTR _strMark$[esp+36]
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 340  : }

  0011e	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  00122	8b c7		 mov	 eax, edi
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5d		 pop	 ebp
  00127	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0012e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00131	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66711:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strMark$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66712:
  00009	8d 4d 04	 lea	 ecx, DWORD PTR _strWholeString$[ebp-4]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66713:
  00012	8d 4d e4	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66714:
  0001b	8d 4d f0	 lea	 ecx, DWORD PTR _strReturn$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66715:
  00024	8d 4d ec	 lea	 ecx, DWORD PTR _strLeft$60665[ebp]
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66716:
  0002d	8d 4d e8	 lea	 ecx, DWORD PTR _strRight$60667[ebp]
  00030	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FuncGetCountByMark@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z:
  00036	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66741
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetCountByMark@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ENDP ; FuncGetCountByMark
PUBLIC	?FuncGetProfileIntBy@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z ; FuncGetProfileIntBy
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T66772	DD	0ffffffffH
	DD	FLAT:$L66752
	DD	00H
	DD	FLAT:$L66753
	DD	01H
	DD	FLAT:$L66754
	DD	02H
	DD	FLAT:$L66755
$T66769	DD	019930520H
	DD	04H
	DD	FLAT:$T66772
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	ENDS
;	COMDAT ?FuncGetProfileIntBy@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z
_TEXT	SEGMENT
_strString$ = -532					; size = 4
_buffer$ = -528						; size = 512
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_strSection$ = 8					; size = 4
_strKey$ = 12						; size = 4
_strFileName$ = 16					; size = 4
?FuncGetProfileIntBy@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z PROC NEAR ; FuncGetProfileIntBy, COMDAT

; 343  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?FuncGetProfileIntBy@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 08 02 00
	00		 sub	 esp, 520		; 00000208H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	56		 push	 esi
  00021	89 84 24 08 02
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+536], eax
  00028	57		 push	 edi

; 344  : 	char	buffer[512] = {0};
; 345  : 	DWORD nSize = 256;
; 346  :     DFN_GetPrivateProfileString(strSection, strKey, _T(""), buffer, nSize, strFileName);

  00029	8b 94 24 24 02
	00 00		 mov	 edx, DWORD PTR _strKey$[esp+536]
  00030	33 c0		 xor	 eax, eax
  00032	c6 44 24 0c 00	 mov	 BYTE PTR _buffer$[esp+540], 0
  00037	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  0003c	8d 7c 24 0d	 lea	 edi, DWORD PTR _buffer$[esp+541]
  00040	f3 ab		 rep stosd
  00042	66 ab		 stosw
  00044	aa		 stosb
  00045	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR _strFileName$[esp+536]
  0004c	50		 push	 eax
  0004d	8b 84 24 24 02
	00 00		 mov	 eax, DWORD PTR _strSection$[esp+540]
  00054	68 00 01 00 00	 push	 256			; 00000100H
  00059	8d 4c 24 14	 lea	 ecx, DWORD PTR _buffer$[esp+548]
  0005d	51		 push	 ecx
  0005e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00063	52		 push	 edx
  00064	50		 push	 eax
  00065	c7 84 24 30 02
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+572], 2
  00070	e8 00 00 00 00	 call	 ?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z ; DFN_GetPrivateProfileString
  00075	83 c4 18	 add	 esp, 24			; 00000018H

; 347  : 
; 348  : 	CString strString = _T("");

  00078	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0007d	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strString$[esp+544]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 349  : 	strString = buffer;

  00087	8d 4c 24 0c	 lea	 ecx, DWORD PTR _buffer$[esp+540]
  0008b	51		 push	 ecx
  0008c	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strString$[esp+544]
  00090	c6 84 24 1c 02
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+552], 3
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 350  : 
; 351  : 	int nReturnValue = atoi(strString);

  0009e	8b 54 24 08	 mov	 edx, DWORD PTR _strString$[esp+540]
  000a2	52		 push	 edx
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__atoi
  000a9	83 c4 04	 add	 esp, 4

; 352  : 	return nReturnValue;

  000ac	8d 4c 24 08	 lea	 ecx, DWORD PTR _strString$[esp+540]
  000b0	8b f0		 mov	 esi, eax
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000b8	8d 8c 24 20 02
	00 00		 lea	 ecx, DWORD PTR _strSection$[esp+536]
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000c5	8d 8c 24 24 02
	00 00		 lea	 ecx, DWORD PTR _strKey$[esp+536]
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d2	8d 8c 24 28 02
	00 00		 lea	 ecx, DWORD PTR _strFileName$[esp+536]
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 353  : }

  000df	8b 8c 24 10 02
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+540]
  000e6	5f		 pop	 edi
  000e7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ee	8b 8c 24 08 02
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+536]
  000f5	8b c6		 mov	 eax, esi
  000f7	5e		 pop	 esi
  000f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fd	81 c4 14 02 00
	00		 add	 esp, 532		; 00000214H
  00103	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66752:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _strFileName$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66753:
  00009	8d 4d 08	 lea	 ecx, DWORD PTR _strKey$[ebp-4]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66754:
  00012	8d 4d 04	 lea	 ecx, DWORD PTR _strSection$[ebp-4]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66755:
  0001b	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR _strString$[ebp]
  00021	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FuncGetProfileIntBy@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z:
  00027	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66769
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetProfileIntBy@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@00@Z ENDP ; FuncGetProfileIntBy
PUBLIC	?FuncGetLeftStringByMark@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0H@Z ; FuncGetLeftStringByMark
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T66814	DD	0ffffffffH
	DD	FLAT:$L66777
	DD	00H
	DD	FLAT:$L66778
	DD	01H
	DD	FLAT:$L66779
	DD	02H
	DD	FLAT:$L66780
	DD	03H
	DD	FLAT:$L66781
	DD	04H
	DD	FLAT:$L66782
$T66810	DD	019930520H
	DD	06H
	DD	FLAT:$T66814
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	ENDS
;	COMDAT ?FuncGetLeftStringByMark@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0H@Z
_TEXT	SEGMENT
_strTemp$ = -28						; size = 4
_strRight$60696 = -24					; size = 4
_strReturn$ = -20					; size = 4
$T66784 = -16						; size = 4
_strLeft$60694 = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_strWholeString$ = 12					; size = 4
_strMark$ = 16						; size = 4
_nIndex$ = 20						; size = 4
?FuncGetLeftStringByMark@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0H@Z PROC NEAR ; FuncGetLeftStringByMark, COMDAT

; 356  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?FuncGetLeftStringByMark@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0H@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	55		 push	 ebp
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 357  : 	CString strTemp = _T("");
; 358  : 	strTemp = strWholeString;
; 359  : 	
; 360  : 	int nIndex1 = strTemp.Find(strMark, 0);
; 361  : 	int i = 0;
; 362  : 	CString strReturn = _T("");
; 363  : 	int nMarkByte = 0;
; 364  : 	nMarkByte = strMark.GetLength();
; 365  : 
; 366  : 	while (nIndex1!=-1) 
; 367  : 	{
; 368  : 		i++;
; 369  : 		
; 370  : 		CString strLeft = strTemp.Left(nIndex1);
; 371  : 		CString strRight = strTemp.Right(strTemp.GetLength()-nIndex1-nMarkByte);
; 372  : 
; 373  : 		if (i == nIndex)
; 374  : 			strReturn = strLeft;
; 375  : 		
; 376  : 		nIndex1 = strRight.Find(strMark, 0);

  0001b	33 ff		 xor	 edi, edi
  0001d	89 7c 24 18	 mov	 DWORD PTR $T66784[esp+40], edi
  00021	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00026	8d 4c 24 10	 lea	 ecx, DWORD PTR _strTemp$[esp+44]
  0002a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+52], 1
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00038	8d 44 24 30	 lea	 eax, DWORD PTR _strWholeString$[esp+36]
  0003c	50		 push	 eax
  0003d	8d 4c 24 10	 lea	 ecx, DWORD PTR _strTemp$[esp+44]
  00041	c6 44 24 28 02	 mov	 BYTE PTR __$EHRec$[esp+52], 2
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0004c	8b 4c 24 34	 mov	 ecx, DWORD PTR _strMark$[esp+36]
  00050	57		 push	 edi
  00051	51		 push	 ecx
  00052	8d 4c 24 14	 lea	 ecx, DWORD PTR _strTemp$[esp+48]
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00061	8d 4c 24 18	 lea	 ecx, DWORD PTR _strReturn$[esp+44]
  00065	8b f0		 mov	 esi, eax
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0006d	83 fe ff	 cmp	 esi, -1
  00070	8b 54 24 34	 mov	 edx, DWORD PTR _strMark$[esp+36]
  00074	8b 6a f4	 mov	 ebp, DWORD PTR [edx-12]
  00077	c6 44 24 24 03	 mov	 BYTE PTR __$EHRec$[esp+48], 3
  0007c	0f 84 93 00 00
	00		 je	 $L60693
  00082	53		 push	 ebx
  00083	8b 5c 24 3c	 mov	 ebx, DWORD PTR _nIndex$[esp+40]
$L60692:
  00087	56		 push	 esi
  00088	8d 44 24 20	 lea	 eax, DWORD PTR _strLeft$60694[esp+48]
  0008c	50		 push	 eax
  0008d	8d 4c 24 18	 lea	 ecx, DWORD PTR _strTemp$[esp+52]
  00091	47		 inc	 edi
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  00098	8b 4c 24 10	 mov	 ecx, DWORD PTR _strTemp$[esp+44]
  0009c	8b 41 f4	 mov	 eax, DWORD PTR [ecx-12]
  0009f	2b c5		 sub	 eax, ebp
  000a1	2b c6		 sub	 eax, esi
  000a3	50		 push	 eax
  000a4	8d 54 24 18	 lea	 edx, DWORD PTR _strRight$60696[esp+48]
  000a8	52		 push	 edx
  000a9	8d 4c 24 18	 lea	 ecx, DWORD PTR _strTemp$[esp+52]
  000ad	c6 44 24 30 04	 mov	 BYTE PTR __$EHRec$[esp+60], 4
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Right@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  000b8	3b fb		 cmp	 edi, ebx
  000ba	c6 44 24 28 05	 mov	 BYTE PTR __$EHRec$[esp+52], 5
  000bf	75 0f		 jne	 SHORT $L60698
  000c1	8d 44 24 1c	 lea	 eax, DWORD PTR _strLeft$60694[esp+44]
  000c5	50		 push	 eax
  000c6	8d 4c 24 1c	 lea	 ecx, DWORD PTR _strReturn$[esp+48]
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$L60698:
  000d0	8b 4c 24 38	 mov	 ecx, DWORD PTR _strMark$[esp+40]
  000d4	6a 00		 push	 0
  000d6	51		 push	 ecx
  000d7	8d 4c 24 1c	 lea	 ecx, DWORD PTR _strRight$60696[esp+52]
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z

; 377  : 		strTemp = strRight;	

  000e1	8d 54 24 14	 lea	 edx, DWORD PTR _strRight$60696[esp+44]
  000e5	52		 push	 edx
  000e6	8d 4c 24 14	 lea	 ecx, DWORD PTR _strTemp$[esp+48]
  000ea	8b f0		 mov	 esi, eax
  000ec	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 378  : 	}

  000f2	8d 4c 24 14	 lea	 ecx, DWORD PTR _strRight$60696[esp+44]
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000fc	8d 4c 24 1c	 lea	 ecx, DWORD PTR _strLeft$60694[esp+44]
  00100	c6 44 24 28 03	 mov	 BYTE PTR __$EHRec$[esp+52], 3
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0010b	83 fe ff	 cmp	 esi, -1
  0010e	0f 85 73 ff ff
	ff		 jne	 $L60692
  00114	5b		 pop	 ebx
$L60693:

; 379  : 
; 380  : 	return strReturn;

  00115	8b 74 24 2c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+36]
  00119	8d 44 24 14	 lea	 eax, DWORD PTR _strReturn$[esp+40]
  0011d	50		 push	 eax
  0011e	8b ce		 mov	 ecx, esi
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00126	8d 4c 24 14	 lea	 ecx, DWORD PTR _strReturn$[esp+40]
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00130	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strTemp$[esp+40]
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0013a	8d 4c 24 30	 lea	 ecx, DWORD PTR _strWholeString$[esp+36]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00144	8d 4c 24 34	 lea	 ecx, DWORD PTR _strMark$[esp+36]
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 381  : }

  0014e	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  00152	5f		 pop	 edi
  00153	8b c6		 mov	 eax, esi
  00155	5e		 pop	 esi
  00156	5d		 pop	 ebp
  00157	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0015e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00161	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66777:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _strMark$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66778:
  00009	8d 4d 08	 lea	 ecx, DWORD PTR _strWholeString$[ebp-4]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66779:
  00012	8d 4d e4	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66780:
  0001b	8d 4d ec	 lea	 ecx, DWORD PTR _strReturn$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66781:
  00024	8d 4d f0	 lea	 ecx, DWORD PTR _strLeft$60694[ebp]
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66782:
  0002d	8d 4d e8	 lea	 ecx, DWORD PTR _strRight$60696[ebp]
  00030	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FuncGetLeftStringByMark@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0H@Z:
  00036	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66810
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetLeftStringByMark@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0H@Z ENDP ; FuncGetLeftStringByMark
PUBLIC	??_C@_0BC@MBOFKFHK@?$CFd?9?$CFd?9?$CFd?5?$CFd?3?$CFd?3?$CFd?$AA@ ; `string'
PUBLIC	?TimeToString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@VCTime@2@@Z ; TimeToString
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atltime.inl
xdata$x	SEGMENT
$T66958	DD	0ffffffffH
	DD	FLAT:$L66819
$T66956	DD	019930520H
	DD	01H
	DD	FLAT:$T66958
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BC@MBOFKFHK@?$CFd?9?$CFd?9?$CFd?5?$CFd?3?$CFd?3?$CFd?$AA@
CONST	SEGMENT
??_C@_0BC@MBOFKFHK@?$CFd?9?$CFd?9?$CFd?5?$CFd?3?$CFd?3?$CFd?$AA@ DB '%d-%'
	DB	'd-%d %d:%d:%d', 00H				; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?TimeToString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@VCTime@2@@Z
_TEXT	SEGMENT
_strTime$ = -24						; size = 4
tv134 = -20						; size = 4
tv143 = -16						; size = 4
$T66821 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_Time$ = 12						; size = 8
?TimeToString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@VCTime@2@@Z PROC NEAR ; TimeToString, COMDAT

; 385  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?TimeToString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@VCTime@2@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 386  : 	CString strTime = _T("");
; 387  : 	strTime.Format("%d-%d-%d %d:%d:%d", Time.GetYear(), Time.GetMonth(), 
; 388  :         Time.GetDay(), Time.GetHour(), Time.GetMinute(), Time.GetSecond());

  0001c	33 f6		 xor	 esi, esi
  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00023	8d 4c 24 14	 lea	 ecx, DWORD PTR _strTime$[esp+44]
  00027	89 74 24 1c	 mov	 DWORD PTR $T66821[esp+44], esi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  00031	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp___localtime64
  00037	8d 44 24 30	 lea	 eax, DWORD PTR _Time$[esp+36]
  0003b	50		 push	 eax
  0003c	89 74 24 28	 mov	 DWORD PTR __$EHRec$[esp+52], esi
  00040	ff d7		 call	 edi
  00042	83 c4 04	 add	 esp, 4
  00045	83 cd ff	 or	 ebp, -1
  00048	3b c6		 cmp	 eax, esi
  0004a	74 08		 je	 SHORT $L66837
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 4c 24 14	 mov	 DWORD PTR tv134[esp+40], ecx
  00052	eb 04		 jmp	 SHORT $L66838
$L66837:
  00054	89 6c 24 14	 mov	 DWORD PTR tv134[esp+40], ebp
$L66838:
  00058	8d 54 24 30	 lea	 edx, DWORD PTR _Time$[esp+36]
  0005c	52		 push	 edx
  0005d	ff d7		 call	 edi
  0005f	83 c4 04	 add	 esp, 4
  00062	3b c6		 cmp	 eax, esi
  00064	74 09		 je	 SHORT $L66859
  00066	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00069	89 44 24 18	 mov	 DWORD PTR tv143[esp+40], eax
  0006d	eb 04		 jmp	 SHORT $L66860
$L66859:
  0006f	89 6c 24 18	 mov	 DWORD PTR tv143[esp+40], ebp
$L66860:
  00073	8d 4c 24 30	 lea	 ecx, DWORD PTR _Time$[esp+36]
  00077	51		 push	 ecx
  00078	ff d7		 call	 edi
  0007a	83 c4 04	 add	 esp, 4
  0007d	3b c6		 cmp	 eax, esi
  0007f	74 03		 je	 SHORT $L66882
  00081	8b 68 08	 mov	 ebp, DWORD PTR [eax+8]
$L66882:
  00084	8d 54 24 30	 lea	 edx, DWORD PTR _Time$[esp+36]
  00088	52		 push	 edx
  00089	ff d7		 call	 edi
  0008b	83 c4 04	 add	 esp, 4
  0008e	3b c6		 cmp	 eax, esi
  00090	74 05		 je	 SHORT $L66903
  00092	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00095	eb 02		 jmp	 SHORT $L66904
$L66903:
  00097	33 db		 xor	 ebx, ebx
$L66904:
  00099	8d 44 24 30	 lea	 eax, DWORD PTR _Time$[esp+36]
  0009d	50		 push	 eax
  0009e	ff d7		 call	 edi
  000a0	83 c4 04	 add	 esp, 4
  000a3	3b c6		 cmp	 eax, esi
  000a5	74 04		 je	 SHORT $L66926
  000a7	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  000aa	46		 inc	 esi
$L66926:
  000ab	8d 4c 24 30	 lea	 ecx, DWORD PTR _Time$[esp+36]
  000af	51		 push	 ecx
  000b0	ff d7		 call	 edi
  000b2	83 c4 04	 add	 esp, 4
  000b5	85 c0		 test	 eax, eax
  000b7	74 0a		 je	 SHORT $L66947
  000b9	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000bc	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  000c1	eb 02		 jmp	 SHORT $L66948
$L66947:
  000c3	33 c0		 xor	 eax, eax
$L66948:
  000c5	8b 54 24 14	 mov	 edx, DWORD PTR tv134[esp+40]
  000c9	8b 4c 24 18	 mov	 ecx, DWORD PTR tv143[esp+40]
  000cd	52		 push	 edx
  000ce	51		 push	 ecx
  000cf	55		 push	 ebp
  000d0	53		 push	 ebx
  000d1	56		 push	 esi
  000d2	50		 push	 eax
  000d3	8d 54 24 28	 lea	 edx, DWORD PTR _strTime$[esp+64]
  000d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@MBOFKFHK@?$CFd?9?$CFd?9?$CFd?5?$CFd?3?$CFd?3?$CFd?$AA@
  000dc	52		 push	 edx
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ

; 389  : 	return strTime;

  000e3	8b 74 24 4c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+68]
  000e7	83 c4 20	 add	 esp, 32			; 00000020H
  000ea	8d 44 24 10	 lea	 eax, DWORD PTR _strTime$[esp+40]
  000ee	50		 push	 eax
  000ef	8b ce		 mov	 ecx, esi
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  000f7	8d 4c 24 10	 lea	 ecx, DWORD PTR _strTime$[esp+40]
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 390  : }

  00101	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  00105	5f		 pop	 edi
  00106	8b c6		 mov	 eax, esi
  00108	5e		 pop	 esi
  00109	5d		 pop	 ebp
  0010a	5b		 pop	 ebx
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00112	83 c4 18	 add	 esp, 24			; 00000018H
  00115	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66819:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _strTime$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?TimeToString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@VCTime@2@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66956
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?TimeToString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@VCTime@2@@Z ENDP ; TimeToString
PUBLIC	?CreateListByStringandMark@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCStringList@@0@Z ; CreateListByStringandMark
EXTRN	?AddTail@CStringList@@QAEPAU__POSITION@@ABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:NEAR ; CStringList::AddTail
;	COMDAT xdata$x
xdata$x	SEGMENT
$T66980	DD	0ffffffffH
	DD	FLAT:$L66968
	DD	00H
	DD	FLAT:$L66969
	DD	01H
	DD	FLAT:$L66970
	DD	01H
	DD	FLAT:$L66972
	DD	01H
	DD	FLAT:$L66974
$T66976	DD	019930520H
	DD	05H
	DD	FLAT:$T66980
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ?CreateListByStringandMark@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCStringList@@0@Z
_TEXT	SEGMENT
$T66967 = -24						; size = 4
$T66963 = -24						; size = 4
$T66965 = -20						; size = 4
$T66964 = -20						; size = 4
$T66966 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_strSource$ = 8						; size = 4
_strDesList$ = 12					; size = 4
_strMark$ = 16						; size = 4
?CreateListByStringandMark@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCStringList@@0@Z PROC NEAR ; CreateListByStringandMark, COMDAT

; 417  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?CreateListByStringandMark@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCStringList@@0@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	57		 push	 edi

; 418  : 	int nEmail=FuncGetCountByMark( strSource,strMark);

  0001c	51		 push	 ecx
  0001d	8d 44 24 38	 lea	 eax, DWORD PTR _strMark$[esp+40]
  00021	8b cc		 mov	 ecx, esp
  00023	89 64 24 14	 mov	 DWORD PTR $T66963[esp+44], esp
  00027	bb 01 00 00 00	 mov	 ebx, 1
  0002c	50		 push	 eax
  0002d	89 5c 24 2c	 mov	 DWORD PTR __$EHRec$[esp+56], ebx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00037	51		 push	 ecx
  00038	8d 54 24 34	 lea	 edx, DWORD PTR _strSource$[esp+44]
  0003c	8b cc		 mov	 ecx, esp
  0003e	89 64 24 1c	 mov	 DWORD PTR $T66964[esp+48], esp
  00042	52		 push	 edx
  00043	c6 44 24 30 02	 mov	 BYTE PTR __$EHRec$[esp+60], 2
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  0004e	88 5c 24 2c	 mov	 BYTE PTR __$EHRec$[esp+56], bl
  00052	e8 00 00 00 00	 call	 ?FuncGetCountByMark@@YAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0@Z ; FuncGetCountByMark
  00057	8b f8		 mov	 edi, eax
  00059	83 c4 08	 add	 esp, 8

; 419  : 	for(int i = 1; i <= nEmail; i++)

  0005c	3b fb		 cmp	 edi, ebx
  0005e	8b f3		 mov	 esi, ebx
  00060	7c 5f		 jl	 SHORT $L60732
  00062	8b 6c 24 30	 mov	 ebp, DWORD PTR _strDesList$[esp+36]
$L60730:

; 420  : 		strDesList.AddTail( FuncGetLeftStringByMark(strSource,strMark,i));

  00066	56		 push	 esi
  00067	51		 push	 ecx
  00068	8d 44 24 3c	 lea	 eax, DWORD PTR _strMark$[esp+44]
  0006c	8b cc		 mov	 ecx, esp
  0006e	89 64 24 1c	 mov	 DWORD PTR $T66965[esp+48], esp
  00072	50		 push	 eax
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00079	51		 push	 ecx
  0007a	8d 54 24 38	 lea	 edx, DWORD PTR _strSource$[esp+48]
  0007e	8b cc		 mov	 ecx, esp
  00080	89 64 24 24	 mov	 DWORD PTR $T66966[esp+52], esp
  00084	52		 push	 edx
  00085	c6 44 24 34 03	 mov	 BYTE PTR __$EHRec$[esp+64], 3
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00090	8d 44 24 1c	 lea	 eax, DWORD PTR $T66967[esp+52]
  00094	50		 push	 eax
  00095	88 5c 24 34	 mov	 BYTE PTR __$EHRec$[esp+64], bl
  00099	e8 00 00 00 00	 call	 ?FuncGetLeftStringByMark@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0H@Z ; FuncGetLeftStringByMark
  0009e	83 c4 10	 add	 esp, 16			; 00000010H
  000a1	50		 push	 eax
  000a2	8b cd		 mov	 ecx, ebp
  000a4	c6 44 24 28 04	 mov	 BYTE PTR __$EHRec$[esp+52], 4
  000a9	e8 00 00 00 00	 call	 ?AddTail@CStringList@@QAEPAU__POSITION@@ABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringList::AddTail
  000ae	8d 4c 24 10	 lea	 ecx, DWORD PTR $T66967[esp+40]
  000b2	88 5c 24 24	 mov	 BYTE PTR __$EHRec$[esp+48], bl
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000bc	46		 inc	 esi
  000bd	3b f7		 cmp	 esi, edi
  000bf	7e a5		 jle	 SHORT $L60730
$L60732:

; 421  : }

  000c1	8d 4c 24 2c	 lea	 ecx, DWORD PTR _strSource$[esp+36]
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000cb	8d 4c 24 34	 lea	 ecx, DWORD PTR _strMark$[esp+36]
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d5	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$EHRec$[esp+40]
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi
  000db	5d		 pop	 ebp
  000dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e3	5b		 pop	 ebx
  000e4	83 c4 18	 add	 esp, 24			; 00000018H
  000e7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66968:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _strMark$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66969:
  00009	8d 4d 04	 lea	 ecx, DWORD PTR _strSource$[ebp-4]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66970:
  00012	8b 4d e8	 mov	 ecx, DWORD PTR $T66963[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66972:
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR $T66965[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66974:
  00024	8d 4d e8	 lea	 ecx, DWORD PTR $T66967[ebp]
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?CreateListByStringandMark@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCStringList@@0@Z:
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T66976
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateListByStringandMark@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@AAVCStringList@@0@Z ENDP ; CreateListByStringandMark
PUBLIC	?FuncGetProfileStringBy@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@00@Z ; FuncGetProfileStringBy
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T67006	DD	0ffffffffH
	DD	FLAT:$L66986
	DD	00H
	DD	FLAT:$L66987
	DD	01H
	DD	FLAT:$L66988
	DD	02H
	DD	FLAT:$L66989
$T67003	DD	019930520H
	DD	04H
	DD	FLAT:$T67006
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	ENDS
;	COMDAT ?FuncGetProfileStringBy@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@00@Z
_TEXT	SEGMENT
$T66991 = -2068						; size = 4
_strString$ = -2068					; size = 4
_buffer$ = -2064					; size = 2048
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_strSection$ = 12					; size = 4
_strKey$ = 16						; size = 4
_strFileName$ = 20					; size = 4
?FuncGetProfileStringBy@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@00@Z PROC NEAR ; FuncGetProfileStringBy, COMDAT

; 485  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?FuncGetProfileStringBy@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@00@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 08 08 00
	00		 sub	 esp, 2056		; 00000808H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	89 84 24 04 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2068], eax
  00027	56		 push	 esi
  00028	33 c0		 xor	 eax, eax
  0002a	57		 push	 edi
  0002b	89 44 24 08	 mov	 DWORD PTR $T66991[esp+2076], eax

; 486  : 	char	buffer[2048] = {0};
; 487  : 	DWORD nSize = 2048;
; 488  :     DFN_GetPrivateProfileString(strSection, strKey, _T(""), buffer, nSize, strFileName);

  0002f	8b 94 24 28 08
	00 00		 mov	 edx, DWORD PTR _strKey$[esp+2072]
  00036	88 44 24 0c	 mov	 BYTE PTR _buffer$[esp+2076], al
  0003a	b9 ff 01 00 00	 mov	 ecx, 511		; 000001ffH
  0003f	8d 7c 24 0d	 lea	 edi, DWORD PTR _buffer$[esp+2077]
  00043	f3 ab		 rep stosd
  00045	66 ab		 stosw
  00047	aa		 stosb
  00048	8b 84 24 2c 08
	00 00		 mov	 eax, DWORD PTR _strFileName$[esp+2072]
  0004f	50		 push	 eax
  00050	8b 84 24 28 08
	00 00		 mov	 eax, DWORD PTR _strSection$[esp+2076]
  00057	68 00 08 00 00	 push	 2048			; 00000800H
  0005c	8d 4c 24 14	 lea	 ecx, DWORD PTR _buffer$[esp+2084]
  00060	51		 push	 ecx
  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	c7 84 24 30 08
	00 00 02 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+2108], 2
  00073	e8 00 00 00 00	 call	 ?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z ; DFN_GetPrivateProfileString
  00078	83 c4 18	 add	 esp, 24			; 00000018H

; 489  : 
; 490  : 	CString strString = _T("");

  0007b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00080	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strString$[esp+2080]
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 491  : 	strString = buffer;

  0008a	8d 4c 24 0c	 lea	 ecx, DWORD PTR _buffer$[esp+2076]
  0008e	51		 push	 ecx
  0008f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strString$[esp+2080]
  00093	c6 84 24 1c 08
	00 00 03	 mov	 BYTE PTR __$EHRec$[esp+2088], 3
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 492  : 
; 493  : 	return strString;

  000a1	8b b4 24 20 08
	00 00		 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+2072]
  000a8	8d 54 24 08	 lea	 edx, DWORD PTR _strString$[esp+2076]
  000ac	52		 push	 edx
  000ad	8b ce		 mov	 ecx, esi
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  000b5	8d 4c 24 08	 lea	 ecx, DWORD PTR _strString$[esp+2076]
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000bf	8d 8c 24 24 08
	00 00		 lea	 ecx, DWORD PTR _strSection$[esp+2072]
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000cc	8d 8c 24 28 08
	00 00		 lea	 ecx, DWORD PTR _strKey$[esp+2072]
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000d9	8d 8c 24 2c 08
	00 00		 lea	 ecx, DWORD PTR _strFileName$[esp+2072]
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 494  : }

  000e6	8b 8c 24 10 08
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+2076]
  000ed	5f		 pop	 edi
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f5	8b 8c 24 08 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2072]
  000fc	8b c6		 mov	 eax, esi
  000fe	5e		 pop	 esi
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	81 c4 14 08 00
	00		 add	 esp, 2068		; 00000814H
  0010a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L66986:
  00000	8d 4d 10	 lea	 ecx, DWORD PTR _strFileName$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66987:
  00009	8d 4d 0c	 lea	 ecx, DWORD PTR _strKey$[ebp-4]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66988:
  00012	8d 4d 08	 lea	 ecx, DWORD PTR _strSection$[ebp-4]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L66989:
  0001b	8d 8d ec f7 ff
	ff		 lea	 ecx, DWORD PTR _strString$[ebp]
  00021	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FuncGetProfileStringBy@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@00@Z:
  00027	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67003
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetProfileStringBy@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@00@Z ENDP ; FuncGetProfileStringBy
PUBLIC	??_C@_0BK@DHDFGIGF@?$CFs?2groups?2resource?4config?$AA@ ; `string'
PUBLIC	??_C@_0M@DHIAIDA@CompanyName?$AA@		; `string'
PUBLIC	??_C@_08FLGELGHE@Resource?$AA@			; `string'
PUBLIC	?FuncGetCompanyName@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; FuncGetCompanyName
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T67026	DD	0ffffffffH
	DD	FLAT:$L67013
	DD	00H
	DD	FLAT:$L67014
	DD	00H
	DD	FLAT:$L67015
$T67023	DD	019930520H
	DD	03H
	DD	FLAT:$T67026
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BK@DHDFGIGF@?$CFs?2groups?2resource?4config?$AA@
CONST	SEGMENT
??_C@_0BK@DHDFGIGF@?$CFs?2groups?2resource?4config?$AA@ DB '%s\groups\res'
	DB	'ource.config', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DHIAIDA@CompanyName?$AA@
CONST	SEGMENT
??_C@_0M@DHIAIDA@CompanyName?$AA@ DB 'CompanyName', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FLGELGHE@Resource?$AA@
CONST	SEGMENT
??_C@_08FLGELGHE@Resource?$AA@ DB 'Resource', 00H	; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?FuncGetCompanyName@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_strPath$ = -1060					; size = 4
_strResourceFile$ = -1056				; size = 4
$T67012 = -1052						; size = 4
_buffer$ = -1048					; size = 1024
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_strRet$ = 8						; size = 4
?FuncGetCompanyName@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; FuncGetCompanyName, COMDAT

; 497  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?FuncGetCompanyName@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec 18 04 00
	00		 sub	 esp, 1048		; 00000418H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	57		 push	 edi
  00027	89 84 24 14 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1064], eax

; 498  : 	CString strPath = _T("");

  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00033	8d 4c 24 08	 lea	 ecx, DWORD PTR _strPath$[esp+1068]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 499  : 	strPath = ::FuncGetInstallPath();

  0003d	8d 44 24 0c	 lea	 eax, DWORD PTR $T67012[esp+1064]
  00041	50		 push	 eax
  00042	c7 84 24 28 04
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1076], 0
  0004d	e8 00 00 00 00	 call	 ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8d 4c 24 08	 lea	 ecx, DWORD PTR _strPath$[esp+1068]
  0005a	c6 84 24 28 04
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+1076], 1
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00068	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67012[esp+1064]
  0006c	c6 84 24 24 04
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+1072], 0
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 500  : 
; 501  : 	CString strResourceFile = _T("");

  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0007f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strResourceFile$[esp+1068]
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 502  : 	strResourceFile.Format("%s\\groups\\resource.config", (LPCTSTR)strPath);

  00089	8b 4c 24 04	 mov	 ecx, DWORD PTR _strPath$[esp+1064]
  0008d	51		 push	 ecx
  0008e	8d 54 24 0c	 lea	 edx, DWORD PTR _strResourceFile$[esp+1068]
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DHDFGIGF@?$CFs?2groups?2resource?4config?$AA@
  00097	52		 push	 edx
  00098	c6 84 24 30 04
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+1084], 2
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ

; 503  : 	
; 504  : 	char buffer[1024] = {0};	

  000a6	33 c0		 xor	 eax, eax
  000a8	c6 44 24 1c 00	 mov	 BYTE PTR _buffer$[esp+1076], 0
  000ad	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  000b2	8d 7c 24 1d	 lea	 edi, DWORD PTR _buffer$[esp+1077]
  000b6	f3 ab		 rep stosd
  000b8	66 ab		 stosw
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	aa		 stosb

; 505  : 	GetPrivateProfileString("Resource", "CompanyName", "", buffer, sizeof(buffer) - 1, (LPCTSTR)strResourceFile);

  000be	8b 44 24 08	 mov	 eax, DWORD PTR _strResourceFile$[esp+1064]
  000c2	50		 push	 eax
  000c3	68 ff 03 00 00	 push	 1023			; 000003ffH
  000c8	8d 4c 24 18	 lea	 ecx, DWORD PTR _buffer$[esp+1072]
  000cc	51		 push	 ecx
  000cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@DHIAIDA@CompanyName?$AA@
  000d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FLGELGHE@Resource?$AA@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 506  : 
; 507  : 	strRet = buffer;

  000e2	8b 4d 08	 mov	 ecx, DWORD PTR _strRet$[ebp]
  000e5	8d 54 24 10	 lea	 edx, DWORD PTR _buffer$[esp+1064]
  000e9	52		 push	 edx
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 508  : }

  000f0	8d 4c 24 08	 lea	 ecx, DWORD PTR _strResourceFile$[esp+1064]
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000fa	8d 4c 24 04	 lea	 ecx, DWORD PTR _strPath$[esp+1064]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00104	8b 8c 24 1c 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1064]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00112	8b 8c 24 14 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1064]
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	5f		 pop	 edi
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67013:
  00000	8d 8d dc fb ff
	ff		 lea	 ecx, DWORD PTR _strPath$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67014:
  0000c	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR $T67012[ebp]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67015:
  00018	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _strResourceFile$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FuncGetCompanyName@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00024	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67023
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetCompanyName@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; FuncGetCompanyName
PUBLIC	??_C@_0L@HDFBFFKD@CompanyUrl?$AA@		; `string'
PUBLIC	?FuncGetCompanyUrl@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; FuncGetCompanyUrl
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T67045	DD	0ffffffffH
	DD	FLAT:$L67032
	DD	00H
	DD	FLAT:$L67033
	DD	00H
	DD	FLAT:$L67034
$T67042	DD	019930520H
	DD	03H
	DD	FLAT:$T67045
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0L@HDFBFFKD@CompanyUrl?$AA@
CONST	SEGMENT
??_C@_0L@HDFBFFKD@CompanyUrl?$AA@ DB 'CompanyUrl', 00H	; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?FuncGetCompanyUrl@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
_strPath$ = -1060					; size = 4
_strResourceFile$ = -1056				; size = 4
$T67031 = -1052						; size = 4
_buffer$ = -1048					; size = 1024
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_strRet$ = 8						; size = 4
?FuncGetCompanyUrl@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; FuncGetCompanyUrl, COMDAT

; 511  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?FuncGetCompanyUrl@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec 18 04 00
	00		 sub	 esp, 1048		; 00000418H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	57		 push	 edi
  00027	89 84 24 14 04
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+1064], eax

; 512  : 	CString strPath = _T("");

  0002e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00033	8d 4c 24 08	 lea	 ecx, DWORD PTR _strPath$[esp+1068]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 513  : 	strPath = ::FuncGetInstallPath();

  0003d	8d 44 24 0c	 lea	 eax, DWORD PTR $T67031[esp+1064]
  00041	50		 push	 eax
  00042	c7 84 24 28 04
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+1076], 0
  0004d	e8 00 00 00 00	 call	 ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
  00052	83 c4 04	 add	 esp, 4
  00055	50		 push	 eax
  00056	8d 4c 24 08	 lea	 ecx, DWORD PTR _strPath$[esp+1068]
  0005a	c6 84 24 28 04
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+1076], 1
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00068	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67031[esp+1064]
  0006c	c6 84 24 24 04
	00 00 00	 mov	 BYTE PTR __$EHRec$[esp+1072], 0
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 514  : 
; 515  : 	CString strResourceFile = _T("");

  0007a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0007f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strResourceFile$[esp+1068]
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 516  : 	strResourceFile.Format("%s\\groups\\resource.config", (LPCTSTR)strPath);

  00089	8b 4c 24 04	 mov	 ecx, DWORD PTR _strPath$[esp+1064]
  0008d	51		 push	 ecx
  0008e	8d 54 24 0c	 lea	 edx, DWORD PTR _strResourceFile$[esp+1068]
  00092	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@DHDFGIGF@?$CFs?2groups?2resource?4config?$AA@
  00097	52		 push	 edx
  00098	c6 84 24 30 04
	00 00 02	 mov	 BYTE PTR __$EHRec$[esp+1084], 2
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ

; 517  : 	
; 518  : 	char buffer[1024] = {0};	

  000a6	33 c0		 xor	 eax, eax
  000a8	c6 44 24 1c 00	 mov	 BYTE PTR _buffer$[esp+1076], 0
  000ad	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  000b2	8d 7c 24 1d	 lea	 edi, DWORD PTR _buffer$[esp+1077]
  000b6	f3 ab		 rep stosd
  000b8	66 ab		 stosw
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	aa		 stosb

; 519  : 	GetPrivateProfileString("Resource", "CompanyUrl", "", buffer, sizeof(buffer) - 1, (LPCTSTR)strResourceFile);

  000be	8b 44 24 08	 mov	 eax, DWORD PTR _strResourceFile$[esp+1064]
  000c2	50		 push	 eax
  000c3	68 ff 03 00 00	 push	 1023			; 000003ffH
  000c8	8d 4c 24 18	 lea	 ecx, DWORD PTR _buffer$[esp+1072]
  000cc	51		 push	 ecx
  000cd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000d2	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@HDFBFFKD@CompanyUrl?$AA@
  000d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08FLGELGHE@Resource?$AA@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 520  : 
; 521  : 	strRet = buffer;

  000e2	8b 4d 08	 mov	 ecx, DWORD PTR _strRet$[ebp]
  000e5	8d 54 24 10	 lea	 edx, DWORD PTR _buffer$[esp+1064]
  000e9	52		 push	 edx
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 522  : }

  000f0	8d 4c 24 08	 lea	 ecx, DWORD PTR _strResourceFile$[esp+1064]
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000fa	8d 4c 24 04	 lea	 ecx, DWORD PTR _strPath$[esp+1064]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00104	8b 8c 24 1c 04
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+1064]
  0010b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00112	8b 8c 24 14 04
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+1064]
  00119	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011e	5f		 pop	 edi
  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67032:
  00000	8d 8d dc fb ff
	ff		 lea	 ecx, DWORD PTR _strPath$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67033:
  0000c	8d 8d e4 fb ff
	ff		 lea	 ecx, DWORD PTR $T67031[ebp]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67034:
  00018	8d 8d e0 fb ff
	ff		 lea	 ecx, DWORD PTR _strResourceFile$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FuncGetCompanyUrl@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00024	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67042
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetCompanyUrl@@YAXAAV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; FuncGetCompanyUrl
PUBLIC	??0_rec@@QAE@XZ					; _rec::_rec
EXTRN	__imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ??0_rec@@QAE@XZ
_TEXT	SEGMENT
??0_rec@@QAE@XZ PROC NEAR				; _rec::_rec, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00009	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00012	8b c6		 mov	 eax, esi
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??0_rec@@QAE@XZ ENDP					; _rec::_rec
_TEXT	ENDS
PUBLIC	??1_rec@@QAE@XZ					; _rec::~_rec
; Function compile flags: /Ogty
;	COMDAT ??1_rec@@QAE@XZ
_TEXT	SEGMENT
??1_rec@@QAE@XZ PROC NEAR				; _rec::~_rec, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0000c	8b ce		 mov	 ecx, esi
  0000e	5e		 pop	 esi
  0000f	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
??1_rec@@QAE@XZ ENDP					; _rec::~_rec
_TEXT	ENDS
PUBLIC	??4_rec@@QAEAAU0@ABU0@@Z			; _rec::operator=
; Function compile flags: /Ogty
;	COMDAT ??4_rec@@QAEAAU0@ABU0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4_rec@@QAEAAU0@ABU0@@Z PROC NEAR			; _rec::operator=, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR ___that$[esp+4]
  00006	57		 push	 edi
  00007	8b f1		 mov	 esi, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0000f	83 c7 04	 add	 edi, 4
  00012	57		 push	 edi
  00013	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0001c	5f		 pop	 edi
  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	c2 04 00	 ret	 4
??4_rec@@QAEAAU0@ABU0@@Z ENDP				; _rec::operator=
_TEXT	ENDS
PUBLIC	?FuncGetRightString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0@Z ; FuncGetRightString
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T67094	DD	0ffffffffH
	DD	FLAT:$L67056
	DD	00H
	DD	FLAT:$L67057
	DD	01H
	DD	FLAT:$L67058
	DD	02H
	DD	FLAT:$L67059
	DD	03H
	DD	FLAT:$L67063
	DD	04H
	DD	FLAT:$L67064
$T67089	DD	019930520H
	DD	06H
	DD	FLAT:$T67094
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	ENDS
;	COMDAT ?FuncGetRightString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0@Z
_TEXT	SEGMENT
_strTemp$ = -28						; size = 4
_strRight$60886 = -24					; size = 4
_strReturn$ = -20					; size = 4
$T67061 = -16						; size = 4
_strLeft$60884 = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_strWholeString$ = 12					; size = 4
_strMark$ = 16						; size = 4
?FuncGetRightString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0@Z PROC NEAR ; FuncGetRightString, COMDAT

; 613  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?FuncGetRightString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR $T67061[esp+36], 0

; 614  : 	CString strTemp = _T("");

  00022	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00027	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strTemp$[esp+40]
  0002b	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 1
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 615  : 	strTemp = strWholeString;

  00039	8d 44 24 2c	 lea	 eax, DWORD PTR _strWholeString$[esp+32]
  0003d	50		 push	 eax
  0003e	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strTemp$[esp+40]
  00042	c6 44 24 24 02	 mov	 BYTE PTR __$EHRec$[esp+48], 2
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 616  : 	int nMarkByte = 0;
; 617  : 	nMarkByte = strMark.GetLength();

  0004d	8b 44 24 30	 mov	 eax, DWORD PTR _strMark$[esp+32]
  00051	8b 78 f4	 mov	 edi, DWORD PTR [eax-12]

; 618  : 
; 619  : 	int nIndex1 = strTemp.Find(strMark, 0);

  00054	6a 00		 push	 0
  00056	50		 push	 eax
  00057	8d 4c 24 10	 lea	 ecx, DWORD PTR _strTemp$[esp+44]
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z

; 620  : 	CString strReturn = _T("");

  00061	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00066	8d 4c 24 14	 lea	 ecx, DWORD PTR _strReturn$[esp+40]
  0006a	8b f0		 mov	 esi, eax
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 621  : 
; 622  : 	if(nIndex1 < 0)

  00072	85 f6		 test	 esi, esi
  00074	c6 44 24 20 03	 mov	 BYTE PTR __$EHRec$[esp+44], 3
  00079	7d 16		 jge	 SHORT $L67090

; 623  : 		return "";

  0007b	8b 74 24 28	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+32]
  0007f	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00084	8b ce		 mov	 ecx, esi
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
  0008c	e9 8b 00 00 00	 jmp	 $L67093
$L67090:

; 624  : 
; 625  : 	while (nIndex1!=-1) 

  00091	83 fe ff	 cmp	 esi, -1
  00094	74 75		 je	 SHORT $L60883
$L60882:

; 626  : 	{
; 627  : 		CString strLeft = strTemp.Left(nIndex1);

  00096	56		 push	 esi
  00097	8d 4c 24 18	 lea	 ecx, DWORD PTR _strLeft$60884[esp+40]
  0009b	51		 push	 ecx
  0009c	8d 4c 24 10	 lea	 ecx, DWORD PTR _strTemp$[esp+44]
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z

; 628  : 		CString strRight = strTemp.Right(strTemp.GetLength()-nIndex1-nMarkByte);

  000a6	8b 54 24 08	 mov	 edx, DWORD PTR _strTemp$[esp+36]
  000aa	8b 42 f4	 mov	 eax, DWORD PTR [edx-12]
  000ad	2b c6		 sub	 eax, esi
  000af	2b c7		 sub	 eax, edi
  000b1	50		 push	 eax
  000b2	8d 44 24 10	 lea	 eax, DWORD PTR _strRight$60886[esp+40]
  000b6	50		 push	 eax
  000b7	8d 4c 24 10	 lea	 ecx, DWORD PTR _strTemp$[esp+44]
  000bb	c6 44 24 28 04	 mov	 BYTE PTR __$EHRec$[esp+52], 4
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Right@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z

; 629  : 
; 630  : 		nIndex1 = strRight.Find(strMark, 0);

  000c6	8b 4c 24 30	 mov	 ecx, DWORD PTR _strMark$[esp+32]
  000ca	6a 00		 push	 0
  000cc	51		 push	 ecx
  000cd	8d 4c 24 14	 lea	 ecx, DWORD PTR _strRight$60886[esp+44]
  000d1	c6 44 24 28 05	 mov	 BYTE PTR __$EHRec$[esp+52], 5
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z

; 631  : 		strTemp = strRight;	

  000dc	8d 54 24 0c	 lea	 edx, DWORD PTR _strRight$60886[esp+36]
  000e0	52		 push	 edx
  000e1	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strTemp$[esp+40]
  000e5	8b f0		 mov	 esi, eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 632  : 	}

  000ed	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strRight$60886[esp+36]
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f7	8d 4c 24 14	 lea	 ecx, DWORD PTR _strLeft$60884[esp+36]
  000fb	c6 44 24 20 03	 mov	 BYTE PTR __$EHRec$[esp+44], 3
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00106	83 fe ff	 cmp	 esi, -1
  00109	75 8b		 jne	 SHORT $L60882
$L60883:

; 633  : 
; 634  : 	return strTemp;

  0010b	8b 74 24 28	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+32]
  0010f	8d 44 24 08	 lea	 eax, DWORD PTR _strTemp$[esp+36]
  00113	50		 push	 eax
  00114	8b ce		 mov	 ecx, esi
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
$L67093:
  0011c	8d 4c 24 10	 lea	 ecx, DWORD PTR _strReturn$[esp+36]
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00126	8d 4c 24 08	 lea	 ecx, DWORD PTR _strTemp$[esp+36]
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00130	8d 4c 24 2c	 lea	 ecx, DWORD PTR _strWholeString$[esp+32]
  00134	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0013a	8d 4c 24 30	 lea	 ecx, DWORD PTR _strMark$[esp+32]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 635  : }

  00144	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00148	5f		 pop	 edi
  00149	8b c6		 mov	 eax, esi
  0014b	5e		 pop	 esi
  0014c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00153	83 c4 1c	 add	 esp, 28			; 0000001cH
  00156	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67056:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _strMark$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67057:
  00009	8d 4d 08	 lea	 ecx, DWORD PTR _strWholeString$[ebp-4]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67058:
  00012	8d 4d e4	 lea	 ecx, DWORD PTR _strTemp$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67059:
  0001b	8d 4d ec	 lea	 ecx, DWORD PTR _strReturn$[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67063:
  00024	8d 4d f0	 lea	 ecx, DWORD PTR _strLeft$60884[ebp]
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67064:
  0002d	8d 4d e8	 lea	 ecx, DWORD PTR _strRight$60886[ebp]
  00030	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FuncGetRightString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0@Z:
  00036	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67089
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetRightString@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@0@Z ENDP ; FuncGetRightString
PUBLIC	?MakeStringListByChar@@YA_NAAVCStringList@@PBD@Z ; MakeStringListByChar
EXTRN	?AddHead@CStringList@@QAEPAU__POSITION@@PBD@Z:NEAR ; CStringList::AddHead
; Function compile flags: /Ogty
;	COMDAT ?MakeStringListByChar@@YA_NAAVCStringList@@PBD@Z
_TEXT	SEGMENT
_pList$ = 8						; size = 4
_pInput$ = 12						; size = 4
?MakeStringListByChar@@YA_NAAVCStringList@@PBD@Z PROC NEAR ; MakeStringListByChar, COMDAT

; 637  : {

  00000	56		 push	 esi

; 638  : 	const char * p;
; 639  : 	int nSize;
; 640  : 	p=pInput;

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _pInput$[esp]

; 641  : 	while(*p!='\0')

  00005	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00008	74 30		 je	 SHORT $L67102
  0000a	53		 push	 ebx
  0000b	8b 5c 24 0c	 mov	 ebx, DWORD PTR _pList$[esp+4]
  0000f	57		 push	 edi
$L60895:

; 642  : 	{
; 643  : 		nSize = static_cast<int>(strlen(p));

  00010	8b c6		 mov	 eax, esi
  00012	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
$L67101:
  00015	8a 08		 mov	 cl, BYTE PTR [eax]
  00017	40		 inc	 eax
  00018	84 c9		 test	 cl, cl
  0001a	75 f9		 jne	 SHORT $L67101
  0001c	2b c2		 sub	 eax, edx
  0001e	8b f8		 mov	 edi, eax

; 644  : 		if( nSize>0 )

  00020	85 ff		 test	 edi, edi
  00022	7e 08		 jle	 SHORT $L60898

; 645  : 		{	
; 646  : 			pList.AddHead(p);

  00024	56		 push	 esi
  00025	8b cb		 mov	 ecx, ebx
  00027	e8 00 00 00 00	 call	 ?AddHead@CStringList@@QAEPAU__POSITION@@PBD@Z ; CStringList::AddHead
$L60898:
  0002c	8a 44 3e 01	 mov	 al, BYTE PTR [esi+edi+1]
  00030	84 c0		 test	 al, al

; 647  : 		//	printf(p);
; 648  : 		}
; 649  : 		p=p+nSize+1;

  00032	8d 74 3e 01	 lea	 esi, DWORD PTR [esi+edi+1]
  00036	75 d8		 jne	 SHORT $L60895
  00038	5f		 pop	 edi
  00039	5b		 pop	 ebx
$L67102:

; 650  : 	}
; 651  : 
; 652  : 	return true;

  0003a	b0 01		 mov	 al, 1
  0003c	5e		 pop	 esi

; 653  : }

  0003d	c3		 ret	 0
?MakeStringListByChar@@YA_NAAVCStringList@@PBD@Z ENDP	; MakeStringListByChar
_TEXT	ENDS
PUBLIC	?MakeCharByString@@YA_NPADAAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; MakeCharByString
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T67132	DD	0ffffffffH
	DD	FLAT:$L67108
$T67127	DD	019930520H
	DD	01H
	DD	FLAT:$T67132
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	ENDS
;	COMDAT ?MakeCharByString@@YA_NPADAAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pOut$ = 8						; size = 4
_nOutSize$ = 12						; size = 4
_strInput$ = 16						; size = 4
?MakeCharByString@@YA_NPADAAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z PROC NEAR ; MakeCharByString, COMDAT

; 655  : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?MakeCharByString@@YA_NPADAAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi

; 656  : 	 char *p;
; 657  : 	
; 658  : 	int nSize=strInput.GetLength();

  00018	8b 44 24 24	 mov	 eax, DWORD PTR _strInput$[esp+20]
  0001c	8b 70 f4	 mov	 esi, DWORD PTR [eax-12]

; 659  : 	if(nSize+2 <nOutSize)

  0001f	8b 5c 24 20	 mov	 ebx, DWORD PTR _nOutSize$[esp+20]
  00023	8b 03		 mov	 eax, DWORD PTR [ebx]
  00025	8d 4e 02	 lea	 ecx, DWORD PTR [esi+2]
  00028	3b c8		 cmp	 ecx, eax
  0002a	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0

; 660  : 	{
; 661  : 		strcpy(pOut,strInput.GetBuffer(strInput.GetLength()));

  00032	8d 4c 24 24	 lea	 ecx, DWORD PTR _strInput$[esp+20]
  00036	7d 4c		 jge	 SHORT $L60906
  00038	56		 push	 esi
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  0003f	8b 7c 24 1c	 mov	 edi, DWORD PTR _pOut$[esp+20]
  00043	8b d7		 mov	 edx, edi
$L67105:
  00045	8a 08		 mov	 cl, BYTE PTR [eax]
  00047	40		 inc	 eax
  00048	88 0a		 mov	 BYTE PTR [edx], cl
  0004a	42		 inc	 edx
  0004b	84 c9		 test	 cl, cl
  0004d	75 f6		 jne	 SHORT $L67105

; 666  : 	//printf("%d\n",nSize);23028830 13602067678 
; 667  : 	for(int i=0;i<nSize;i++)

  0004f	85 f6		 test	 esi, esi
  00051	8b c7		 mov	 eax, edi
  00053	7e 0e		 jle	 SHORT $L60912

; 665  : 	p=pOut;

  00055	8b ce		 mov	 ecx, esi
$L60910:

; 668  : 	{
; 669  : 		if(*p=='$') 	

  00057	80 38 24	 cmp	 BYTE PTR [eax], 36	; 00000024H
  0005a	75 03		 jne	 SHORT $L60913

; 670  : 			*p='\0';

  0005c	c6 00 00	 mov	 BYTE PTR [eax], 0
$L60913:

; 671  : 		p++;

  0005f	40		 inc	 eax
  00060	49		 dec	 ecx
  00061	75 f4		 jne	 SHORT $L60910
$L60912:

; 672  : 	}
; 673  : 	nOutSize=nSize+1;

  00063	46		 inc	 esi

; 674  : 	return true;

  00064	8d 4c 24 24	 lea	 ecx, DWORD PTR _strInput$[esp+20]
  00068	89 33		 mov	 DWORD PTR [ebx], esi
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00070	b0 01		 mov	 al, 1

; 675  : 	
; 676  : }

  00072	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	c3		 ret	 0
$L60906:

; 662  : 	}
; 663  : 	else 
; 664  : 		return false;

  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 675  : 	
; 676  : }

  0008a	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	32 c0		 xor	 al, al
  00092	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00099	5b		 pop	 ebx
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67108:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _strInput$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?MakeCharByString@@YA_NPADAAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67127
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?MakeCharByString@@YA_NPADAAHV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ENDP ; MakeCharByString
PUBLIC	?GetSEIP@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GetSEIP
PUBLIC	??_C@_0BG@BFJACLLI@?$CFs?2fcgi?9bin?2mc?4config?$AA@ ; `string'
PUBLIC	??_C@_04BPKCJLI@SEID?$AA@			; `string'
PUBLIC	??_C@_0BA@GGPFGLLN@MonitorSchedule?$AA@		; `string'
PUBLIC	??_C@_09IPAEKDAI@localhost?$AA@			; `string'
PUBLIC	??_C@_0L@HPMGBIOI@ServerHost?$AA@		; `string'
EXTRN	__imp__GetPrivateProfileIntA@16:NEAR
EXTRN	__imp__puts:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67149	DD	0ffffffffH
	DD	FLAT:$L67139
	DD	00H
	DD	FLAT:$L67140
$T67145	DD	019930520H
	DD	02H
	DD	FLAT:$T67149
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BG@BFJACLLI@?$CFs?2fcgi?9bin?2mc?4config?$AA@
CONST	SEGMENT
??_C@_0BG@BFJACLLI@?$CFs?2fcgi?9bin?2mc?4config?$AA@ DB '%s\fcgi-bin\mc.c'
	DB	'onfig', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04BPKCJLI@SEID?$AA@
CONST	SEGMENT
??_C@_04BPKCJLI@SEID?$AA@ DB 'SEID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GGPFGLLN@MonitorSchedule?$AA@
CONST	SEGMENT
??_C@_0BA@GGPFGLLN@MonitorSchedule?$AA@ DB 'MonitorSchedule', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09IPAEKDAI@localhost?$AA@
CONST	SEGMENT
??_C@_09IPAEKDAI@localhost?$AA@ DB 'localhost', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HPMGBIOI@ServerHost?$AA@
CONST	SEGMENT
??_C@_0L@HPMGBIOI@ServerHost?$AA@ DB 'ServerHost', 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetSEIP@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_strRootPath$ = -2080					; size = 4
$T67142 = -2076						; size = 4
$T67138 = -2076						; size = 4
_szFile$ = -2072					; size = 1024
_szSeHost$ = -1048					; size = 1024
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetSEIP@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC NEAR ; GetSEIP, COMDAT

; 678  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?GetSEIP@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	81 ec 18 08 00
	00		 sub	 esp, 2072		; 00000818H
  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00026	53		 push	 ebx
  00027	56		 push	 esi
  00028	33 db		 xor	 ebx, ebx
  0002a	57		 push	 edi

; 679  : 	CString strRootPath;

  0002b	8d 4c 24 10	 lea	 ecx, DWORD PTR _strRootPath$[esp+2096]
  0002f	89 84 24 1c 08
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+2096], eax
  00036	89 5c 24 14	 mov	 DWORD PTR $T67142[esp+2096], ebx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 680  : 	strRootPath=FuncGetInstallRootSCPath();

  00040	8d 44 24 14	 lea	 eax, DWORD PTR $T67138[esp+2096]
  00044	50		 push	 eax
  00045	89 9c 24 30 08
	00 00		 mov	 DWORD PTR __$EHRec$[esp+2108], ebx
  0004c	e8 00 00 00 00	 call	 ?FuncGetInstallRootSCPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallRootSCPath
  00051	83 c4 04	 add	 esp, 4
  00054	50		 push	 eax
  00055	8d 4c 24 14	 lea	 ecx, DWORD PTR _strRootPath$[esp+2100]
  00059	c6 84 24 30 08
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+2108], 1
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00067	8d 4c 24 14	 lea	 ecx, DWORD PTR $T67138[esp+2096]
  0006b	88 9c 24 2c 08
	00 00		 mov	 BYTE PTR __$EHRec$[esp+2104], bl
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 681  : 	char szFile[1024]={0};

  00078	88 5c 24 18	 mov	 BYTE PTR _szFile$[esp+2096], bl
  0007c	33 c0		 xor	 eax, eax
  0007e	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00083	8d 7c 24 19	 lea	 edi, DWORD PTR _szFile$[esp+2097]
  00087	f3 ab		 rep stosd

; 682  : 	sprintf(szFile,"%s\\fcgi-bin\\mc.config",strRootPath);

  00089	8b 4c 24 10	 mov	 ecx, DWORD PTR _strRootPath$[esp+2096]
  0008d	51		 push	 ecx
  0008e	66 ab		 stosw
  00090	8d 54 24 1c	 lea	 edx, DWORD PTR _szFile$[esp+2100]
  00094	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BG@BFJACLLI@?$CFs?2fcgi?9bin?2mc?4config?$AA@
  00099	52		 push	 edx
  0009a	aa		 stosb
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 683  : 	puts(szFile);

  000a1	8d 44 24 24	 lea	 eax, DWORD PTR _szFile$[esp+2108]
  000a5	50		 push	 eax
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__puts
  000ac	83 c4 10	 add	 esp, 16			; 00000010H

; 684  : 	int nSeId=1;
; 685  : 	nSeId =GetPrivateProfileInt("MonitorSchedule","SEID",1,szFile);

  000af	8d 4c 24 18	 lea	 ecx, DWORD PTR _szFile$[esp+2096]
  000b3	51		 push	 ecx
  000b4	6a 01		 push	 1
  000b6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_04BPKCJLI@SEID?$AA@
  000bb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@GGPFGLLN@MonitorSchedule?$AA@
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 686  : 	if(nSeId==1)	

  000c6	83 f8 01	 cmp	 eax, 1
  000c9	75 07		 jne	 SHORT $L60925

; 687  : 		return "localhost";

  000cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09IPAEKDAI@localhost?$AA@
  000d0	eb 49		 jmp	 SHORT $L67148
$L60925:

; 688  : 	char szSeHost[1024]={0};

  000d2	33 c0		 xor	 eax, eax
  000d4	88 9c 24 18 04
	00 00		 mov	 BYTE PTR _szSeHost$[esp+2096], bl
  000db	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  000e0	8d bc 24 19 04
	00 00		 lea	 edi, DWORD PTR _szSeHost$[esp+2097]
  000e7	f3 ab		 rep stosd
  000e9	66 ab		 stosw

; 689  : 	
; 690  : 	GetPrivateProfileString("MonitorSchedule","ServerHost","localhost",szSeHost,1023,szFile);

  000eb	8d 54 24 18	 lea	 edx, DWORD PTR _szFile$[esp+2096]
  000ef	52		 push	 edx
  000f0	68 ff 03 00 00	 push	 1023			; 000003ffH
  000f5	aa		 stosb
  000f6	8d 84 24 20 04
	00 00		 lea	 eax, DWORD PTR _szSeHost$[esp+2104]
  000fd	50		 push	 eax
  000fe	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09IPAEKDAI@localhost?$AA@
  00103	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0L@HPMGBIOI@ServerHost?$AA@
  00108	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@GGPFGLLN@MonitorSchedule?$AA@
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 691  : 	return szSeHost;

  00113	8d 8c 24 18 04
	00 00		 lea	 ecx, DWORD PTR _szSeHost$[esp+2096]
  0011a	51		 push	 ecx
$L67148:
  0011b	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0011e	8b ce		 mov	 ecx, esi
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00126	8d 4c 24 10	 lea	 ecx, DWORD PTR _strRootPath$[esp+2096]
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 692  : 	
; 693  : 	
; 694  : }

  00130	8b 8c 24 24 08
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+2096]
  00137	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0013e	8b 8c 24 1c 08
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+2096]
  00145	8b c6		 mov	 eax, esi
  00147	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	5b		 pop	 ebx
  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67139:
  00000	8d 8d e0 f7 ff
	ff		 lea	 ecx, DWORD PTR _strRootPath$[ebp]
  00006	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67140:
  0000c	8d 8d e4 f7 ff
	ff		 lea	 ecx, DWORD PTR $T67138[ebp]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?GetSEIP@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
  00018	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67145
  0001d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetSEIP@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; GetSEIP
PUBLIC	??_C@_07DLHCIBDH@default?$AA@			; `string'
PUBLIC	?GetResourceValue@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ; GetResourceValue
EXTRN	__imp_?FindNodeValue@@YA_NPAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@Z:NEAR
EXTRN	__imp_?LoadResource@@YAPAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z:NEAR
EXTRN	__imp_?GetResourceNode@@YAPAXPAX@Z:NEAR
EXTRN	__imp_?CloseResource@@YA_NAAPAX@Z:NEAR
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67171	DD	0ffffffffH
	DD	FLAT:$L67161
	DD	00H
	DD	FLAT:$L67157
	DD	01H
	DD	FLAT:$L67158
	DD	02H
	DD	FLAT:$L67159
$T67166	DD	019930520H
	DD	04H
	DD	FLAT:$T67171
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default?$AA@
CONST	SEGMENT
??_C@_07DLHCIBDH@default?$AA@ DB 'default', 00H		; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetResourceValue@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z
_TEXT	SEGMENT
$T67162 = -60						; size = 4
_obj$ = -56						; size = 4
$T67156 = -52						; size = 4
$T67155 = -52						; size = 4
$T67154 = -48						; size = 4
_rvalue$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_rkey$ = 12						; size = 28
?GetResourceValue@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z PROC NEAR ; GetResourceValue, COMDAT

; 697  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GetResourceValue@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 30	 sub	 esp, 48			; 00000030H
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	53		 push	 ebx
  0001e	89 44 24 30	 mov	 DWORD PTR __$ArrayPad$[esp+64], eax
  00022	56		 push	 esi
  00023	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T67162[esp+68], 0
  0002b	bb 01 00 00 00	 mov	 ebx, 1

; 698  : 	string rvalue="";

  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00035	8d 4c 24 1c	 lea	 ecx, DWORD PTR _rvalue$[esp+72]
  00039	89 5c 24 44	 mov	 DWORD PTR __$EHRec$[esp+80], ebx
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 699  : 	//OBJECT obj=LoadResource("default", "localhost");  
; 700  : 	OBJECT obj=LoadResource("default", GetSEIP());  

  00043	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00046	8b c4		 mov	 eax, esp
  00048	89 64 24 30	 mov	 DWORD PTR $T67154[esp+96], esp
  0004c	50		 push	 eax
  0004d	c6 44 24 60 02	 mov	 BYTE PTR __$EHRec$[esp+108], 2
  00052	e8 00 00 00 00	 call	 ?GetSEIP@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; GetSEIP
  00057	83 ec 18	 sub	 esp, 24			; 00000018H
  0005a	8b cc		 mov	 ecx, esp
  0005c	89 64 24 48	 mov	 DWORD PTR $T67155[esp+124], esp
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_07DLHCIBDH@default?$AA@
  00065	c6 44 24 7c 03	 mov	 BYTE PTR __$EHRec$[esp+136], 3
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00070	c6 44 24 78 02	 mov	 BYTE PTR __$EHRec$[esp+132], 2
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?LoadResource@@YAPAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
  0007b	83 c4 38	 add	 esp, 56			; 00000038H

; 701  : 	if( obj==INVALID_VALUE )

  0007e	85 c0		 test	 eax, eax
  00080	89 44 24 0c	 mov	 DWORD PTR _obj$[esp+68], eax
  00084	75 13		 jne	 SHORT $L60939

; 702  : 		return rvalue;

  00086	8b 74 24 48	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+64]
  0008a	8d 4c 24 18	 lea	 ecx, DWORD PTR _rvalue$[esp+68]
  0008e	51		 push	 ecx
  0008f	8b ce		 mov	 ecx, esi
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00097	eb 64		 jmp	 SHORT $L67169
$L60939:

; 703  : 
; 704  : 	MAPNODE ma=GetResourceNode(obj);

  00099	50		 push	 eax
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetResourceNode@@YAPAXPAX@Z
  000a0	8b f0		 mov	 esi, eax
  000a2	83 c4 04	 add	 esp, 4

; 705  : 	if( ma==INVALID_VALUE )

  000a5	85 f6		 test	 esi, esi
  000a7	75 15		 jne	 SHORT $L60941

; 706  : 	{
; 707  : 		CloseResource(obj);

  000a9	8d 54 24 0c	 lea	 edx, DWORD PTR _obj$[esp+68]
  000ad	52		 push	 edx
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?CloseResource@@YA_NAAPAX@Z
  000b4	83 c4 04	 add	 esp, 4

; 708  : 		return rvalue;

  000b7	8d 44 24 18	 lea	 eax, DWORD PTR _rvalue$[esp+68]
  000bb	50		 push	 eax
  000bc	eb 33		 jmp	 SHORT $L67170
$L60941:

; 709  : 	}
; 710  : 
; 711  : 	FindNodeValue(ma,rkey,rvalue);

  000be	8d 4c 24 18	 lea	 ecx, DWORD PTR _rvalue$[esp+68]
  000c2	51		 push	 ecx
  000c3	83 ec 1c	 sub	 esp, 28			; 0000001cH
  000c6	8d 54 24 6c	 lea	 edx, DWORD PTR _rkey$[esp+96]
  000ca	8b cc		 mov	 ecx, esp
  000cc	89 64 24 30	 mov	 DWORD PTR $T67156[esp+100], esp
  000d0	52		 push	 edx
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  000d7	56		 push	 esi
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?FindNodeValue@@YA_NPAXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV12@@Z

; 712  : 	CloseResource(obj);

  000de	8d 44 24 30	 lea	 eax, DWORD PTR _obj$[esp+104]
  000e2	50		 push	 eax
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?CloseResource@@YA_NAAPAX@Z
  000e9	83 c4 28	 add	 esp, 40			; 00000028H

; 713  : 	return rvalue;

  000ec	8d 4c 24 18	 lea	 ecx, DWORD PTR _rvalue$[esp+68]
  000f0	51		 push	 ecx
$L67170:
  000f1	8b 74 24 4c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+68]
  000f5	8b ce		 mov	 ecx, esi
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$L67169:
  000fd	8d 4c 24 18	 lea	 ecx, DWORD PTR _rvalue$[esp+68]
  00101	89 5c 24 08	 mov	 DWORD PTR $T67162[esp+68], ebx
  00105	88 5c 24 40	 mov	 BYTE PTR __$EHRec$[esp+76], bl
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0010f	8d 4c 24 4c	 lea	 ecx, DWORD PTR _rkey$[esp+64]
  00113	c6 44 24 40 00	 mov	 BYTE PTR __$EHRec$[esp+76], 0
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 714  : }

  0011e	8b 4c 24 38	 mov	 ecx, DWORD PTR __$EHRec$[esp+68]
  00122	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00129	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+68]
  0012d	8b c6		 mov	 eax, esi
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	5e		 pop	 esi
  00135	5b		 pop	 ebx
  00136	83 c4 3c	 add	 esp, 60			; 0000003cH
  00139	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67157:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _rkey$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67158:
  00009	8d 4d d4	 lea	 ecx, DWORD PTR _rvalue$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67159:
  00012	8b 4d d0	 mov	 ecx, DWORD PTR $T67154[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67161:
  0001b	8b 45 c4	 mov	 eax, DWORD PTR $T67162[ebp]
  0001e	83 e0 01	 and	 eax, 1
  00021	0f 84 0d 00 00
	00		 je	 $L67163
  00027	83 65 c4 fe	 and	 DWORD PTR $T67162[ebp], -2 ; fffffffeH
  0002b	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0002e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67163:
  00034	c3		 ret	 0
__ehhandler$?GetResourceValue@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67166
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetResourceValue@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ENDP ; GetResourceValue
PUBLIC	??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 373  : 	CAtlSafeAllocBufferManager() : m_pHead(NULL) {};

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c3		 ret	 0
??0?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
; Function compile flags: /Ogty
;	COMDAT ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 387  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 388  : 		// Walk the list and free the buffers
; 389  : 		while (m_pHead != NULL)

  00003	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00006	74 1b		 je	 SHORT $L60964
  00008	57		 push	 edi
  00009	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  0000f	90		 npad	 1
$L60963:

; 390  : 		{
; 391  : 			CAtlSafeAllocBufferNode* p = m_pHead;

  00010	8b 06		 mov	 eax, DWORD PTR [esi]

; 392  : 			m_pHead = m_pHead->m_pNext;

  00012	8b 08		 mov	 ecx, DWORD PTR [eax]

; 393  : 			Allocator::Free(p);

  00014	50		 push	 eax
  00015	89 0e		 mov	 DWORD PTR [esi], ecx
  00017	ff d7		 call	 edi
  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	83 c4 04	 add	 esp, 4
  0001e	85 c0		 test	 eax, eax
  00020	75 ee		 jne	 SHORT $L60963
  00022	5f		 pop	 edi
$L60964:
  00023	5e		 pop	 esi

; 394  : 		}
; 395  : 	}

  00024	c3		 ret	 0
??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Ogty
;	COMDAT ??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 216  : 	{

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 217  : 	}

  00008	c3		 ret	 0
??0?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
; Function compile flags: /Ogty
;	COMDAT ??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 234  : 		return( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 235  : 	}

  00002	c3		 ret	 0
??B?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
PUBLIC	??1?$CW2AEX@$0IA@@ATL@@QAE@XZ			; ATL::CW2AEX<128>::~CW2AEX<128>
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ PROC NEAR			; ATL::CW2AEX<128>::~CW2AEX<128>, COMDAT
; _this$ = ecx

; 429  : 		if( m_psz != m_szBuffer )

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c1 04	 add	 ecx, 4
  00005	3b c1		 cmp	 eax, ecx
  00007	74 08		 je	 SHORT $L60981

; 430  : 		{
; 431  : 			free( m_psz );

  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00010	59		 pop	 ecx
$L60981:

; 432  : 		}
; 433  : 	}

  00011	c3		 ret	 0
??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ENDP			; ATL::CW2AEX<128>::~CW2AEX<128>
_TEXT	ENDS
PUBLIC	??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ			; ATL::CW2AEX<128>::operator char *
; Function compile flags: /Ogty
;	COMDAT ??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ PROC NEAR		; ATL::CW2AEX<128>::operator char *, COMDAT
; _this$ = ecx

; 437  : 		return( m_psz );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 438  : 	}

  00002	c3		 ret	 0
??B?$CW2AEX@$0IA@@ATL@@QBEPADXZ ENDP			; ATL::CW2AEX<128>::operator char *
_TEXT	ENDS
PUBLIC	??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@0@Z ; ATL::operator==
EXTRN	__imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z:NEAR
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
;	COMDAT ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@0@Z
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@0@Z PROC NEAR ; ATL::operator==, COMDAT

; 2082 : 		return( str1.Compare( str2 ) == 0 );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _str2$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _str1$[esp-4]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00011	f7 d8		 neg	 eax
  00013	1b c0		 sbb	 eax, eax
  00015	40		 inc	 eax

; 2083 : 	}

  00016	c3		 ret	 0
??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@0@Z ENDP ; ATL::operator==
_TEXT	ENDS
PUBLIC	??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator==
; Function compile flags: /Ogty
;	COMDAT ??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_psz2$ = 12						; size = 4
??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z PROC NEAR ; ATL::operator==, COMDAT

; 2088 : 		return( str1.Compare( psz2 ) == 0 );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _psz2$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _str1$[esp-4]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  0000f	f7 d8		 neg	 eax
  00011	1b c0		 sbb	 eax, eax
  00013	40		 inc	 eax

; 2089 : 	}

  00014	c3		 ret	 0
??8ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ENDP ; ATL::operator==
_TEXT	ENDS
PUBLIC	??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ; ATL::operator!=
; Function compile flags: /Ogty
;	COMDAT ??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_psz2$ = 12						; size = 4
??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z PROC NEAR ; ATL::operator!=, COMDAT

; 2122 : 		return( str1.Compare( psz2 ) != 0 );

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _psz2$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR _str1$[esp-4]
  00008	50		 push	 eax
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  0000f	f7 d8		 neg	 eax
  00011	1b c0		 sbb	 eax, eax
  00013	f7 d8		 neg	 eax

; 2123 : 	}

  00015	c3		 ret	 0
??9ATL@@YA_NABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@0@PBD@Z ENDP ; ATL::operator!=
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 78   : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 79   : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
EXTRN	__imp_?_Unlock@_Mutex@std@@QAEXXZ:NEAR
; Function compile flags: /Ogty
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $L67213

; 60   : 				_Myistr.rdbuf()->_Unlock();

  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L67213:

; 61   : 			}

  00018	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
; Function compile flags: /Ogty
;	COMDAT ??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 78   : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 79   : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
PUBLIC	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogty
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 59   : 			if (_Myistr.rdbuf() != 0)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $L67228

; 60   : 				_Myistr.rdbuf()->_Unlock();

  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L67228:

; 61   : 			}

  00018	c3		 ret	 0
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ
_TEXT	SEGMENT
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap, COMDAT
; _this$ = ecx

; 313  : 		Allocator::Free( m_p );

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	50		 push	 eax
  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00009	59		 pop	 ecx

; 314  : 	}

  0000a	c3		 ret	 0
?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
_TEXT	ENDS
PUBLIC	?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z		; ATL::CW2AEX<128>::Init
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
_nCodePage$ = 12					; size = 4
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z PROC NEAR		; ATL::CW2AEX<128>::Init, COMDAT
; _this$ = ecx

; 442  : 	{

  00000	53		 push	 ebx
  00001	55		 push	 ebp

; 443  : 		if (psz == NULL)

  00002	8b 6c 24 0c	 mov	 ebp, DWORD PTR _psz$[esp+4]
  00006	85 ed		 test	 ebp, ebp
  00008	8b d9		 mov	 ebx, ecx
  0000a	75 07		 jne	 SHORT $L62371

; 444  : 		{
; 445  : 			m_psz = NULL;

  0000c	89 2b		 mov	 DWORD PTR [ebx], ebp
  0000e	5d		 pop	 ebp
  0000f	5b		 pop	 ebx

; 463  : 		}
; 464  : 	}

  00010	c2 08 00	 ret	 8
$L62371:
  00013	56		 push	 esi
  00014	57		 push	 edi

; 446  : 			return;
; 447  : 		}
; 448  : 		int nLengthW = lstrlenW( psz )+1;

  00015	55		 push	 ebp
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0001c	8b f0		 mov	 esi, eax
  0001e	46		 inc	 esi

; 449  : 		int nLengthA = nLengthW*2;

  0001f	8d 3c 36	 lea	 edi, DWORD PTR [esi+esi]

; 450  : 
; 451  : 		if( nLengthA > t_nBufferLength )

  00022	81 ff 80 00 00
	00		 cmp	 edi, 128		; 00000080H
  00028	7e 1a		 jle	 SHORT $L67238

; 452  : 		{
; 453  : 			m_psz = static_cast< LPSTR >( malloc( nLengthA*sizeof( char ) ) );

  0002a	57		 push	 edi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00031	83 c4 04	 add	 esp, 4

; 454  : 			if (m_psz == NULL)

  00034	85 c0		 test	 eax, eax
  00036	89 03		 mov	 DWORD PTR [ebx], eax
  00038	75 0a		 jne	 SHORT $L67238

; 455  : 			{
; 456  : 				AtlThrow( E_OUTOFMEMORY );

  0003a	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0003f	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L67238:

; 457  : 			}
; 458  : 		}
; 459  : 
; 460  : 		if (::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ) == 0)

  00044	8b 03		 mov	 eax, DWORD PTR [ebx]
  00046	8b 4c 24 18	 mov	 ecx, DWORD PTR _nCodePage$[esp+12]
  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	57		 push	 edi
  0004f	50		 push	 eax
  00050	56		 push	 esi
  00051	55		 push	 ebp
  00052	6a 00		 push	 0
  00054	51		 push	 ecx
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0005b	85 c0		 test	 eax, eax
  0005d	75 05		 jne	 SHORT $L67239

; 461  : 		{
; 462  : 			AtlThrowLastWin32();

  0005f	e8 00 00 00 00	 call	 ?AtlThrowLastWin32@ATL@@YGXXZ ; ATL::AtlThrowLastWin32
$L67239:
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	5d		 pop	 ebp
  00067	5b		 pop	 ebx

; 463  : 		}
; 464  : 	}

  00068	c2 08 00	 ret	 8
$L67241:
?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ENDP		; ATL::CW2AEX<128>::Init
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
EXTRN	__imp_?_Lock@_Mutex@std@@QAEXXZ:NEAR
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Istr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 06		 mov	 DWORD PTR [esi], eax

; 53   : 			if (_Myistr.rdbuf() != 0)

  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000e	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00012	85 c0		 test	 eax, eax
  00014	74 09		 je	 SHORT $L67255

; 54   : 				_Myistr.rdbuf()->_Lock();

  00016	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@_Mutex@std@@QAEXXZ
$L67255:

; 55   : 			}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogty
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 52   : 			{	// lock the stream buffer, if there

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Istr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 06		 mov	 DWORD PTR [esi], eax

; 53   : 			if (_Myistr.rdbuf() != 0)

  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000e	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00012	85 c0		 test	 eax, eax
  00014	74 09		 je	 SHORT $L67269

; 54   : 				_Myistr.rdbuf()->_Lock();

  00016	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@_Mutex@std@@QAEXXZ
$L67269:

; 55   : 			}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ
_TEXT	SEGMENT
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData, COMDAT
; _this$ = ecx

; 366  : 			return (this + 1);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 367  : 		}

  00003	c3		 ret	 0
?GetData@CAtlSafeAllocBufferNode@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXXZ ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::CAtlSafeAllocBufferNode::GetData
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 109  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 110  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
PUBLIC	??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
; Function compile flags: /Ogty
;	COMDAT ??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 109  : 			return (_Ok);

  00000	8a 41 04	 mov	 al, BYTE PTR [ecx+4]

; 110  : 			}

  00003	c3		 ret	 0
??Bsentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::operator bool
_TEXT	ENDS
PUBLIC	?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap, COMDAT
; _this$ = ecx

; 293  : 		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nBytes$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000e	83 c4 04	 add	 esp, 4

; 294  : 		if( p == NULL )

  00011	85 c0		 test	 eax, eax
  00013	75 0a		 jne	 SHORT $L63288

; 295  : 		{
; 296  : 			AtlThrow( E_OUTOFMEMORY );

  00015	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  0001a	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L63288:

; 297  : 		}
; 298  : 		m_p = p;

  0001f	89 06		 mov	 DWORD PTR [esi], eax
  00021	5e		 pop	 esi

; 299  : 	}

  00022	c2 04 00	 ret	 4
$L67281:
?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ostr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 06		 mov	 DWORD PTR [esi], eax

; 69   : 			if (_Myostr.rdbuf() != 0)

  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000e	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00012	85 c0		 test	 eax, eax
  00014	74 09		 je	 SHORT $L67295

; 70   : 				_Myostr.rdbuf()->_Lock();

  00016	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@_Mutex@std@@QAEXXZ
$L67295:

; 71   : 			}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogty
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $L67307

; 76   : 				_Myostr.rdbuf()->_Unlock();

  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L67307:

; 77   : 			}

  00018	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
; Function compile flags: /Ogty
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 68   : 			{	// lock the stream buffer, if there

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ostr$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 06		 mov	 DWORD PTR [esi], eax

; 69   : 			if (_Myostr.rdbuf() != 0)

  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0000e	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00012	85 c0		 test	 eax, eax
  00014	74 09		 je	 SHORT $L67322

; 70   : 				_Myostr.rdbuf()->_Lock();

  00016	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@_Mutex@std@@QAEXXZ
$L67322:

; 71   : 			}

  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogty
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 75   : 			if (_Myostr.rdbuf() != 0)

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $L67334

; 76   : 				_Myostr.rdbuf()->_Unlock();

  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L67334:

; 77   : 			}

  00018	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	__TI2?AVbad_cast@@
PUBLIC	__CTA2?AVbad_cast@@
PUBLIC	??_R0?AVbad_cast@@@8				; bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??0bad_cast@@QAE@ABV0@@Z:NEAR			; bad_cast::bad_cast
EXTRN	??1bad_cast@@UAE@XZ:NEAR			; bad_cast::~bad_cast
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:NEAR
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:NEAR
EXTRN	__imp_?_Id_cnt@id@locale@std@@0HA:DWORD
EXTRN	__imp_?_Incref@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Register@facet@locale@std@@QAEXXZ:NEAR
EXTRN	__imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z:NEAR
EXTRN	__CxxThrowException@8:NEAR
EXTRN	??_7type_info@@6B@:DWORD			; type_info::`vftable'
EXTRN	__imp_??0bad_cast@@QAE@PBD@Z:NEAR
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
; File d:\program files\microsoft visual studio .net 2003\vc7\include\xlocale
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67356	DD	0ffffffffH
	DD	FLAT:$L67341
$T67353	DD	019930520H
	DD	01H
	DD	FLAT:$T67356
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT __TI2?AVbad_cast@@
xdata$x	SEGMENT
__TI2?AVbad_cast@@ DD 00H
	DD	FLAT:??1bad_cast@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@@@8??0bad_cast@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@@@8
_DATA	SEGMENT
??_R0?AVbad_cast@@@8 DD FLAT:??_7type_info@@6B@		; bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
; Function compile flags: /Ogty
_DATA	ENDS
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$ = -36						; size = 4
__Lock$67346 = -32					; size = 4
__Lock$ = -28						; size = 4
$T67338 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<char> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 18	 sub	 esp, 24			; 00000018H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00021	6a 00		 push	 0
  00023	8d 4c 24 18	 lea	 ecx, DWORD PTR __Lock$[esp+52]
  00027	ff d7		 call	 edi

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  0002e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  00034	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0003a	89 44 24 0c	 mov	 DWORD PTR __Psave$[esp+48], eax
  0003e	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00041	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+56], 0
  00049	75 24		 jne	 SHORT $L67345
  0004b	6a 00		 push	 0
  0004d	8d 4c 24 14	 lea	 ecx, DWORD PTR __Lock$67346[esp+52]
  00051	ff d7		 call	 edi
  00053	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00056	75 11		 jne	 SHORT $L67347
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?_Id_cnt@id@locale@std@@0HA
  0005d	ff 00		 inc	 DWORD PTR [eax]
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?_Id_cnt@id@locale@std@@0HA
  00065	8b 11		 mov	 edx, DWORD PTR [ecx]
  00067	89 16		 mov	 DWORD PTR [esi], edx
$L67347:
  00069	8d 4c 24 10	 lea	 ecx, DWORD PTR __Lock$67346[esp+48]
  0006d	ff d3		 call	 ebx
$L67345:
  0006f	8b 36		 mov	 esi, DWORD PTR [esi]

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00071	8b 4c 24 34	 mov	 ecx, DWORD PTR __Loc$[esp+44]
  00075	56		 push	 esi
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  0007c	8b f0		 mov	 esi, eax

; 322  : 
; 323  : 	if (_Pf != 0)

  0007e	85 f6		 test	 esi, esi
  00080	75 55		 jne	 SHORT $L63864

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  00082	8b 74 24 0c	 mov	 esi, DWORD PTR __Psave$[esp+48]
  00086	85 f6		 test	 esi, esi

; 326  : 		_Pf = _Psave;	// lazy facet already allocated
; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00088	75 4d		 jne	 SHORT $L63864
  0008a	8d 44 24 0c	 lea	 eax, DWORD PTR __Psave$[esp+48]
  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@@Z
  00095	83 c4 04	 add	 esp, 4
  00098	83 f8 ff	 cmp	 eax, -1
  0009b	75 1e		 jne	 SHORT $L63853

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  000a2	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T67338[esp+52]
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  000ac	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  000b1	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T67338[esp+52]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 __CxxThrowException@8
$L63853:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  000bb	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Psave$[esp+48]
  000bf	8b f1		 mov	 esi, ecx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  000c1	89 0d 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::ctype<char> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000c7	8b f9		 mov	 edi, ecx

; 342  : 		_Pfmod->_Incref();

  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000cf	8b cf		 mov	 ecx, edi
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L63864:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000d7	8d 4c 24 14	 lea	 ecx, DWORD PTR __Lock$[esp+48]
  000db	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  000e3	ff d3		 call	 ebx

; 347  : 	}

  000e5	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000e9	5f		 pop	 edi
  000ea	8b c6		 mov	 eax, esi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f5	83 c4 24	 add	 esp, 36			; 00000024H
  000f8	c3		 ret	 0
$L67355:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67341:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67353
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
EXTRN	__imp_?id@?$ctype@_W@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z:NEAR
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67379	DD	0ffffffffH
	DD	FLAT:$L67364
$T67376	DD	019930520H
	DD	01H
	DD	FLAT:$T67379
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
__Psave$ = -36						; size = 4
__Lock$67369 = -32					; size = 4
__Lock$ = -28						; size = 4
$T67362 = -24						; size = 12
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC NEAR ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 315  : 	{	// get facet reference from locale

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 18	 sub	 esp, 24			; 00000018H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 316  : 	_Lockit _Lock(_LOCK_LOCALE);	// the thread lock, make get atomic

  0001b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00021	6a 00		 push	 0
  00023	8d 4c 24 18	 lea	 ecx, DWORD PTR __Lock$[esp+52]
  00027	ff d7		 call	 edi

; 317  : 	const locale::facet *_Psave =
; 318  : 		_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 319  : 
; 320  : 	size_t _Id = _Facet::id;

  0002e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_?id@?$ctype@_W@std@@2V0locale@2@A
  00034	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0003a	89 44 24 0c	 mov	 DWORD PTR __Psave$[esp+48], eax
  0003e	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00041	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+56], 0
  00049	75 24		 jne	 SHORT $L67368
  0004b	6a 00		 push	 0
  0004d	8d 4c 24 14	 lea	 ecx, DWORD PTR __Lock$67369[esp+52]
  00051	ff d7		 call	 edi
  00053	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00056	75 11		 jne	 SHORT $L67370
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?_Id_cnt@id@locale@std@@0HA
  0005d	ff 00		 inc	 DWORD PTR [eax]
  0005f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?_Id_cnt@id@locale@std@@0HA
  00065	8b 11		 mov	 edx, DWORD PTR [ecx]
  00067	89 16		 mov	 DWORD PTR [esi], edx
$L67370:
  00069	8d 4c 24 10	 lea	 ecx, DWORD PTR __Lock$67369[esp+48]
  0006d	ff d3		 call	 ebx
$L67368:
  0006f	8b 36		 mov	 esi, DWORD PTR [esi]

; 321  : 	const locale::facet *_Pf = _Loc._Getfacet(_Id);

  00071	8b 4c 24 34	 mov	 ecx, DWORD PTR __Loc$[esp+44]
  00075	56		 push	 esi
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
  0007c	8b f0		 mov	 esi, eax

; 322  : 
; 323  : 	if (_Pf != 0)

  0007e	85 f6		 test	 esi, esi
  00080	75 55		 jne	 SHORT $L63892

; 324  : 		;	// got facet from locale
; 325  : 	else if (_Psave != 0)

  00082	8b 74 24 0c	 mov	 esi, DWORD PTR __Psave$[esp+48]
  00086	85 f6		 test	 esi, esi

; 326  : 		_Pf = _Psave;	// lazy facet already allocated
; 327  : 	else if (_Facet::_Getcat(&_Psave) == (size_t)(-1))

  00088	75 4d		 jne	 SHORT $L63892
  0008a	8d 44 24 0c	 lea	 eax, DWORD PTR __Psave$[esp+48]
  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@@Z
  00095	83 c4 04	 add	 esp, 4
  00098	83 f8 ff	 cmp	 eax, -1
  0009b	75 1e		 jne	 SHORT $L63889

; 328  : 
; 329  :  #if _HAS_EXCEPTIONS
; 330  : 		throw bad_cast();	// lazy disallowed

  0009d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  000a2	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T67362[esp+52]
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0bad_cast@@QAE@PBD@Z
  000ac	68 00 00 00 00	 push	 OFFSET FLAT:__TI2?AVbad_cast@@
  000b1	8d 4c 24 1c	 lea	 ecx, DWORD PTR $T67362[esp+52]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 __CxxThrowException@8
$L63889:

; 331  : 
; 332  :  #else /* _HAS_EXCEPTIONS */
; 333  : 		abort();	// lazy disallowed
; 334  :  #endif /* _HAS_EXCEPTIONS */
; 335  : 
; 336  : 	else
; 337  : 		{	// queue up lazy facet for destruction
; 338  : 		_Pf = _Psave;

  000bb	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Psave$[esp+48]
  000bf	8b f1		 mov	 esi, ecx

; 339  : 		_Facetptr<_Facet>::_Psave = _Psave;

  000c1	89 0d 00 00 00
	00		 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, ecx ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 340  : 
; 341  : 		locale::facet *_Pfmod = (_Facet *)_Psave;

  000c7	8b f9		 mov	 edi, ecx

; 342  : 		_Pfmod->_Incref();

  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Incref@facet@locale@std@@QAEXXZ

; 343  : 		_Pfmod->_Register();

  000cf	8b cf		 mov	 ecx, edi
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Register@facet@locale@std@@QAEXXZ
$L63892:

; 344  : 		}
; 345  : 
; 346  : 	return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000d7	8d 4c 24 14	 lea	 ecx, DWORD PTR __Lock$[esp+48]
  000db	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  000e3	ff d3		 call	 ebx

; 347  : 	}

  000e5	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  000e9	5f		 pop	 edi
  000ea	8b c6		 mov	 eax, esi
  000ec	5e		 pop	 esi
  000ed	5b		 pop	 ebx
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000f5	83 c4 24	 add	 esp, 36			; 00000024H
  000f8	c3		 ret	 0
$L67378:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67364:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67376
  0000e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	SEGMENT
$T67393	DD	0ffffffffH
	DD	FLAT:$L67387
	DD	00H
	DD	FLAT:$L67386
$T67391	DD	019930520H
	DD	02H
	DD	FLAT:$T67393
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
_TEXT	SEGMENT
$T67388 = -44						; size = 4
$T67385 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 21   : 	{	// return string + string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67385[esp+52]
  00022	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T67388[esp+52], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00030	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00034	51		 push	 ecx
  00035	8b c8		 mov	 ecx, eax
  00037	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00045	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  00049	50		 push	 eax
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00052	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67385[esp+48]
  00056	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67388[esp+48], 1
  0005e	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 23   : 	}

  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67386:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67385[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67387:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67388[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67389
  00015	83 65 d4 fe	 and	 DWORD PTR $T67388[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67389:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67391
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67406	DD	0ffffffffH
	DD	FLAT:$L67400
	DD	00H
	DD	FLAT:$L67399
$T67404	DD	019930520H
	DD	02H
	DD	FLAT:$T67406
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
$T67401 = -44						; size = 4
$T67398 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67398[esp+52]
  00022	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T67401[esp+52], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00030	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00034	51		 push	 ecx
  00035	8b c8		 mov	 ecx, eax
  00037	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00045	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  00049	50		 push	 eax
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00052	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67398[esp+48]
  00056	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67401[esp+48], 1
  0005e	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 33   : 	}

  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67399:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67398[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67400:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67401[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67402
  00015	83 65 d4 fe	 and	 DWORD PTR $T67401[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67402:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67404
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67419	DD	0ffffffffH
	DD	FLAT:$L67413
	DD	00H
	DD	FLAT:$L67412
$T67417	DD	019930520H
	DD	02H
	DD	FLAT:$T67419
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
_TEXT	SEGMENT
$T67414 = -44						; size = 4
$T67411 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 1
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 41   : 	{	// return character + string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	6a 01		 push	 1
  00020	8d 4c 24 10	 lea	 ecx, DWORD PTR $T67411[esp+56]
  00024	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR $T67414[esp+56], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
  00032	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00036	51		 push	 ecx
  00037	8b c8		 mov	 ecx, eax
  00039	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  00047	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  0004b	50		 push	 eax
  0004c	8b ce		 mov	 ecx, esi
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00054	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67411[esp+48]
  00058	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67414[esp+48], 1
  00060	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 43   : 	}

  0006b	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006f	8b c6		 mov	 eax, esi
  00071	5e		 pop	 esi
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67412:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67411[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67413:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67414[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67415
  00015	83 65 d4 fe	 and	 DWORD PTR $T67414[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67415:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67417
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@DABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67432	DD	0ffffffffH
	DD	FLAT:$L67426
	DD	00H
	DD	FLAT:$L67425
$T67430	DD	019930520H
	DD	02H
	DD	FLAT:$T67432
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
$T67427 = -44						; size = 4
$T67424 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67424[esp+52]
  00022	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T67427[esp+52], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00030	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00034	51		 push	 ecx
  00035	8b c8		 mov	 ecx, eax
  00037	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
  00045	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  00049	50		 push	 eax
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00052	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67424[esp+48]
  00056	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67427[esp+48], 1
  0005e	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 53   : 	}

  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67425:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67424[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67426:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67427[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67428
  00015	83 65 d4 fe	 and	 DWORD PTR $T67427[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67428:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67430
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67445	DD	0ffffffffH
	DD	FLAT:$L67439
	DD	00H
	DD	FLAT:$L67438
$T67443	DD	019930520H
	DD	02H
	DD	FLAT:$T67445
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
_TEXT	SEGMENT
$T67440 = -44						; size = 4
$T67437 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 1
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 61   : 	{	// return string + character

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67437[esp+52]
  00022	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T67440[esp+52], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00030	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00034	51		 push	 ecx
  00035	8b c8		 mov	 ecx, eax
  00037	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
  00045	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  00049	50		 push	 eax
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00052	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67437[esp+48]
  00056	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67440[esp+48], 1
  0005e	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 63   : 	}

  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67438:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67437[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67439:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67440[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67441
  00015	83 65 d4 fe	 and	 DWORD PTR $T67440[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67441:
  00022	c3		 ret	 0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67443
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:NEAR
EXTRN	__imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ:NEAR
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67458	DD	0ffffffffH
	DD	FLAT:$L67452
	DD	00H
	DD	FLAT:$L67451
$T67456	DD	019930520H
	DD	02H
	DD	FLAT:$T67458
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
_TEXT	SEGMENT
$T67453 = -44						; size = 4
$T67450 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 21   : 	{	// return string + string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 22   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67450[esp+52]
  00022	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T67453[esp+52], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00030	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00034	51		 push	 ecx
  00035	8b c8		 mov	 ecx, eax
  00037	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  00045	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  00049	50		 push	 eax
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00052	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67450[esp+48]
  00056	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67453[esp+48], 1
  0005e	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ

; 23   : 	}

  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67451:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67450[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67452:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67453[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67454
  00015	83 65 d4 fe	 and	 DWORD PTR $T67453[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67454:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67456
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@0@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67471	DD	0ffffffffH
	DD	FLAT:$L67465
	DD	00H
	DD	FLAT:$L67464
$T67469	DD	019930520H
	DD	02H
	DD	FLAT:$T67471
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
_TEXT	SEGMENT
$T67466 = -44						; size = 4
$T67463 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 31   : 	{	// return NTCS + string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67463[esp+52]
  00022	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T67466[esp+52], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
  00030	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00034	51		 push	 ecx
  00035	8b c8		 mov	 ecx, eax
  00037	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  00045	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  00049	50		 push	 eax
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00052	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67463[esp+48]
  00056	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67466[esp+48], 1
  0005e	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ

; 33   : 	}

  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67464:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67463[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67465:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67466[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67467
  00015	83 65 d4 fe	 and	 DWORD PTR $T67466[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67467:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67469
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67484	DD	0ffffffffH
	DD	FLAT:$L67478
	DD	00H
	DD	FLAT:$L67477
$T67482	DD	019930520H
	DD	02H
	DD	FLAT:$T67484
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
_TEXT	SEGMENT
$T67479 = -44						; size = 4
$T67476 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 2
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 41   : 	{	// return character + string

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 42   : 	return (basic_string<_Elem, _Traits, _Alloc>(1, _Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	6a 01		 push	 1
  00020	8d 4c 24 10	 lea	 ecx, DWORD PTR $T67476[esp+56]
  00024	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR $T67479[esp+56], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@I_W@Z
  00032	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00036	51		 push	 ecx
  00037	8b c8		 mov	 ecx, eax
  00039	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
  00047	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  0004b	50		 push	 eax
  0004c	8b ce		 mov	 ecx, esi
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00054	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67476[esp+48]
  00058	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67479[esp+48], 1
  00060	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ

; 43   : 	}

  0006b	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006f	8b c6		 mov	 eax, esi
  00071	5e		 pop	 esi
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00079	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67477:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67476[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67478:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67479[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67480
  00015	83 65 d4 fe	 and	 DWORD PTR $T67479[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67480:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67482
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_WABV10@@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67497	DD	0ffffffffH
	DD	FLAT:$L67491
	DD	00H
	DD	FLAT:$L67490
$T67495	DD	019930520H
	DD	02H
	DD	FLAT:$T67497
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
_TEXT	SEGMENT
$T67492 = -44						; size = 4
$T67489 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 51   : 	{	// return string + NTCS

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67489[esp+52]
  00022	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T67492[esp+52], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00030	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00034	51		 push	 ecx
  00035	8b c8		 mov	 ecx, eax
  00037	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
  00045	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  00049	50		 push	 eax
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00052	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67489[esp+48]
  00056	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67492[esp+48], 1
  0005e	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ

; 53   : 	}

  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67490:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67489[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67491:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67492[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67493
  00015	83 65 d4 fe	 and	 DWORD PTR $T67492[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67493:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67495
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@PB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67510	DD	0ffffffffH
	DD	FLAT:$L67504
	DD	00H
	DD	FLAT:$L67503
$T67508	DD	019930520H
	DD	02H
	DD	FLAT:$T67510
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
_TEXT	SEGMENT
$T67505 = -44						; size = 4
$T67502 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 2
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z PROC NEAR ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 61   : 	{	// return string + character

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 20	 sub	 esp, 32			; 00000020H

; 62   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

  00018	8b 44 24 34	 mov	 eax, DWORD PTR __Left$[esp+40]
  0001c	56		 push	 esi
  0001d	50		 push	 eax
  0001e	8d 4c 24 0c	 lea	 ecx, DWORD PTR $T67502[esp+52]
  00022	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR $T67505[esp+52], 0
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00030	8b 4c 24 3c	 mov	 ecx, DWORD PTR __Right$[esp+44]
  00034	51		 push	 ecx
  00035	8b c8		 mov	 ecx, eax
  00037	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 1
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
  00045	8b 74 24 34	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+44]
  00049	50		 push	 eax
  0004a	8b ce		 mov	 ecx, esi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00052	8d 4c 24 08	 lea	 ecx, DWORD PTR $T67502[esp+48]
  00056	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR $T67505[esp+48], 1
  0005e	c6 44 24 2c 00	 mov	 BYTE PTR __$EHRec$[esp+56], 0
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ

; 63   : 	}

  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00077	83 c4 2c	 add	 esp, 44			; 0000002cH
  0007a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67503:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T67502[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67504:
  00009	8b 45 d4	 mov	 eax, DWORD PTR $T67505[ebp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	0f 84 0d 00 00
	00		 je	 $L67506
  00015	83 65 d4 fe	 and	 DWORD PTR $T67505[ebp], -2 ; fffffffeH
  00019	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0001c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
$L67506:
  00022	c3		 ret	 0
__ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z:
  00023	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67508
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogty
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $L67535
  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L67535:
  00018	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Ogty
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $L67559
  0000f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00012	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L67559:
  00018	c3		 ret	 0
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
_TEXT	ENDS
PUBLIC	??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@		; `string'
PUBLIC	?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@Z ; FuncGetInstallPath
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	SEGMENT
$T67590	DD	0ffffffffH
	DD	FLAT:$L67564
	DD	00H
	DD	FLAT:$L67565
	DD	01H
	DD	FLAT:$L67566
	DD	02H
	DD	FLAT:$L67567
	DD	03H
	DD	FLAT:$L67568
$T67588	DD	019930520H
	DD	05H
	DD	FLAT:$T67590
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@ DB '%s\%s', 00H	; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@Z
_TEXT	SEGMENT
_strRet$ = -28						; size = 4
_strAppRoot$ = -24					; size = 4
_strCid$60491 = -20					; size = 4
$T67570 = -16						; size = 4
$T67563 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_strDir$ = 12						; size = 4
?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@Z PROC NEAR ; FuncGetInstallPath, COMDAT

; 40   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	56		 push	 esi
  00019	33 f6		 xor	 esi, esi
  0001b	89 74 24 10	 mov	 DWORD PTR $T67570[esp+32], esi

; 41   : 	CString strAppRoot= FuncGetInstallPath();

  0001f	8d 44 24 08	 lea	 eax, DWORD PTR _strAppRoot$[esp+32]
  00023	50		 push	 eax
  00024	89 74 24 20	 mov	 DWORD PTR __$EHRec$[esp+44], esi
  00028	e8 00 00 00 00	 call	 ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
  0002d	83 c4 04	 add	 esp, 4

; 42   : 	CString strRet="";

  00030	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00035	8d 4c 24 08	 lea	 ecx, DWORD PTR _strRet$[esp+36]
  00039	c6 44 24 20 01	 mov	 BYTE PTR __$EHRec$[esp+44], 1
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 43   : 
; 44   : 	if(strAppRoot.GetLength()>0)

  00044	8b 4c 24 08	 mov	 ecx, DWORD PTR _strAppRoot$[esp+32]
  00048	39 71 f4	 cmp	 DWORD PTR [ecx-12], esi
  0004b	c6 44 24 1c 02	 mov	 BYTE PTR __$EHRec$[esp+40], 2
  00050	0f 8e ce 00 00
	00		 jle	 $L60490

; 45   : 	{
; 46   : 		if(strDir != "")

  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0005b	8d 4c 24 2c	 lea	 ecx, DWORD PTR _strDir$[esp+32]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00065	85 c0		 test	 eax, eax
  00067	74 22		 je	 SHORT $L60488

; 47   : 			strRet.Format("%s\\%s",strAppRoot, strDir);

  00069	8b 54 24 28	 mov	 edx, DWORD PTR _strDir$[esp+28]
  0006d	8b 44 24 08	 mov	 eax, DWORD PTR _strAppRoot$[esp+32]
  00071	52		 push	 edx
  00072	50		 push	 eax
  00073	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strRet$[esp+40]
  00077	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
  0007c	51		 push	 ecx
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00083	83 c4 10	 add	 esp, 16			; 00000010H

; 48   : 		else

  00086	e9 99 00 00 00	 jmp	 $L60490
$L60488:

; 49   : 		{
; 50   : 			CString strCid = _T("");

  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00090	8d 4c 24 10	 lea	 ecx, DWORD PTR _strCid$60491[esp+36]
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 51   : 			strCid = GetCIDFromCookie();

  0009a	8d 54 24 10	 lea	 edx, DWORD PTR $T67563[esp+32]
  0009e	52		 push	 edx
  0009f	c6 44 24 20 03	 mov	 BYTE PTR __$EHRec$[esp+44], 3
  000a4	e8 00 00 00 00	 call	 ?GetCIDFromCookie@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; GetCIDFromCookie
  000a9	83 c4 04	 add	 esp, 4
  000ac	50		 push	 eax
  000ad	8d 4c 24 10	 lea	 ecx, DWORD PTR _strCid$60491[esp+36]
  000b1	c6 44 24 20 04	 mov	 BYTE PTR __$EHRec$[esp+44], 4
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000bc	8d 4c 24 10	 lea	 ecx, DWORD PTR $T67563[esp+32]
  000c0	c6 44 24 1c 03	 mov	 BYTE PTR __$EHRec$[esp+40], 3
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 52   : 
; 53   : 			if(strCid != "")

  000cb	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000d0	8d 4c 24 10	 lea	 ecx, DWORD PTR _strCid$60491[esp+36]
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  000da	85 c0		 test	 eax, eax
  000dc	74 1f		 je	 SHORT $L60493

; 54   : 				strRet.Format("%s\\%s",strAppRoot, strCid);

  000de	8b 44 24 0c	 mov	 eax, DWORD PTR _strCid$60491[esp+32]
  000e2	8b 4c 24 08	 mov	 ecx, DWORD PTR _strAppRoot$[esp+32]
  000e6	50		 push	 eax
  000e7	51		 push	 ecx
  000e8	8d 54 24 0c	 lea	 edx, DWORD PTR _strRet$[esp+40]
  000ec	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05BMGBEOOC@?$CFs?2?$CFs?$AA@
  000f1	52		 push	 edx
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000f8	83 c4 10	 add	 esp, 16			; 00000010H

; 55   : 			else

  000fb	eb 18		 jmp	 SHORT $L60494
$L60493:

; 56   : 				strRet.Format("%s",strAppRoot);

  000fd	8b 44 24 08	 mov	 eax, DWORD PTR _strAppRoot$[esp+32]
  00101	50		 push	 eax
  00102	8d 4c 24 08	 lea	 ecx, DWORD PTR _strRet$[esp+36]
  00106	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  0010b	51		 push	 ecx
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH
$L60494:

; 57   : 		}

  00115	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strCid$60491[esp+32]
  00119	c6 44 24 1c 02	 mov	 BYTE PTR __$EHRec$[esp+40], 2
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L60490:

; 58   : 	}
; 59   : 
; 60   : 	return strRet;

  00124	8b 74 24 24	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+28]
  00128	8d 54 24 04	 lea	 edx, DWORD PTR _strRet$[esp+32]
  0012c	52		 push	 edx
  0012d	8b ce		 mov	 ecx, esi
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00135	8d 4c 24 04	 lea	 ecx, DWORD PTR _strRet$[esp+32]
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0013f	8d 4c 24 08	 lea	 ecx, DWORD PTR _strAppRoot$[esp+32]
  00143	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00149	8d 4c 24 28	 lea	 ecx, DWORD PTR _strDir$[esp+28]
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 61   : }

  00153	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  00157	8b c6		 mov	 eax, esi
  00159	5e		 pop	 esi
  0015a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00161	83 c4 1c	 add	 esp, 28			; 0000001cH
  00164	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67564:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strDir$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67565:
  00009	8d 4d e8	 lea	 ecx, DWORD PTR _strAppRoot$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67566:
  00012	8d 4d e4	 lea	 ecx, DWORD PTR _strRet$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67567:
  0001b	8d 4d ec	 lea	 ecx, DWORD PTR _strCid$60491[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67568:
  00024	8d 4d f0	 lea	 ecx, DWORD PTR $T67563[ebp]
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@Z:
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67588
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@@Z ENDP ; FuncGetInstallPath
PUBLIC	?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ; FuncGetStringFromIDS
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T67622	DD	0ffffffffH
	DD	FLAT:$L67601
	DD	00H
	DD	FLAT:$L67597
	DD	01H
	DD	FLAT:$L67598
	DD	02H
	DD	FLAT:$L67600
$T67619	DD	019930520H
	DD	04H
	DD	FLAT:$T67622
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	ENDS
;	COMDAT ?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
_TEXT	SEGMENT
_strRet$ = -84						; size = 4
$T67602 = -80						; size = 4
$T67596 = -76						; size = 4
_sRet$ = -72						; size = 28
_rKey$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_szIDS$ = 12						; size = 4
?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z PROC NEAR ; FuncGetStringFromIDS, COMDAT

; 64   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 48	 sub	 esp, 72			; 00000048H
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	56		 push	 esi

; 65   : 	CString strRet="";

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00023	8d 4c 24 08	 lea	 ecx, DWORD PTR _strRet$[esp+92]
  00027	89 44 24 4c	 mov	 DWORD PTR __$ArrayPad$[esp+92], eax
  0002b	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR $T67602[esp+92], 0
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 66   : 	std::string rKey;

  00039	8d 4c 24 2c	 lea	 ecx, DWORD PTR _rKey$[esp+88]
  0003d	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+96], 1
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 67   : 	if(szIDS)

  0004b	8b 44 24 60	 mov	 eax, DWORD PTR _szIDS$[esp+84]
  0004f	85 c0		 test	 eax, eax
  00051	c6 44 24 54 02	 mov	 BYTE PTR __$EHRec$[esp+96], 2
  00056	74 0b		 je	 SHORT $L60502

; 68   : 		rKey = szIDS;

  00058	50		 push	 eax
  00059	8d 4c 24 30	 lea	 ecx, DWORD PTR _rKey$[esp+92]
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$L60502:

; 69   : 	std::string sRet= GetResourceValue(rKey);

  00063	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00066	8d 44 24 48	 lea	 eax, DWORD PTR _rKey$[esp+116]
  0006a	8b cc		 mov	 ecx, esp
  0006c	89 64 24 28	 mov	 DWORD PTR $T67596[esp+116], esp
  00070	50		 push	 eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00077	8d 4c 24 2c	 lea	 ecx, DWORD PTR _sRet$[esp+116]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 ?GetResourceValue@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ; GetResourceValue
  00081	83 c4 20	 add	 esp, 32			; 00000020H

; 70   : 	strRet = sRet.c_str();

  00084	83 7c 24 28 10	 cmp	 DWORD PTR _sRet$[esp+112], 16 ; 00000010H
  00089	8b 44 24 14	 mov	 eax, DWORD PTR _sRet$[esp+92]
  0008d	c6 44 24 54 03	 mov	 BYTE PTR __$EHRec$[esp+96], 3
  00092	73 04		 jae	 SHORT $L67615
  00094	8d 44 24 14	 lea	 eax, DWORD PTR _sRet$[esp+92]
$L67615:
  00098	50		 push	 eax
  00099	8d 4c 24 08	 lea	 ecx, DWORD PTR _strRet$[esp+92]
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 71   : 	return strRet;

  000a3	8b 74 24 5c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+84]
  000a7	8d 54 24 04	 lea	 edx, DWORD PTR _strRet$[esp+88]
  000ab	52		 push	 edx
  000ac	8b ce		 mov	 ecx, esi
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  000b4	8d 4c 24 10	 lea	 ecx, DWORD PTR _sRet$[esp+88]
  000b8	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR $T67602[esp+88], 1
  000c0	c6 44 24 54 02	 mov	 BYTE PTR __$EHRec$[esp+96], 2
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000cb	8d 4c 24 2c	 lea	 ecx, DWORD PTR _rKey$[esp+88]
  000cf	c6 44 24 54 01	 mov	 BYTE PTR __$EHRec$[esp+96], 1
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000da	8d 4c 24 04	 lea	 ecx, DWORD PTR _strRet$[esp+88]
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 72   : }

  000e4	8b 4c 24 4c	 mov	 ecx, DWORD PTR __$EHRec$[esp+88]
  000e8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ef	8b 4c 24 48	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+88]
  000f3	8b c6		 mov	 eax, esi
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	5e		 pop	 esi
  000fb	83 c4 54	 add	 esp, 84			; 00000054H
  000fe	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67597:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR _strRet$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67598:
  00009	8d 4d d4	 lea	 ecx, DWORD PTR _rKey$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67600:
  00012	8d 4d b8	 lea	 ecx, DWORD PTR _sRet$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67601:
  0001b	8b 45 b0	 mov	 eax, DWORD PTR $T67602[ebp]
  0001e	83 e0 01	 and	 eax, 1
  00021	0f 84 0d 00 00
	00		 je	 $L67603
  00027	83 65 b0 fe	 and	 DWORD PTR $T67602[ebp], -2 ; fffffffeH
  0002b	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0002e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67603:
  00034	c3		 ret	 0
__ehhandler$?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67619
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD@Z ENDP ; FuncGetStringFromIDS
PUBLIC	?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD0@Z ; FuncGetStringFromIDS
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T67654	DD	0ffffffffH
	DD	FLAT:$L67633
	DD	00H
	DD	FLAT:$L67629
	DD	01H
	DD	FLAT:$L67630
	DD	02H
	DD	FLAT:$L67632
$T67651	DD	019930520H
	DD	04H
	DD	FLAT:$T67654
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	ENDS
;	COMDAT ?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD0@Z
_TEXT	SEGMENT
_strRet$ = -84						; size = 4
$T67634 = -80						; size = 4
$T67628 = -76						; size = 4
_sRet$ = -72						; size = 28
_rKey$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_szSection$ = 12					; size = 4
_szIDS$ = 16						; size = 4
?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD0@Z PROC NEAR ; FuncGetStringFromIDS, COMDAT

; 76   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD0@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 48	 sub	 esp, 72			; 00000048H
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	56		 push	 esi

; 77   : 	CString strRet="";

  0001e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00023	8d 4c 24 08	 lea	 ecx, DWORD PTR _strRet$[esp+92]
  00027	89 44 24 4c	 mov	 DWORD PTR __$ArrayPad$[esp+92], eax
  0002b	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR $T67634[esp+92], 0
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 78   : 	std::string rKey;

  00039	8d 4c 24 2c	 lea	 ecx, DWORD PTR _rKey$[esp+88]
  0003d	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+96], 1
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 79   : 	if(szIDS)

  0004b	8b 44 24 64	 mov	 eax, DWORD PTR _szIDS$[esp+84]
  0004f	85 c0		 test	 eax, eax
  00051	c6 44 24 54 02	 mov	 BYTE PTR __$EHRec$[esp+96], 2
  00056	74 0b		 je	 SHORT $L60513

; 80   : 		rKey = szIDS;

  00058	50		 push	 eax
  00059	8d 4c 24 30	 lea	 ecx, DWORD PTR _rKey$[esp+92]
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$L60513:

; 81   : 	std::string sRet= GetResourceValue(rKey);

  00063	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00066	8d 44 24 48	 lea	 eax, DWORD PTR _rKey$[esp+116]
  0006a	8b cc		 mov	 ecx, esp
  0006c	89 64 24 28	 mov	 DWORD PTR $T67628[esp+116], esp
  00070	50		 push	 eax
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00077	8d 4c 24 2c	 lea	 ecx, DWORD PTR _sRet$[esp+116]
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 ?GetResourceValue@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ; GetResourceValue
  00081	83 c4 20	 add	 esp, 32			; 00000020H

; 82   : 	strRet = sRet.c_str();

  00084	83 7c 24 28 10	 cmp	 DWORD PTR _sRet$[esp+112], 16 ; 00000010H
  00089	8b 44 24 14	 mov	 eax, DWORD PTR _sRet$[esp+92]
  0008d	c6 44 24 54 03	 mov	 BYTE PTR __$EHRec$[esp+96], 3
  00092	73 04		 jae	 SHORT $L67647
  00094	8d 44 24 14	 lea	 eax, DWORD PTR _sRet$[esp+92]
$L67647:
  00098	50		 push	 eax
  00099	8d 4c 24 08	 lea	 ecx, DWORD PTR _strRet$[esp+92]
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@PBD@Z

; 83   : 	return strRet;

  000a3	8b 74 24 5c	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+84]
  000a7	8d 54 24 04	 lea	 edx, DWORD PTR _strRet$[esp+88]
  000ab	52		 push	 edx
  000ac	8b ce		 mov	 ecx, esi
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  000b4	8d 4c 24 10	 lea	 ecx, DWORD PTR _sRet$[esp+88]
  000b8	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR $T67634[esp+88], 1
  000c0	c6 44 24 54 02	 mov	 BYTE PTR __$EHRec$[esp+96], 2
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000cb	8d 4c 24 2c	 lea	 ecx, DWORD PTR _rKey$[esp+88]
  000cf	c6 44 24 54 01	 mov	 BYTE PTR __$EHRec$[esp+96], 1
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  000da	8d 4c 24 04	 lea	 ecx, DWORD PTR _strRet$[esp+88]
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 84   : }

  000e4	8b 4c 24 4c	 mov	 ecx, DWORD PTR __$EHRec$[esp+88]
  000e8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ef	8b 4c 24 48	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+88]
  000f3	8b c6		 mov	 eax, esi
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	5e		 pop	 esi
  000fb	83 c4 54	 add	 esp, 84			; 00000054H
  000fe	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67629:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR _strRet$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67630:
  00009	8d 4d d4	 lea	 ecx, DWORD PTR _rKey$[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67632:
  00012	8d 4d b8	 lea	 ecx, DWORD PTR _sRet$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$L67633:
  0001b	8b 45 b0	 mov	 eax, DWORD PTR $T67634[ebp]
  0001e	83 e0 01	 and	 eax, 1
  00021	0f 84 0d 00 00
	00		 je	 $L67635
  00027	83 65 b0 fe	 and	 DWORD PTR $T67634[ebp], -2 ; fffffffeH
  0002b	8b 4d 04	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
  0002e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67635:
  00034	c3		 ret	 0
__ehhandler$?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD0@Z:
  00035	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67651
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?FuncGetStringFromIDS@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@PBD0@Z ENDP ; FuncGetStringFromIDS
PUBLIC	??_C@_05ONEOBAM@?$CFs_?$CFs?$AA@		; `string'
PUBLIC	??_C@_09BMHOOPHN@oscmd?4ini?$AA@		; `string'
PUBLIC	?DFNParser_GetPrivateProfileString@@YAKPBD00PADK0@Z ; DFNParser_GetPrivateProfileString
;	COMDAT ??_C@_05ONEOBAM@?$CFs_?$CFs?$AA@
CONST	SEGMENT
??_C@_05ONEOBAM@?$CFs_?$CFs?$AA@ DB '%s_%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BMHOOPHN@oscmd?4ini?$AA@
CONST	SEGMENT
??_C@_09BMHOOPHN@oscmd?4ini?$AA@ DB 'oscmd.ini', 00H	; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?DFNParser_GetPrivateProfileString@@YAKPBD00PADK0@Z
_TEXT	SEGMENT
_cKey$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpAppName$ = 8						; size = 4
_lpKeyName$ = 12					; size = 4
_lpDefault$ = 16					; size = 4
_lpReturnedString$ = 20					; size = 4
_nSize$ = 24						; size = 4
_lpFileName$ = 28					; size = 4
?DFNParser_GetPrivateProfileString@@YAKPBD00PADK0@Z PROC NEAR ; DFNParser_GetPrivateProfileString, COMDAT

; 201  : {

  00000	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	57		 push	 edi
  0000c	89 84 24 04 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+264], eax

; 202  : 	char cKey[255]={0};

  00013	33 c0		 xor	 eax, eax
  00015	c6 44 24 04 00	 mov	 BYTE PTR _cKey$[esp+264], 0
  0001a	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  0001f	8d 7c 24 05	 lea	 edi, DWORD PTR _cKey$[esp+265]
  00023	f3 ab		 rep stosd

; 203  : 	sprintf(cKey,"%s_%s",lpAppName,lpKeyName);

  00025	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR _lpAppName$[esp+260]
  0002c	66 ab		 stosw
  0002e	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR _lpKeyName$[esp+260]
  00035	50		 push	 eax
  00036	51		 push	 ecx
  00037	8d 54 24 0c	 lea	 edx, DWORD PTR _cKey$[esp+272]
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05ONEOBAM@?$CFs_?$CFs?$AA@
  00040	52		 push	 edx
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 204  : 	return  DFN_GetPrivateProfileString(lpFileName,cKey,lpDefault,lpReturnedString,nSize,"oscmd.ini");

  00047	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR _nSize$[esp+276]
  0004e	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR _lpReturnedString$[esp+276]
  00055	8b 94 24 24 01
	00 00		 mov	 edx, DWORD PTR _lpDefault$[esp+276]
  0005c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09BMHOOPHN@oscmd?4ini?$AA@
  00061	50		 push	 eax
  00062	51		 push	 ecx
  00063	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR _lpFileName$[esp+288]
  0006a	52		 push	 edx
  0006b	8d 44 24 24	 lea	 eax, DWORD PTR _cKey$[esp+296]
  0006f	50		 push	 eax
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 ?DFN_GetPrivateProfileString@@YAKPBD00PADK0@Z ; DFN_GetPrivateProfileString

; 205  : 
; 206  : }

  00076	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+304]
  0007d	83 c4 28	 add	 esp, 40			; 00000028H
  00080	5f		 pop	 edi
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  0008c	c3		 ret	 0
?DFNParser_GetPrivateProfileString@@YAKPBD00PADK0@Z ENDP ; DFNParser_GetPrivateProfileString
_TEXT	ENDS
PUBLIC	?DFNParser_GetPrivateProfileInt@@YAHPBD0H0@Z	; DFNParser_GetPrivateProfileInt
; Function compile flags: /Ogty
;	COMDAT ?DFNParser_GetPrivateProfileInt@@YAHPBD0H0@Z
_TEXT	SEGMENT
_cKey$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpAppName$ = 8						; size = 4
_lpKeyName$ = 12					; size = 4
_nDefault$ = 16						; size = 4
_lpFileName$ = 20					; size = 4
?DFNParser_GetPrivateProfileInt@@YAHPBD0H0@Z PROC NEAR	; DFNParser_GetPrivateProfileInt, COMDAT

; 253  : {

  00000	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	57		 push	 edi
  0000c	89 84 24 04 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+264], eax

; 254  : 	char cKey[255]={0};

  00013	33 c0		 xor	 eax, eax
  00015	c6 44 24 04 00	 mov	 BYTE PTR _cKey$[esp+264], 0
  0001a	b9 3f 00 00 00	 mov	 ecx, 63			; 0000003fH
  0001f	8d 7c 24 05	 lea	 edi, DWORD PTR _cKey$[esp+265]
  00023	f3 ab		 rep stosd

; 255  : 	sprintf(cKey,"%s_%s",lpAppName,lpKeyName);

  00025	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR _lpAppName$[esp+260]
  0002c	66 ab		 stosw
  0002e	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR _lpKeyName$[esp+260]
  00035	50		 push	 eax
  00036	51		 push	 ecx
  00037	8d 54 24 0c	 lea	 edx, DWORD PTR _cKey$[esp+272]
  0003b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05ONEOBAM@?$CFs_?$CFs?$AA@
  00040	52		 push	 edx
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf

; 256  : 
; 257  : 	return DFN_GetPrivateProfileInt(lpFileName,cKey,nDefault,"oscmd.ini" );

  00047	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR _nDefault$[esp+276]
  0004e	8b 94 24 28 01
	00 00		 mov	 edx, DWORD PTR _lpFileName$[esp+276]
  00055	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_09BMHOOPHN@oscmd?4ini?$AA@
  0005a	50		 push	 eax
  0005b	8d 4c 24 1c	 lea	 ecx, DWORD PTR _cKey$[esp+288]
  0005f	51		 push	 ecx
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ?DFN_GetPrivateProfileInt@@YAHPBD0H0@Z ; DFN_GetPrivateProfileInt

; 258  : 
; 259  : }

  00066	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+296]
  0006d	83 c4 20	 add	 esp, 32			; 00000020H
  00070	5f		 pop	 edi
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  0007c	c3		 ret	 0
?DFNParser_GetPrivateProfileInt@@YAHPBD0H0@Z ENDP	; DFNParser_GetPrivateProfileInt
_TEXT	ENDS
PUBLIC	??_C@_01NEMOKFLO@?$DN?$AA@			; `string'
PUBLIC	?GetValueFromList@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@AAVCStringList@@@Z ; GetValueFromList
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T67713	DD	0ffffffffH
	DD	FLAT:$L67669
	DD	00H
	DD	FLAT:$L67670
	DD	01H
	DD	FLAT:$L67671
	DD	02H
	DD	FLAT:$L67672
	DD	02H
	DD	FLAT:$L67673
$T67706	DD	019930520H
	DD	05H
	DD	FLAT:$T67713
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_01NEMOKFLO@?$DN?$AA@
CONST	SEGMENT
??_C@_01NEMOKFLO@?$DN?$AA@ DB '=', 00H			; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?GetValueFromList@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@AAVCStringList@@@Z
_TEXT	SEGMENT
_strValue$ = -20					; size = 4
$T67675 = -16						; size = 4
$T67668 = -16						; size = 4
$T67667 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_strName$ = 12						; size = 4
_strItem$ = 16						; size = 4
_strList$ = 16						; size = 4
?GetValueFromList@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@AAVCStringList@@@Z PROC NEAR ; GetValueFromList, COMDAT

; 394  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GetValueFromList@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@AAVCStringList@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR $T67675[esp+32], 0

; 395  : 	POSITION pos=NULL;
; 396  : 	pos=strList.GetHeadPosition();

  00023	8b 44 24 2c	 mov	 eax, DWORD PTR _strList$[esp+28]
  00027	8b 70 04	 mov	 esi, DWORD PTR [eax+4]

; 397  : 	int nIndex=0;
; 398  : 	CString strItem=_T("");

  0002a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0002f	8d 4c 24 30	 lea	 ecx, DWORD PTR _strItem$[esp+32]
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 0
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 399  : 	CString strValue=_T("");

  00041	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00046	8d 4c 24 10	 lea	 ecx, DWORD PTR _strValue$[esp+36]
  0004a	c6 44 24 20 01	 mov	 BYTE PTR __$EHRec$[esp+44], 1
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 400  : 	while(pos!=NULL)

  00055	85 f6		 test	 esi, esi
  00057	b3 02		 mov	 bl, 2
  00059	88 5c 24 1c	 mov	 BYTE PTR __$EHRec$[esp+40], bl
  0005d	74 73		 je	 SHORT $L60716
  0005f	90		 npad	 1
$L60715:

; 401  : 	{
; 402  : 		strItem=strList.GetNext(pos);

  00060	85 f6		 test	 esi, esi
  00062	8b c6		 mov	 eax, esi
  00064	0f 84 ab 00 00
	00		 je	 $L67708
  0006a	8b 36		 mov	 esi, DWORD PTR [esi]
  0006c	83 c0 08	 add	 eax, 8
  0006f	50		 push	 eax
  00070	8d 4c 24 30	 lea	 ecx, DWORD PTR _strItem$[esp+32]
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 403  : 		nIndex=strItem.Find("=");

  0007a	6a 00		 push	 0
  0007c	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01NEMOKFLO@?$DN?$AA@
  00081	8d 4c 24 34	 lea	 ecx, DWORD PTR _strItem$[esp+36]
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z
  0008b	8b f8		 mov	 edi, eax

; 404  : 		strValue=strItem.Left(nIndex);

  0008d	57		 push	 edi
  0008e	8d 4c 24 14	 lea	 ecx, DWORD PTR $T67667[esp+36]
  00092	51		 push	 ecx
  00093	8d 4c 24 34	 lea	 ecx, DWORD PTR _strItem$[esp+36]
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Left@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  0009d	50		 push	 eax
  0009e	8d 4c 24 10	 lea	 ecx, DWORD PTR _strValue$[esp+36]
  000a2	c6 44 24 20 03	 mov	 BYTE PTR __$EHRec$[esp+44], 3
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000ad	8d 4c 24 10	 lea	 ecx, DWORD PTR $T67667[esp+32]
  000b1	88 5c 24 1c	 mov	 BYTE PTR __$EHRec$[esp+40], bl
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 405  : 		if (strValue==strName)

  000bb	8b 54 24 28	 mov	 edx, DWORD PTR _strName$[esp+28]
  000bf	52		 push	 edx
  000c0	8d 4c 24 10	 lea	 ecx, DWORD PTR _strValue$[esp+36]
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  000ca	85 c0		 test	 eax, eax
  000cc	74 4c		 je	 SHORT $L67709

; 400  : 	while(pos!=NULL)

  000ce	85 f6		 test	 esi, esi
  000d0	75 8e		 jne	 SHORT $L60715
$L60716:

; 409  : 		}
; 410  : 	}
; 411  : 	return "";	

  000d2	8b 74 24 24	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+28]
  000d6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000db	8b ce		 mov	 ecx, esi
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z
$L67712:
  000e3	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strValue$[esp+32]
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000ed	8d 4c 24 2c	 lea	 ecx, DWORD PTR _strItem$[esp+28]
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f7	8d 4c 24 28	 lea	 ecx, DWORD PTR _strName$[esp+28]
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 412  : }

  00101	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  00105	5f		 pop	 edi
  00106	8b c6		 mov	 eax, esi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00111	83 c4 14	 add	 esp, 20			; 00000014H
  00114	c3		 ret	 0
$L67708:

; 401  : 	{
; 402  : 		strItem=strList.GetNext(pos);

  00115	e9 00 00 00 00	 jmp	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
$L67709:

; 406  : 		{
; 407  : 			strValue=strItem.Right(strItem.GetLength()-nIndex-1);

  0011a	8b 44 24 2c	 mov	 eax, DWORD PTR _strItem$[esp+28]
  0011e	8b 40 f4	 mov	 eax, DWORD PTR [eax-12]
  00121	2b c7		 sub	 eax, edi
  00123	48		 dec	 eax
  00124	50		 push	 eax
  00125	8d 4c 24 14	 lea	 ecx, DWORD PTR $T67668[esp+36]
  00129	51		 push	 ecx
  0012a	8d 4c 24 34	 lea	 ecx, DWORD PTR _strItem$[esp+36]
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Right@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBE?AV12@H@Z
  00134	50		 push	 eax
  00135	8d 4c 24 10	 lea	 ecx, DWORD PTR _strValue$[esp+36]
  00139	c6 44 24 20 04	 mov	 BYTE PTR __$EHRec$[esp+44], 4
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00144	8d 4c 24 10	 lea	 ecx, DWORD PTR $T67668[esp+32]
  00148	88 5c 24 1c	 mov	 BYTE PTR __$EHRec$[esp+40], bl
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 408  : 			return strValue;

  00152	8b 74 24 24	 mov	 esi, DWORD PTR ___$ReturnUdt$[esp+28]
  00156	8d 54 24 0c	 lea	 edx, DWORD PTR _strValue$[esp+32]
  0015a	52		 push	 edx
  0015b	8b ce		 mov	 ecx, esi
  0015d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z
  00163	e9 7b ff ff ff	 jmp	 $L67712
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67669:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _strName$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67670:
  00009	8d 4d 0c	 lea	 ecx, DWORD PTR _strItem$[ebp-4]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67671:
  00012	8d 4d ec	 lea	 ecx, DWORD PTR _strValue$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67672:
  0001b	8d 4d f0	 lea	 ecx, DWORD PTR $T67667[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67673:
  00024	8d 4d f0	 lea	 ecx, DWORD PTR $T67668[ebp]
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?GetValueFromList@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@AAVCStringList@@@Z:
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67706
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetValueFromList@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@V12@AAVCStringList@@@Z ENDP ; GetValueFromList
PUBLIC	??_C@_0BC@GIIBNEJI@?$CFs?2groups?2log?4ini?$AA@	; `string'
PUBLIC	??_C@_08EFEFJCIK@IsOpen?$CFd?$AA@		; `string'
PUBLIC	??_C@_06DKEIEPKC@IsOpen?$AA@			; `string'
PUBLIC	??_C@_05GCIPIGEI@Debug?$AA@			; `string'
PUBLIC	??_C@_0CE@FGJHIBPE@?$CFd?D?j?$CFd?T?B?$CFd?H?U?5LogType?$DN?$CFd?5?$CFd?3?$CFd?3?$CFd@ ; `string'
PUBLIC	??_C@_0BA@DONDPCJE@?$CFs?2logs?2log?4txt?$AA@	; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_0BK@GNDEBDFN@?$CFs?2monitormanager?2logs?2?$CFs?$AA@ ; `string'
PUBLIC	??_C@_02DPNLHKJD@a?$CL?$AA@			; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	?WriteLog@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H0@Z ; WriteLog
EXTRN	__imp__GetLocalTime@4:NEAR
EXTRN	__imp__fclose:NEAR
EXTRN	__imp__fopen:NEAR
EXTRN	__imp__fprintf:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlsimpstr.h
xdata$x	SEGMENT
$T67761	DD	0ffffffffH
	DD	FLAT:$L67721
	DD	00H
	DD	FLAT:$L67722
	DD	01H
	DD	FLAT:$L67723
	DD	02H
	DD	FLAT:$L67724
	DD	02H
	DD	FLAT:$L67725
	DD	04H
	DD	FLAT:$L67726
	DD	05H
	DD	FLAT:$L67727
	DD	06H
	DD	FLAT:$L67728
	DD	06H
	DD	FLAT:$L67729
$T67758	DD	019930520H
	DD	09H
	DD	FLAT:$T67761
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_C@_0BC@GIIBNEJI@?$CFs?2groups?2log?4ini?$AA@
CONST	SEGMENT
??_C@_0BC@GIIBNEJI@?$CFs?2groups?2log?4ini?$AA@ DB '%s\groups\log.ini', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08EFEFJCIK@IsOpen?$CFd?$AA@
CONST	SEGMENT
??_C@_08EFEFJCIK@IsOpen?$CFd?$AA@ DB 'IsOpen%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKEIEPKC@IsOpen?$AA@
CONST	SEGMENT
??_C@_06DKEIEPKC@IsOpen?$AA@ DB 'IsOpen', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GCIPIGEI@Debug?$AA@
CONST	SEGMENT
??_C@_05GCIPIGEI@Debug?$AA@ DB 'Debug', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGJHIBPE@?$CFd?D?j?$CFd?T?B?$CFd?H?U?5LogType?$DN?$CFd?5?$CFd?3?$CFd?3?$CFd@
CONST	SEGMENT
??_C@_0CE@FGJHIBPE@?$CFd?D?j?$CFd?T?B?$CFd?H?U?5LogType?$DN?$CFd?5?$CFd?3?$CFd?3?$CFd@ DB '%'
	DB	'd', 0c4H, 0eaH, '%d', 0d4H, 0c2H, '%d', 0c8H, 0d5H, ' LogType'
	DB	'=%d %d:%d:%d %s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DONDPCJE@?$CFs?2logs?2log?4txt?$AA@
CONST	SEGMENT
??_C@_0BA@DONDPCJE@?$CFs?2logs?2log?4txt?$AA@ DB '%s\logs\log.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GNDEBDFN@?$CFs?2monitormanager?2logs?2?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@GNDEBDFN@?$CFs?2monitormanager?2logs?2?$CFs?$AA@ DB '%s\monitor'
	DB	'manager\logs\%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPNLHKJD@a?$CL?$AA@
CONST	SEGMENT
??_C@_02DPNLHKJD@a?$CL?$AA@ DB 'a+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.cpp
CONST	ENDS
;	COMDAT ?WriteLog@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H0@Z
_TEXT	SEGMENT
_strKey$ = -48						; size = 4
_strRealFile$ = -44					; size = 4
_strLogIni$ = -40					; size = 4
_strOut$ = -36						; size = 4
$T67718 = -32						; size = 4
_st$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
_strLog$ = 8						; size = 4
$T67720 = 12						; size = 4
$T67719 = 12						; size = 4
_nLogType$ = 12						; size = 4
_strLogFile$ = 16					; size = 4
?WriteLog@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H0@Z PROC NEAR ; WriteLog, COMDAT

; 424  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?WriteLog@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H0@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 24	 sub	 esp, 36			; 00000024H
  00018	56		 push	 esi
  00019	57		 push	 edi

; 425  : 
; 426  : 	
; 427  : 	CString strLogIni = _T("");

  0001a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0001f	8d 4c 24 14	 lea	 ecx, DWORD PTR _strLogIni$[esp+60]
  00023	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+68], 1
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 428  : #if 1
; 429  : 	strLogIni.Format("%s\\groups\\log.ini", FuncGetInstallPath());

  00031	8d 44 24 18	 lea	 eax, DWORD PTR $T67718[esp+56]
  00035	50		 push	 eax
  00036	c6 44 24 38 02	 mov	 BYTE PTR __$EHRec$[esp+68], 2
  0003b	e8 00 00 00 00	 call	 ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	51		 push	 ecx
  00043	8d 54 24 18	 lea	 edx, DWORD PTR _strLogIni$[esp+64]
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BC@GIIBNEJI@?$CFs?2groups?2log?4ini?$AA@
  0004c	52		 push	 edx
  0004d	c6 44 24 44 03	 mov	 BYTE PTR __$EHRec$[esp+80], 3
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00058	83 c4 10	 add	 esp, 16			; 00000010H
  0005b	8d 4c 24 18	 lea	 ecx, DWORD PTR $T67718[esp+56]
  0005f	c6 44 24 34 02	 mov	 BYTE PTR __$EHRec$[esp+64], 2
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 430  : #else
; 431  : 	strLogIni.Format("%s\\monitormanager\\groups\\log.ini", FuncGetInstallPath());
; 432  : #endif
; 433  : 	CString strKey = _T("");

  0006a	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0006f	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strKey$[esp+60]
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 434  : 	if (nLogType != 0)

  00079	8b 7c 24 40	 mov	 edi, DWORD PTR _nLogType$[esp+52]
  0007d	85 ff		 test	 edi, edi
  0007f	c6 44 24 34 04	 mov	 BYTE PTR __$EHRec$[esp+64], 4
  00084	74 16		 je	 SHORT $L60745

; 435  : 	{
; 436  : 		strKey.Format("IsOpen%d", nLogType);

  00086	57		 push	 edi
  00087	8d 44 24 0c	 lea	 eax, DWORD PTR _strKey$[esp+60]
  0008b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_08EFEFJCIK@IsOpen?$CFd?$AA@
  00090	50		 push	 eax
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00097	83 c4 0c	 add	 esp, 12			; 0000000cH

; 437  : 	}
; 438  : 	else

  0009a	eb 13		 jmp	 SHORT $L60747
$L60745:

; 439  : 	{
; 440  : 		strKey.Format("IsOpen");

  0009c	8d 4c 24 08	 lea	 ecx, DWORD PTR _strKey$[esp+56]
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_06DKEIEPKC@IsOpen?$AA@
  000a5	51		 push	 ecx
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  000ac	83 c4 08	 add	 esp, 8
$L60747:

; 441  : 	}
; 442  : 	int nDebug = GetPrivateProfileInt("Debug", strKey.GetBuffer(strKey.GetLength()), 
; 443  : 									  0, strLogIni.GetBuffer(strLogIni.GetLength()));

  000af	8b 54 24 10	 mov	 edx, DWORD PTR _strLogIni$[esp+56]
  000b3	8b 4c 24 08	 mov	 ecx, DWORD PTR _strKey$[esp+56]
  000b7	8b 42 f4	 mov	 eax, DWORD PTR [edx-12]
  000ba	8b 71 f4	 mov	 esi, DWORD PTR [ecx-12]
  000bd	50		 push	 eax
  000be	8d 4c 24 14	 lea	 ecx, DWORD PTR _strLogIni$[esp+60]
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  000c8	50		 push	 eax
  000c9	6a 00		 push	 0
  000cb	56		 push	 esi
  000cc	8d 4c 24 14	 lea	 ecx, DWORD PTR _strKey$[esp+68]
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?GetBuffer@?$CSimpleStringT@D$00@ATL@@QAEPADH@Z
  000d6	50		 push	 eax
  000d7	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05GCIPIGEI@Debug?$AA@
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileIntA@16

; 444  : 	//nDebug=1;
; 445  : 	if (nDebug == 0)

  000e2	85 c0		 test	 eax, eax

; 446  : 	{
; 447  : 		return;

  000e4	0f 84 5c 01 00
	00		 je	 $L67760

; 448  : 	}
; 449  : 	SYSTEMTIME st;
; 450  : 	GetLocalTime(&st);

  000ea	8d 54 24 1c	 lea	 edx, DWORD PTR _st$[esp+56]
  000ee	52		 push	 edx
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocalTime@4

; 451  : 	CString strOut = _T("");

  000f5	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000fa	8d 4c 24 18	 lea	 ecx, DWORD PTR _strOut$[esp+60]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 452  : 	strOut.Format("%d%d%d LogType=%d %d:%d:%d %s", st.wYear, st.wMonth, st.wDay, nLogType, st.wHour, st.wMinute, st.wSecond, strLog);

  00104	8b 44 24 3c	 mov	 eax, DWORD PTR _strLog$[esp+52]
  00108	0f b7 4c 24 28	 movzx	 ecx, WORD PTR _st$[esp+68]
  0010d	0f b7 54 24 26	 movzx	 edx, WORD PTR _st$[esp+66]
  00112	50		 push	 eax
  00113	0f b7 44 24 28	 movzx	 eax, WORD PTR _st$[esp+68]
  00118	51		 push	 ecx
  00119	0f b7 4c 24 2a	 movzx	 ecx, WORD PTR _st$[esp+70]
  0011e	52		 push	 edx
  0011f	0f b7 54 24 2a	 movzx	 edx, WORD PTR _st$[esp+70]
  00124	50		 push	 eax
  00125	0f b7 44 24 2c	 movzx	 eax, WORD PTR _st$[esp+72]
  0012a	57		 push	 edi
  0012b	51		 push	 ecx
  0012c	52		 push	 edx
  0012d	50		 push	 eax
  0012e	8d 4c 24 34	 lea	 ecx, DWORD PTR _strOut$[esp+88]
  00132	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CE@FGJHIBPE@?$CFd?D?j?$CFd?T?B?$CFd?H?U?5LogType?$DN?$CFd?5?$CFd?3?$CFd?3?$CFd@
  00137	51		 push	 ecx
  00138	c6 44 24 5c 05	 mov	 BYTE PTR __$EHRec$[esp+104], 5
  0013d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  00143	83 c4 28	 add	 esp, 40			; 00000028H

; 453  : 	FILE *f = NULL;
; 454  : 	CString strRealFile = _T("");

  00146	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0014b	8d 4c 24 10	 lea	 ecx, DWORD PTR _strRealFile$[esp+60]
  0014f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@PBD@Z

; 455  : 	if (strLogFile == _T(""))

  00155	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0015a	8d 4c 24 48	 lea	 ecx, DWORD PTR _strLogFile$[esp+56]
  0015e	c6 44 24 38 06	 mov	 BYTE PTR __$EHRec$[esp+68], 6
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z
  00169	85 c0		 test	 eax, eax
  0016b	75 31		 jne	 SHORT $L60757

; 456  : 	{
; 457  : 		strRealFile.Format("%s\\logs\\log.txt", FuncGetInstallPath());

  0016d	8d 54 24 40	 lea	 edx, DWORD PTR $T67719[esp+52]
  00171	52		 push	 edx
  00172	e8 00 00 00 00	 call	 ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
  00177	8b 00		 mov	 eax, DWORD PTR [eax]
  00179	50		 push	 eax
  0017a	8d 4c 24 14	 lea	 ecx, DWORD PTR _strRealFile$[esp+64]
  0017e	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BA@DONDPCJE@?$CFs?2logs?2log?4txt?$AA@
  00183	51		 push	 ecx
  00184	c6 44 24 44 07	 mov	 BYTE PTR __$EHRec$[esp+80], 7
  00189	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  0018f	83 c4 10	 add	 esp, 16			; 00000010H
  00192	8d 4c 24 40	 lea	 ecx, DWORD PTR $T67719[esp+52]
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 458  : 	}
; 459  : 	else

  0019c	eb 5b		 jmp	 SHORT $L60765
$L60757:

; 460  : 	{
; 461  : 		if (strLogFile.Find(":") == -1)

  0019e	6a 00		 push	 0
  001a0	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  001a5	8d 4c 24 4c	 lea	 ecx, DWORD PTR _strLogFile$[esp+60]
  001a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Find@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBDH@Z
  001af	83 f8 ff	 cmp	 eax, -1
  001b2	75 36		 jne	 SHORT $L60761

; 462  : 		{
; 463  : #if _DEBUG			
; 464  : 			strRealFile.Format("%s\\logs\\%s", FuncGetInstallPath(), strLogFile);
; 465  : #else
; 466  : 			strRealFile.Format("%s\\monitormanager\\logs\\%s", FuncGetInstallPath(), strLogFile);

  001b4	8d 54 24 40	 lea	 edx, DWORD PTR $T67720[esp+52]
  001b8	52		 push	 edx
  001b9	e8 00 00 00 00	 call	 ?FuncGetInstallPath@@YA?AV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@XZ ; FuncGetInstallPath
  001be	8b 4c 24 48	 mov	 ecx, DWORD PTR _strLogFile$[esp+56]
  001c2	8b 10		 mov	 edx, DWORD PTR [eax]
  001c4	51		 push	 ecx
  001c5	52		 push	 edx
  001c6	8d 44 24 18	 lea	 eax, DWORD PTR _strRealFile$[esp+68]
  001ca	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0BK@GNDEBDFN@?$CFs?2monitormanager?2logs?2?$CFs?$AA@
  001cf	50		 push	 eax
  001d0	c6 44 24 48 08	 mov	 BYTE PTR __$EHRec$[esp+84], 8
  001d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Format@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAAXPBDZZ
  001db	83 c4 14	 add	 esp, 20			; 00000014H
  001de	8d 4c 24 40	 lea	 ecx, DWORD PTR $T67720[esp+52]
  001e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 467  : #endif
; 468  : 		}
; 469  : 		else

  001e8	eb 0f		 jmp	 SHORT $L60765
$L60761:

; 470  : 		{
; 471  : 			strRealFile = strLogFile;

  001ea	8d 4c 24 44	 lea	 ecx, DWORD PTR _strLogFile$[esp+52]
  001ee	51		 push	 ecx
  001ef	8d 4c 24 10	 lea	 ecx, DWORD PTR _strRealFile$[esp+60]
  001f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$L60765:

; 472  : 		}
; 473  : 	}
; 474  : 	f = fopen(strRealFile, "a+");

  001f9	8b 54 24 0c	 mov	 edx, DWORD PTR _strRealFile$[esp+56]
  001fd	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02DPNLHKJD@a?$CL?$AA@
  00202	52		 push	 edx
  00203	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00209	8b f0		 mov	 esi, eax
  0020b	83 c4 08	 add	 esp, 8

; 475  :     if (f!=NULL)

  0020e	85 f6		 test	 esi, esi
  00210	74 20		 je	 SHORT $L60767

; 476  :     {
; 477  :         fprintf(f, strOut);

  00212	8b 44 24 14	 mov	 eax, DWORD PTR _strOut$[esp+56]
  00216	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__fprintf
  0021c	50		 push	 eax
  0021d	56		 push	 esi
  0021e	ff d7		 call	 edi

; 478  : 	    fprintf(f, "\r\n");

  00220	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6?$AA@
  00225	56		 push	 esi
  00226	ff d7		 call	 edi

; 479  :         fclose(f);

  00228	56		 push	 esi
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  0022f	83 c4 14	 add	 esp, 20			; 00000014H
$L60767:

; 480  :     }
; 481  : 	
; 482  : }

  00232	8d 4c 24 0c	 lea	 ecx, DWORD PTR _strRealFile$[esp+56]
  00236	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0023c	8d 4c 24 14	 lea	 ecx, DWORD PTR _strOut$[esp+56]
  00240	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67760:
  00246	8d 4c 24 08	 lea	 ecx, DWORD PTR _strKey$[esp+56]
  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00250	8d 4c 24 10	 lea	 ecx, DWORD PTR _strLogIni$[esp+56]
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0025a	8d 4c 24 3c	 lea	 ecx, DWORD PTR _strLog$[esp+52]
  0025e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00264	8d 4c 24 44	 lea	 ecx, DWORD PTR _strLogFile$[esp+52]
  00268	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0026e	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$EHRec$[esp+56]
  00272	5f		 pop	 edi
  00273	5e		 pop	 esi
  00274	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0027b	83 c4 30	 add	 esp, 48			; 00000030H
  0027e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67721:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _strLogFile$[ebp-4]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67722:
  00009	8d 4d 04	 lea	 ecx, DWORD PTR _strLog$[ebp-4]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67723:
  00012	8d 4d d8	 lea	 ecx, DWORD PTR _strLogIni$[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67724:
  0001b	8d 4d e0	 lea	 ecx, DWORD PTR $T67718[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67725:
  00024	8d 4d d0	 lea	 ecx, DWORD PTR _strKey$[ebp]
  00027	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67726:
  0002d	8d 4d dc	 lea	 ecx, DWORD PTR _strOut$[ebp]
  00030	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67727:
  00036	8d 4d d4	 lea	 ecx, DWORD PTR _strRealFile$[ebp]
  00039	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67728:
  0003f	8d 4d 08	 lea	 ecx, DWORD PTR $T67719[ebp-4]
  00042	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L67729:
  00048	8d 4d 08	 lea	 ecx, DWORD PTR $T67720[ebp-4]
  0004b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?WriteLog@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H0@Z:
  00051	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67758
  00056	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?WriteLog@@YAXV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@H0@Z ENDP ; WriteLog
PUBLIC	??_E_rec@@QAEPAXI@Z				; _rec::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
; Function compile flags: /Ogty
;	COMDAT ??_E_rec@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_E_rec@@QAEPAXI@Z PROC NEAR				; _rec::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	53		 push	 ebx
  00001	8a 5c 24 08	 mov	 bl, BYTE PTR ___flags$[esp]
  00005	f6 c3 02	 test	 bl, 2
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	74 2b		 je	 SHORT $L60832
  0000d	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00010	57		 push	 edi
  00011	68 00 00 00 00	 push	 OFFSET FLAT:??1_rec@@QAE@XZ
  00016	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  00019	50		 push	 eax
  0001a	6a 08		 push	 8
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  00022	f6 c3 01	 test	 bl, 1
  00025	74 09		 je	 SHORT $L60833
  00027	57		 push	 edi
  00028	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0002d	83 c4 04	 add	 esp, 4
$L60833:
  00030	8b c7		 mov	 eax, edi
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	c2 04 00	 ret	 4
$L60832:
  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 ??1_rec@@QAE@XZ
  0003f	f6 c3 01	 test	 bl, 1
  00042	74 09		 je	 SHORT $L60835
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004a	83 c4 04	 add	 esp, 4
$L60835:
  0004d	8b c6		 mov	 eax, esi
  0004f	5e		 pop	 esi
  00050	5b		 pop	 ebx
  00051	c2 04 00	 ret	 4
??_E_rec@@QAEPAXI@Z ENDP				; _rec::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?_Sort@@YAXPAU_rec@@HH@Z			; _Sort
;	COMDAT xdata$x
xdata$x	SEGMENT
$T67820	DD	0ffffffffH
	DD	FLAT:$L67768
$T67810	DD	019930520H
	DD	01H
	DD	FLAT:$T67820
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ?_Sort@@YAXPAU_rec@@HH@Z
_TEXT	SEGMENT
_j$ = -40						; size = 4
tv615 = -36						; size = 4
tv251 = -36						; size = 4
tv585 = -32						; size = 4
tv373 = -32						; size = 4
tv565 = -28						; size = 4
tv397 = -28						; size = 4
_w$ = -24						; size = 8
__$EHRec$ = -12						; size = 12
_r$ = 8							; size = 4
_n$ = 12						; size = 4
_bAsc$ = 16						; size = 4
?_Sort@@YAXPAU_rec@@HH@Z PROC NEAR			; _Sort, COMDAT

; 565  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?_Sort@@YAXPAU_rec@@HH@Z
  0000d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00013	50		 push	 eax
  00014	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001b	83 ec 20	 sub	 esp, 32			; 00000020H
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi

; 566  : 	int i,j;
; 567  : 	struct _rec w;

  00021	8d 4c 24 20	 lea	 ecx, DWORD PTR _w$[esp+56]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  0002b	8d 4c 24 24	 lea	 ecx, DWORD PTR _w$[esp+60]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ

; 568  : 	int compare=0,move=0;
; 569  : 	
; 570  : 	//
; 571  : 	if(bAsc)

  00035	8b 45 10	 mov	 eax, DWORD PTR _bAsc$[ebp]
  00038	85 c0		 test	 eax, eax

; 572  : 	{
; 573  : 		for(i=0;i<=n;i++)

  0003a	8b 55 0c	 mov	 edx, DWORD PTR _n$[ebp]
  0003d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+64], 0
  00045	0f 84 bf 00 00
	00		 je	 $L60850
  0004b	85 d2		 test	 edx, edx
  0004d	0f 8c 72 01 00
	00		 jl	 $L60862
  00053	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00056	b9 01 00 00 00	 mov	 ecx, 1
  0005b	42		 inc	 edx
  0005c	89 44 24 10	 mov	 DWORD PTR _j$[esp+56], eax
  00060	89 4c 24 18	 mov	 DWORD PTR tv373[esp+56], ecx
  00064	89 54 24 1c	 mov	 DWORD PTR tv397[esp+56], edx
$L60851:

; 574  : 		{
; 575  : 			for(j=n-1;j>=i+1;j--)

  00068	3b c1		 cmp	 eax, ecx
  0006a	0f 8c 81 00 00
	00		 jl	 $L60856
  00070	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00073	8d 74 c2 04	 lea	 esi, DWORD PTR [edx+eax*8+4]
  00077	2b c1		 sub	 eax, ecx
  00079	40		 inc	 eax
  0007a	89 44 24 14	 mov	 DWORD PTR tv251[esp+56], eax
  0007e	8b ff		 npad	 2
$L60854:

; 576  : 			{  
; 577  : 				int n = (r[j].key).Compare(r[j-1].key);

  00080	8b 46 f4	 mov	 eax, DWORD PTR [esi-12]
  00083	8d 7e f4	 lea	 edi, DWORD PTR [esi-12]
  00086	8d 5e fc	 lea	 ebx, DWORD PTR [esi-4]
  00089	50		 push	 eax
  0008a	8b cb		 mov	 ecx, ebx
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z

; 578  : 				if(n<0)

  00092	85 c0		 test	 eax, eax
  00094	7d 45		 jge	 SHORT $L60855

; 579  : 				{
; 580  : 					w=r[j];

  00096	53		 push	 ebx
  00097	8d 4c 24 24	 lea	 ecx, DWORD PTR _w$[esp+60]
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000a1	56		 push	 esi
  000a2	8d 4c 24 28	 lea	 ecx, DWORD PTR _w$[esp+64]
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 581  : 					r[j]=r[j-1];

  000ac	57		 push	 edi
  000ad	8b cb		 mov	 ecx, ebx
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000b5	8d 5e f8	 lea	 ebx, DWORD PTR [esi-8]
  000b8	53		 push	 ebx
  000b9	8b ce		 mov	 ecx, esi
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 582  : 					r[j-1]=w;

  000c1	8d 44 24 20	 lea	 eax, DWORD PTR _w$[esp+56]
  000c5	50		 push	 eax
  000c6	8b cf		 mov	 ecx, edi
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  000ce	8d 4c 24 24	 lea	 ecx, DWORD PTR _w$[esp+60]
  000d2	51		 push	 ecx
  000d3	8b cb		 mov	 ecx, ebx
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$L60855:
  000db	8b 44 24 14	 mov	 eax, DWORD PTR tv251[esp+56]
  000df	83 ee 08	 sub	 esi, 8
  000e2	48		 dec	 eax
  000e3	89 44 24 14	 mov	 DWORD PTR tv251[esp+56], eax
  000e7	75 97		 jne	 SHORT $L60854
  000e9	8b 4c 24 18	 mov	 ecx, DWORD PTR tv373[esp+56]
  000ed	8b 44 24 10	 mov	 eax, DWORD PTR _j$[esp+56]
$L60856:
  000f1	8b 54 24 1c	 mov	 edx, DWORD PTR tv397[esp+56]
  000f5	41		 inc	 ecx
  000f6	4a		 dec	 edx
  000f7	89 4c 24 18	 mov	 DWORD PTR tv373[esp+56], ecx
  000fb	89 54 24 1c	 mov	 DWORD PTR tv397[esp+56], edx
  000ff	0f 85 63 ff ff
	ff		 jne	 $L60851

; 583  : 					move=move+3;
; 584  : 				}
; 585  : 
; 586  : 			}
; 587  : 			compare++;
; 588  : 		  }
; 589  : 	}
; 590  : 	//
; 591  : 	else

  00105	e9 bb 00 00 00	 jmp	 $L60862
$L60850:

; 592  : 	{
; 593  : 		for(i=0;i<=n;i++)

  0010a	85 d2		 test	 edx, edx
  0010c	0f 8c b3 00 00
	00		 jl	 $L60862
  00112	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  00115	b9 01 00 00 00	 mov	 ecx, 1
  0011a	42		 inc	 edx
  0011b	89 44 24 10	 mov	 DWORD PTR _j$[esp+56], eax
  0011f	89 4c 24 18	 mov	 DWORD PTR tv585[esp+56], ecx
  00123	89 54 24 14	 mov	 DWORD PTR tv615[esp+56], edx
$L60860:

; 594  : 		{
; 595  : 			for(j=n-1;j>=i+1;j--)

  00127	3b c1		 cmp	 eax, ecx
  00129	0f 8c 82 00 00
	00		 jl	 $L60865
  0012f	8b 55 08	 mov	 edx, DWORD PTR _r$[ebp]
  00132	8d 74 c2 04	 lea	 esi, DWORD PTR [edx+eax*8+4]
  00136	2b c1		 sub	 eax, ecx
  00138	40		 inc	 eax
  00139	89 44 24 1c	 mov	 DWORD PTR tv565[esp+56], eax
  0013d	8d 49 00	 npad	 3
$L60863:

; 596  : 			{  
; 597  : 				int n = (r[j].key).Compare(r[j-1].key);

  00140	8b 46 f4	 mov	 eax, DWORD PTR [esi-12]
  00143	8d 7e f4	 lea	 edi, DWORD PTR [esi-12]
  00146	8d 5e fc	 lea	 ebx, DWORD PTR [esi-4]
  00149	50		 push	 eax
  0014a	8b cb		 mov	 ecx, ebx
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?Compare@?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QBEHPBD@Z

; 598  : 				if(n>0)

  00152	85 c0		 test	 eax, eax
  00154	7e 45		 jle	 SHORT $L60864

; 599  : 				{
; 600  : 					w=r[j];

  00156	53		 push	 ebx
  00157	8d 4c 24 24	 lea	 ecx, DWORD PTR _w$[esp+60]
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00161	56		 push	 esi
  00162	8d 4c 24 28	 lea	 ecx, DWORD PTR _w$[esp+64]
  00166	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 601  : 					r[j]=r[j-1];

  0016c	57		 push	 edi
  0016d	8b cb		 mov	 ecx, ebx
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  00175	8d 5e f8	 lea	 ebx, DWORD PTR [esi-8]
  00178	53		 push	 ebx
  00179	8b ce		 mov	 ecx, esi
  0017b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 602  : 					r[j-1]=w;

  00181	8d 44 24 20	 lea	 eax, DWORD PTR _w$[esp+56]
  00185	50		 push	 eax
  00186	8b cf		 mov	 ecx, edi
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
  0018e	8d 4c 24 24	 lea	 ecx, DWORD PTR _w$[esp+60]
  00192	51		 push	 ecx
  00193	8b cb		 mov	 ecx, ebx
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z
$L60864:
  0019b	8b 44 24 1c	 mov	 eax, DWORD PTR tv565[esp+56]
  0019f	83 ee 08	 sub	 esi, 8
  001a2	48		 dec	 eax
  001a3	89 44 24 1c	 mov	 DWORD PTR tv565[esp+56], eax
  001a7	75 97		 jne	 SHORT $L60863
  001a9	8b 44 24 10	 mov	 eax, DWORD PTR _j$[esp+56]
  001ad	8b 4c 24 18	 mov	 ecx, DWORD PTR tv585[esp+56]
$L60865:
  001b1	8b 54 24 14	 mov	 edx, DWORD PTR tv615[esp+56]
  001b5	41		 inc	 ecx
  001b6	4a		 dec	 edx
  001b7	89 4c 24 18	 mov	 DWORD PTR tv585[esp+56], ecx
  001bb	89 54 24 14	 mov	 DWORD PTR tv615[esp+56], edx
  001bf	0f 85 62 ff ff
	ff		 jne	 $L60860
$L60862:

; 603  : 					move=move+3;
; 604  : 				}
; 605  : 
; 606  : 			}
; 607  : 			compare++;
; 608  : 		  }
; 609  : 	}
; 610  : 
; 611  : }

  001c5	8d 4c 24 24	 lea	 ecx, DWORD PTR _w$[esp+60]
  001c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001cf	8d 4c 24 20	 lea	 ecx, DWORD PTR _w$[esp+56]
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  001d9	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$EHRec$[esp+56]
  001dd	5f		 pop	 edi
  001de	5e		 pop	 esi
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001e6	5b		 pop	 ebx
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67768:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _w$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_rec@@QAE@XZ
__ehhandler$?_Sort@@YAXPAU_rec@@HH@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67810
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?_Sort@@YAXPAU_rec@@HH@Z ENDP				; _Sort
PUBLIC	?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z
_TEXT	SEGMENT
_nRequestedSize$ = 8					; size = 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z PROC NEAR ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 376  : 		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(nRequestedSize + sizeof(CAtlSafeAllocBufferNode));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nRequestedSize$[esp-4]
  00004	56		 push	 esi
  00005	83 c0 08	 add	 eax, 8
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00011	83 c4 04	 add	 esp, 4

; 377  : 		if (p == NULL)

  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $L60959
  00018	5e		 pop	 esi

; 385  : 	}

  00019	c2 04 00	 ret	 4
$L60959:

; 378  : 			return NULL;
; 379  : 		
; 380  : 		// Add buffer to the list
; 381  : 		p->m_pNext = m_pHead;

  0001c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx

; 382  : 		m_pHead = p;

  00020	89 06		 mov	 DWORD PTR [esi], eax

; 383  : 		
; 384  : 		return p->GetData();

  00022	83 c0 08	 add	 eax, 8
  00025	5e		 pop	 esi

; 385  : 	}

  00026	c2 04 00	 ret	 4
?Allocate@?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAEPAXK@Z ENDP ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
; Function compile flags: /Ogty
;	COMDAT ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 226  : 		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00005	3b d0		 cmp	 edx, eax
  00007	74 05		 je	 SHORT $L60971

; 227  : 		{
; 228  : 			FreeHeap();

  00009	e9 00 00 00 00	 jmp	 ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L60971:

; 229  : 		}
; 230  : 	}

  0000e	c3		 ret	 0
??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
_TEXT	ENDS
PUBLIC	??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z		; ATL::CW2AEX<128>::CW2AEX<128>
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlconv.h
;	COMDAT ??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z PROC NEAR		; ATL::CW2AEX<128>::CW2AEX<128>, COMDAT
; _this$ = ecx

; 419  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00006	89 06		 mov	 DWORD PTR [esi], eax

; 420  : 		Init( psz, _AtlGetConversionACP() );

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  0000e	8b 4c 24 08	 mov	 ecx, DWORD PTR _psz$[esp]
  00012	50		 push	 eax
  00013	51		 push	 ecx
  00014	8b ce		 mov	 ecx, esi
  00016	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init

; 421  : 	}

  0001b	8b c6		 mov	 eax, esi
  0001d	5e		 pop	 esi
  0001e	c2 04 00	 ret	 4
??0?$CW2AEX@$0IA@@ATL@@QAE@PB_W@Z ENDP			; ATL::CW2AEX<128>::CW2AEX<128>
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T67864	DD	0ffffffffH
	DD	FLAT:$L67839
$T67862	DD	019930520H
	DD	01H
	DD	FLAT:$T67864
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	8b 44 24 14	 mov	 eax, DWORD PTR __Istr$[esp+12]
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00024	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00028	85 c0		 test	 eax, eax
  0002a	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0002e	74 09		 je	 SHORT $L67858
  00030	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@_Mutex@std@@QAEXXZ
$L67858:

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00039	8b 44 24 1c	 mov	 eax, DWORD PTR __Noskip$[esp+16]
  0003d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003f	50		 push	 eax
  00040	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z

; 74   : 			}

  0004e	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00052	88 46 04	 mov	 BYTE PTR [esi+4], al
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67839:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67862
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
EXTRN	__imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T67894	DD	0ffffffffH
	DD	FLAT:$L67869
$T67892	DD	019930520H
	DD	01H
	DD	FLAT:$T67894
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\istream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z PROC NEAR ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 72   : 			{	// construct locking and calling _Ipfx

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	8b 44 24 14	 mov	 eax, DWORD PTR __Istr$[esp+12]
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00021	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00024	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00028	85 c0		 test	 eax, eax
  0002a	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0002e	74 09		 je	 SHORT $L67888
  00030	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@_Mutex@std@@QAEXXZ
$L67888:

; 73   : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00039	8b 44 24 1c	 mov	 eax, DWORD PTR __Noskip$[esp+16]
  0003d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003f	50		 push	 eax
  00040	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z

; 74   : 			}

  0004e	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00052	88 46 04	 mov	 BYTE PTR [esi+4], al
  00055	8b c6		 mov	 eax, esi
  00057	5e		 pop	 esi
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005f	83 c4 10	 add	 esp, 16			; 00000010H
  00062	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67869:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67892
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 277  : 		ATLASSERT( m_p == NULL );
; 278  : 		if( nBytes > t_nFixedBytes )

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nBytes$[esp-4]
  00004	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	76 0c		 jbe	 SHORT $L62364

; 279  : 		{
; 280  : 			AllocateHeap( nBytes );

  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap

; 285  : 		}
; 286  : 
; 287  : 		return( m_p );

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	5e		 pop	 esi

; 288  : 	}

  00017	c2 04 00	 ret	 4
$L62364:

; 281  : 		}
; 282  : 		else
; 283  : 		{
; 284  : 			m_p = reinterpret_cast< T* >( m_abFixedBuffer );

  0001a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	5e		 pop	 esi

; 288  : 	}

  00020	c2 04 00	 ret	 4
?AllocateBytes@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\xiosbase
xdata$x	SEGMENT
$T67953	DD	0ffffffffH
	DD	FLAT:$L67902
$T67951	DD	019930520H
	DD	01H
	DD	FLAT:$T67953
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b 74 24 18	 mov	 esi, DWORD PTR __Ostr$[esp+16]
  0001b	57		 push	 edi
  0001c	8b f9		 mov	 edi, ecx
  0001e	89 37		 mov	 DWORD PTR [edi], esi
  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00025	8b 44 31 28	 mov	 eax, DWORD PTR [ecx+esi+40]
  00029	85 c0		 test	 eax, eax
  0002b	89 7c 24 08	 mov	 DWORD PTR _this$[esp+24], edi
  0002f	74 09		 je	 SHORT $L67923
  00031	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@_Mutex@std@@QAEXXZ
$L67923:

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0003a	8b 16		 mov	 edx, DWORD PTR [esi]
  0003c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003f	8b 4c 30 08	 mov	 ecx, DWORD PTR [eax+esi+8]
  00043	03 c6		 add	 eax, esi
  00045	85 c9		 test	 ecx, ecx
  00047	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  0004f	75 0f		 jne	 SHORT $L63270
  00051	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00054	85 c0		 test	 eax, eax
  00056	74 08		 je	 SHORT $L63270

; 90   : 				_Ostr.tie()->flush();

  00058	8b c8		 mov	 ecx, eax
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$L63270:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00060	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00062	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00065	8b 44 32 08	 mov	 eax, DWORD PTR [edx+esi+8]

; 92   : 			}

  00069	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0006d	85 c0		 test	 eax, eax
  0006f	0f 94 c0	 sete	 al
  00072	88 47 04	 mov	 BYTE PTR [edi+4], al
  00075	8b c7		 mov	 eax, edi
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00080	83 c4 10	 add	 esp, 16			; 00000010H
  00083	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67902:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67951
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:NEAR
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T67983	DD	0ffffffffH
	DD	FLAT:$L67958
$T67981	DD	019930520H
	DD	01H
	DD	FLAT:$T67983
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+28], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  0002b	84 c0		 test	 al, al
  0002d	75 08		 jne	 SHORT $L63273

; 99   : 				this->_Myostr._Osfx();

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$L63273:

; 100  : 			}

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003e	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00042	85 c0		 test	 eax, eax
  00044	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+28], -1
  0004c	5e		 pop	 esi
  0004d	74 09		 je	 SHORT $L67978
  0004f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L67978:
  00058	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00063	83 c4 10	 add	 esp, 16			; 00000010H
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67958:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T67981
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
EXTRN	__imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\xiosbase
xdata$x	SEGMENT
$T68039	DD	0ffffffffH
	DD	FLAT:$L67988
$T68037	DD	019930520H
	DD	01H
	DD	FLAT:$T68039
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 88   : 			{	// construct locking and testing stream

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b 74 24 18	 mov	 esi, DWORD PTR __Ostr$[esp+16]
  0001b	57		 push	 edi
  0001c	8b f9		 mov	 edi, ecx
  0001e	89 37		 mov	 DWORD PTR [edi], esi
  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00025	8b 44 31 28	 mov	 eax, DWORD PTR [ecx+esi+40]
  00029	85 c0		 test	 eax, eax
  0002b	89 7c 24 08	 mov	 DWORD PTR _this$[esp+24], edi
  0002f	74 09		 je	 SHORT $L68009
  00031	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Lock@_Mutex@std@@QAEXXZ
$L68009:

; 89   : 			if (_Ostr.good() && _Ostr.tie() != 0)

  0003a	8b 16		 mov	 edx, DWORD PTR [esi]
  0003c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003f	8b 4c 30 08	 mov	 ecx, DWORD PTR [eax+esi+8]
  00043	03 c6		 add	 eax, esi
  00045	85 c9		 test	 ecx, ecx
  00047	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  0004f	75 0f		 jne	 SHORT $L63278
  00051	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00054	85 c0		 test	 eax, eax
  00056	74 08		 je	 SHORT $L63278

; 90   : 				_Ostr.tie()->flush();

  00058	8b c8		 mov	 ecx, eax
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
$L63278:

; 91   : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00060	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00062	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00065	8b 44 32 08	 mov	 eax, DWORD PTR [edx+esi+8]

; 92   : 			}

  00069	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  0006d	85 c0		 test	 eax, eax
  0006f	0f 94 c0	 sete	 al
  00072	88 47 04	 mov	 BYTE PTR [edi+4], al
  00075	8b c7		 mov	 eax, edi
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00080	83 c4 10	 add	 esp, 16			; 00000010H
  00083	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L67988:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68037
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
EXTRN	__imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T68069	DD	0ffffffffH
	DD	FLAT:$L68044
$T68067	DD	019930520H
	DD	01H
	DD	FLAT:$T68069
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\ostream
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC NEAR ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// destroy the object

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+28], 0

; 96   : 
; 97   :  #if _HAS_EXCEPTIONS
; 98   : 			if (!uncaught_exception())

  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  0002b	84 c0		 test	 al, al
  0002d	75 08		 jne	 SHORT $L63281

; 99   : 				this->_Myostr._Osfx();

  0002f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L63281:

; 100  : 			}

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003e	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00042	85 c0		 test	 eax, eax
  00044	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+28], -1
  0004c	5e		 pop	 esi
  0004d	74 09		 je	 SHORT $L68064
  0004f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L68064:
  00058	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00063	83 c4 10	 add	 esp, 16			; 00000010H
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68044:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68067
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
EXTRN	__imp_??1locale@std@@QAE@XZ:NEAR
EXTRN	__imp_?clear@ios_base@std@@QAEXH_N@Z:NEAR
EXTRN	__imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB:DWORD
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:NEAR
EXTRN	__imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z:NEAR
EXTRN	__imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T68256	DD	0ffffffffH
	DD	FLAT:$L68081
	DD	00H
	DD	FLAT:$L68082
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68258	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68080
$T68257	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T68258
$T68248	DD	019930520H
	DD	04H
	DD	FLAT:$T68256
	DD	01H
	DD	FLAT:$T68257
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	ENDS
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
__Ctype_fac$63936 = -32					; size = 4
$T68074 = -28						; size = 4
__State$ = -24						; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001b	53		 push	 ebx
  0001c	56		 push	 esi

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;
; 432  : 	bool _Changed = false;
; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0001d	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
  00020	57		 push	 edi
  00021	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00024	33 ff		 xor	 edi, edi
  00026	57		 push	 edi
  00027	56		 push	 esi
  00028	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0002b	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
  0002e	c6 45 ef 00	 mov	 BYTE PTR __Changed$[ebp], 0
  00032	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry

; 434  : 
; 435  : 	if (_Ok)

  00037	8a 45 dc	 mov	 al, BYTE PTR __Ok$[ebp+4]
  0003a	84 c0		 test	 al, al
  0003c	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  0003f	0f 84 f7 00 00
	00		 je	 $L63938

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00045	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00047	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T68074[ebp]
  0004d	50		 push	 eax
  0004e	03 ce		 add	 ecx, esi
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  00056	50		 push	 eax
  00057	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0005b	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00060	83 c4 04	 add	 esp, 4
  00063	8d 4d e4	 lea	 ecx, DWORD PTR $T68074[ebp]
  00066	89 45 e0	 mov	 DWORD PTR __Ctype_fac$63936[ebp], eax
  00069	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00073	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  00079	8b 02		 mov	 eax, DWORD PTR [edx]
  0007b	8b 5d 0c	 mov	 ebx, DWORD PTR __Str$[ebp]
  0007e	50		 push	 eax
  0007f	57		 push	 edi
  00080	8b cb		 mov	 ecx, ebx
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN
; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  00088	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008d	8b 7c 32 18	 mov	 edi, DWORD PTR [edx+esi+24]
  00091	85 ff		 test	 edi, edi
  00093	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00097	7e 17		 jle	 SHORT $L68075
  00099	8b cb		 mov	 ecx, ebx
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  000a1	3b f8		 cmp	 edi, eax
  000a3	73 0b		 jae	 SHORT $L68075
  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000aa	8b 7c 31 18	 mov	 edi, DWORD PTR [ecx+esi+24]
  000ae	eb 0a		 jmp	 SHORT $L68076
$L68075:
  000b0	8b cb		 mov	 ecx, ebx
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  000b8	8b f8		 mov	 edi, eax
$L68076:

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  000ba	8b 16		 mov	 edx, DWORD PTR [esi]
  000bc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000bf	8b 4c 30 28	 mov	 ecx, DWORD PTR [eax+esi+40]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$L63943:

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  000d0	85 ff		 test	 edi, edi
  000d2	76 68		 jbe	 SHORT $L63938

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  000d4	83 f8 ff	 cmp	 eax, -1
  000d7	75 06		 jne	 SHORT $L63947

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  000d9	83 4d e8 01	 or	 DWORD PTR __State$[ebp], 1

; 450  : 				break;

  000dd	eb 5d		 jmp	 SHORT $L63938
$L63947:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  000df	8b 55 e0	 mov	 edx, DWORD PTR __Ctype_fac$63936[ebp]
  000e2	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  000e5	0f b6 c8	 movzx	 ecx, al
  000e8	f6 04 4a 48	 test	 BYTE PTR [edx+ecx*2], 72 ; 00000048H
  000ec	75 4e		 jne	 SHORT $L63938

; 454  : 				break;	// whitespace, quit
; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  000ee	50		 push	 eax
  000ef	6a 01		 push	 1
  000f1	8b cb		 mov	 ecx, ebx
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
  000f9	8b 06		 mov	 eax, DWORD PTR [esi]
  000fb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000fe	8b 4c 31 28	 mov	 ecx, DWORD PTR [ecx+esi+40]

; 458  : 				_Changed = true;

  00102	c6 45 ef 01	 mov	 BYTE PTR __Changed$[ebp], 1
  00106	4f		 dec	 edi
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  0010d	eb c1		 jmp	 SHORT $L63943
$L68080:

; 459  : 				}
; 460  : 		_CATCH_IO_(_Istr)

  0010f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00112	8b 10		 mov	 edx, DWORD PTR [eax]
  00114	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00117	8b 54 01 28	 mov	 edx, DWORD PTR [ecx+eax+40]
  0011b	03 c8		 add	 ecx, eax
  0011d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00120	83 c8 04	 or	 eax, 4
  00123	85 d2		 test	 edx, edx
  00125	75 03		 jne	 SHORT $L68180
  00127	83 c8 04	 or	 eax, 4
$L68180:
  0012a	6a 01		 push	 1
  0012c	50		 push	 eax
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
  00133	b8 00 00 00 00	 mov	 eax, $L68251
  00138	c3		 ret	 0
$L68251:
  00139	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
$L63938:

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  0013c	8b 06		 mov	 eax, DWORD PTR [esi]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 464  : 	if (!_Changed)
; 465  : 		_State |= ios_base::failbit;

  00141	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  00144	33 ff		 xor	 edi, edi
  00146	03 c6		 add	 eax, esi
  00148	89 78 18	 mov	 DWORD PTR [eax+24], edi
  0014b	8a 45 ef	 mov	 al, BYTE PTR __Changed$[ebp]
  0014e	84 c0		 test	 al, al
  00150	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  00153	75 03		 jne	 SHORT $L63951
  00155	83 ca 02	 or	 edx, 2
$L63951:

; 466  : 	_Istr.setstate(_State);

  00158	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0015a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0015d	03 ce		 add	 ecx, esi
  0015f	3b d7		 cmp	 edx, edi
  00161	74 15		 je	 SHORT $L68209
  00163	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00166	0b c2		 or	 eax, edx
  00168	39 79 28	 cmp	 DWORD PTR [ecx+40], edi
  0016b	75 03		 jne	 SHORT $L68208
  0016d	83 c8 04	 or	 eax, 4
$L68208:
  00170	57		 push	 edi
  00171	50		 push	 eax
  00172	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
$L68209:

; 467  : 	return (_Istr);

  00178	8b 45 d8	 mov	 eax, DWORD PTR __Ok$[ebp]
  0017b	8b 10		 mov	 edx, DWORD PTR [eax]
  0017d	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00180	8b 44 01 28	 mov	 eax, DWORD PTR [ecx+eax+40]
  00184	3b c7		 cmp	 eax, edi
  00186	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0018d	74 09		 je	 SHORT $L68250
  0018f	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L68250:

; 468  : 	}

  00198	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0019b	5f		 pop	 edi
  0019c	8b c6		 mov	 eax, esi
  0019e	5e		 pop	 esi
  0019f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a6	5b		 pop	 ebx
  001a7	8b e5		 mov	 esp, ebp
  001a9	5d		 pop	 ebp
  001aa	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68081:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
$L68082:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR $T68074[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68248
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T68431	DD	0ffffffffH
	DD	FLAT:$L68266
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68433	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68265
$T68432	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68433
$T68423	DD	019930520H
	DD	03H
	DD	FLAT:$T68431
	DD	01H
	DD	FLAT:$T68432
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	ENDS
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Ok$ = -32						; size = 8
__State$ = -24						; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;
; 480  : 	bool _Changed = false;
; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0001d	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
  00020	57		 push	 edi
  00021	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00024	6a 01		 push	 1
  00026	33 ff		 xor	 edi, edi
  00028	56		 push	 esi
  00029	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0002c	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
  0002f	c6 45 ef 00	 mov	 BYTE PTR __Changed$[ebp], 0
  00033	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry

; 482  : 
; 483  : 	if (_Ok)

  00038	8a 45 e4	 mov	 al, BYTE PTR __Ok$[ebp+4]
  0003b	84 c0		 test	 al, al
  0003d	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  00040	0f 84 b6 00 00
	00		 je	 $L63960

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN
; 486  : 		_Str.erase();

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00051	57		 push	 edi
  00052	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);
; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  0005c	8b 16		 mov	 edx, DWORD PTR [esi]
  0005e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00061	8b 4c 30 28	 mov	 ecx, DWORD PTR [eax+esi+40]
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
$L68430:
  0006b	8b f8		 mov	 edi, eax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())
; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0006d	83 ff ff	 cmp	 edi, -1
  00070	75 09		 jne	 SHORT $L63967

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  00072	83 4d e8 01	 or	 DWORD PTR __State$[ebp], 1

; 495  : 				break;

  00076	e9 81 00 00 00	 jmp	 $L63960
$L63967:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  0007b	0f b6 45 10	 movzx	 eax, BYTE PTR __Delim$[ebp]
  0007f	3b f8		 cmp	 edi, eax
  00081	75 15		 jne	 SHORT $L63969

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;
; 500  : 				_Istr.rdbuf()->sbumpc();

  00083	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00085	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00088	8b 4c 32 28	 mov	 ecx, DWORD PTR [edx+esi+40]
  0008c	c6 45 ef 01	 mov	 BYTE PTR __Changed$[ebp], 1
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 501  : 				break;

  00096	eb 64		 jmp	 SHORT $L63960
$L63969:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  00098	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0009b	8b 58 14	 mov	 ebx, DWORD PTR [eax+20]
  0009e	8b c8		 mov	 ecx, eax
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  000a6	3b c3		 cmp	 eax, ebx
  000a8	77 06		 ja	 SHORT $L63971

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  000aa	83 4d e8 02	 or	 DWORD PTR __State$[ebp], 2
  000ae	eb 4c		 jmp	 SHORT $L63960
$L63971:

; 506  : 				break;
; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  000b0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000b3	57		 push	 edi
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
  000ba	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000bc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000bf	8b 4c 32 28	 mov	 ecx, DWORD PTR [edx+esi+40]

; 511  : 				_Changed = true;

  000c3	c6 45 ef 01	 mov	 BYTE PTR __Changed$[ebp], 1
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  000cd	eb 9c		 jmp	 SHORT $L68430
$L68265:

; 512  : 				}
; 513  : 		_CATCH_IO_(_Istr)

  000cf	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d4	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000d7	8b 54 01 28	 mov	 edx, DWORD PTR [ecx+eax+40]
  000db	03 c8		 add	 ecx, eax
  000dd	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000e0	83 c8 04	 or	 eax, 4
  000e3	85 d2		 test	 edx, edx
  000e5	75 03		 jne	 SHORT $L68363
  000e7	83 c8 04	 or	 eax, 4
$L68363:
  000ea	6a 01		 push	 1
  000ec	50		 push	 eax
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
  000f3	b8 00 00 00 00	 mov	 eax, $L68426
  000f8	c3		 ret	 0
$L68426:
  000f9	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
$L63960:

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  000fc	8a 45 ef	 mov	 al, BYTE PTR __Changed$[ebp]
  000ff	84 c0		 test	 al, al

; 517  : 		_State |= ios_base::failbit;

  00101	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  00104	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0010b	75 03		 jne	 SHORT $L63973
  0010d	83 ca 02	 or	 edx, 2
$L63973:

; 518  : 	_Istr.setstate(_State);

  00110	8b 06		 mov	 eax, DWORD PTR [esi]
  00112	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00115	03 ce		 add	 ecx, esi
  00117	85 d2		 test	 edx, edx
  00119	74 18		 je	 SHORT $L68383
  0011b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0011e	0b c2		 or	 eax, edx
  00120	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00123	85 d2		 test	 edx, edx
  00125	75 03		 jne	 SHORT $L68386
  00127	83 c8 04	 or	 eax, 4
$L68386:
  0012a	6a 00		 push	 0
  0012c	50		 push	 eax
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
$L68383:

; 519  : 	return (_Istr);

  00133	8b 45 e0	 mov	 eax, DWORD PTR __Ok$[ebp]
  00136	8b 08		 mov	 ecx, DWORD PTR [eax]
  00138	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0013b	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0013f	85 c0		 test	 eax, eax
  00141	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00148	74 09		 je	 SHORT $L68425
  0014a	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L68425:

; 520  : 	}

  00153	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00156	5f		 pop	 edi
  00157	8b c6		 mov	 eax, esi
  00159	5e		 pop	 esi
  0015a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00161	5b		 pop	 ebx
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68266:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68423
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T68623	DD	0ffffffffH
	DD	FLAT:$L68448
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:$L68576
$T68625	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68447
$T68624	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68625
$T68611	DD	019930520H
	DD	04H
	DD	FLAT:$T68623
	DD	01H
	DD	FLAT:$T68624
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
__Size$ = -32						; size = 4
$T68475 = -28						; size = 1
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
$T68513 = 12						; size = 1
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;
; 544  : 	_Mysizt _Size = _Str.size();

  0001b	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00021	53		 push	 ebx
  00022	56		 push	 esi

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00023	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002b	8b 44 30 18	 mov	 eax, DWORD PTR [eax+esi+24]
  0002f	33 db		 xor	 ebx, ebx
  00031	3b c3		 cmp	 eax, ebx
  00033	57		 push	 edi
  00034	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00037	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
  0003a	89 4d e0	 mov	 DWORD PTR __Size$[ebp], ecx
  0003d	7e 0d		 jle	 SHORT $L68437
  0003f	3b c1		 cmp	 eax, ecx
  00041	76 09		 jbe	 SHORT $L68437
  00043	2b c1		 sub	 eax, ecx
  00045	8b f8		 mov	 edi, eax
  00047	89 7d e8	 mov	 DWORD PTR __Pad$[ebp], edi
  0004a	eb 05		 jmp	 SHORT $L68438
$L68437:
  0004c	89 5d e8	 mov	 DWORD PTR __Pad$[ebp], ebx
  0004f	8b fb		 mov	 edi, ebx
$L68438:

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  00051	56		 push	 esi
  00052	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00055	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 548  : 
; 549  : 	if (!_Ok)

  0005a	8a 45 dc	 mov	 al, BYTE PTR __Ok$[ebp+4]
  0005d	84 c0		 test	 al, al
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00066	75 0c		 jne	 SHORT $L63985

; 550  : 		_State |= ios_base::badbit;

  00068	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR __State$[ebp], 4

; 551  : 	else

  0006f	e9 0a 01 00 00	 jmp	 $L68525
$L63985:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN
; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  00074	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00076	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00079	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0007d	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00082	83 f8 40	 cmp	 eax, 64			; 00000040H
  00085	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00089	74 36		 je	 SHORT $L68615
  0008b	eb 03 8d 49 00	 npad	 5
$L63989:

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00090	85 ff		 test	 edi, edi
  00092	76 29		 jbe	 SHORT $L63991

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  00094	8b 06		 mov	 eax, DWORD PTR [esi]
  00096	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00099	8a 54 31 30	 mov	 dl, BYTE PTR [ecx+esi+48]
  0009d	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  000a0	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000a3	88 55 e4	 mov	 BYTE PTR $T68475[ebp], dl
  000a6	8b 4d e4	 mov	 ecx, DWORD PTR $T68475[ebp]
  000a9	51		 push	 ecx
  000aa	8b c8		 mov	 ecx, eax
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  000b2	83 f8 ff	 cmp	 eax, -1
  000b5	75 23		 jne	 SHORT $L63990

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  000b7	83 cb 04	 or	 ebx, 4
  000ba	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
$L63991:

; 560  : 					break;
; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  000bd	85 db		 test	 ebx, ebx
  000bf	75 75		 jne	 SHORT $L64006
$L68615:

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  000c1	33 ff		 xor	 edi, edi
  000c3	bb 10 00 00 00	 mov	 ebx, 16			; 00000010H
$L63997:
  000c8	3b 7d e0	 cmp	 edi, DWORD PTR __Size$[ebp]
  000cb	73 34		 jae	 SHORT $L63999

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  000cd	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  000d0	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  000d3	72 0b		 jb	 SHORT $L68498
  000d5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d8	eb 09		 jmp	 SHORT $L68499
$L63990:

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000da	4f		 dec	 edi
  000db	89 7d e8	 mov	 DWORD PTR __Pad$[ebp], edi
  000de	eb b0		 jmp	 SHORT $L63989

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

$L68498:
  000e0	83 c0 04	 add	 eax, 4
$L68499:
  000e3	8b 16		 mov	 edx, DWORD PTR [esi]
  000e5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e8	8b 4c 31 28	 mov	 ecx, DWORD PTR [ecx+esi+40]
  000ec	33 d2		 xor	 edx, edx
  000ee	8a 14 38	 mov	 dl, BYTE PTR [eax+edi]
  000f1	52		 push	 edx
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  000f8	83 f8 ff	 cmp	 eax, -1
  000fb	75 49		 jne	 SHORT $L63998

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  000fd	83 4d ec 04	 or	 DWORD PTR __State$[ebp], 4
$L63999:

; 569  : 					break;
; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00101	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00104	85 c0		 test	 eax, eax
  00106	75 2e		 jne	 SHORT $L64006
$L64004:

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00108	8b 45 e8	 mov	 eax, DWORD PTR __Pad$[ebp]
  0010b	85 c0		 test	 eax, eax
  0010d	76 27		 jbe	 SHORT $L64006

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  0010f	8b 06		 mov	 eax, DWORD PTR [esi]
  00111	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00114	8a 54 31 30	 mov	 dl, BYTE PTR [ecx+esi+48]
  00118	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  0011b	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0011e	88 55 0c	 mov	 BYTE PTR $T68513[ebp], dl
  00121	8b 4d 0c	 mov	 ecx, DWORD PTR $T68513[ebp]
  00124	51		 push	 ecx
  00125	8b c8		 mov	 ecx, eax
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0012d	83 f8 ff	 cmp	 eax, -1
  00130	75 1a		 jne	 SHORT $L64005

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  00132	83 4d ec 04	 or	 DWORD PTR __State$[ebp], 4
$L64006:

; 578  : 					break;
; 579  : 					}
; 580  : 		_Ostr.width(0);

  00136	8b 06		 mov	 eax, DWORD PTR [esi]
  00138	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013b	03 c6		 add	 eax, esi
  0013d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00144	eb 38		 jmp	 SHORT $L68525
$L63998:

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00146	47		 inc	 edi
  00147	e9 7c ff ff ff	 jmp	 $L63997
$L64005:

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  0014c	ff 4d e8	 dec	 DWORD PTR __Pad$[ebp]
  0014f	eb b7		 jmp	 SHORT $L64004
$L68447:

; 581  : 		_CATCH_IO_(_Ostr)

  00151	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00154	8b 10		 mov	 edx, DWORD PTR [eax]
  00156	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00159	8b 54 01 28	 mov	 edx, DWORD PTR [ecx+eax+40]
  0015d	03 c8		 add	 ecx, eax
  0015f	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00162	83 c8 04	 or	 eax, 4
  00165	85 d2		 test	 edx, edx
  00167	75 03		 jne	 SHORT $L68550
  00169	83 c8 04	 or	 eax, 4
$L68550:
  0016c	6a 01		 push	 1
  0016e	50		 push	 eax
  0016f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
  00175	b8 00 00 00 00	 mov	 eax, $L68619
  0017a	c3		 ret	 0
$L68619:

; 578  : 					break;
; 579  : 					}
; 580  : 		_Ostr.width(0);

  0017b	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
$L68525:

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  0017e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00180	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00183	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  00186	03 ce		 add	 ecx, esi
  00188	85 d2		 test	 edx, edx
  0018a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00191	74 18		 je	 SHORT $L68570
  00193	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00196	0b c2		 or	 eax, edx
  00198	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0019b	85 d2		 test	 edx, edx
  0019d	75 03		 jne	 SHORT $L68573
  0019f	83 c8 04	 or	 eax, 4
$L68573:
  001a2	6a 00		 push	 0
  001a4	50		 push	 eax
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
$L68570:

; 585  : 	return (_Ostr);

  001ab	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  001b8	84 c0		 test	 al, al
  001ba	75 09		 jne	 SHORT $L68599
  001bc	8b 4d d8	 mov	 ecx, DWORD PTR __Ok$[ebp]
  001bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$L68599:
  001c5	8b 45 d8	 mov	 eax, DWORD PTR __Ok$[ebp]
  001c8	8b 10		 mov	 edx, DWORD PTR [eax]
  001ca	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001cd	8b 44 01 28	 mov	 eax, DWORD PTR [ecx+eax+40]
  001d1	85 c0		 test	 eax, eax
  001d3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001da	74 09		 je	 SHORT $L68616
  001dc	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L68616:

; 586  : 	}

  001e5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001e8	5f		 pop	 edi
  001e9	8b c6		 mov	 eax, esi
  001eb	5e		 pop	 esi
  001ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001f3	5b		 pop	 ebx
  001f4	8b e5		 mov	 esp, ebp
  001f6	5d		 pop	 ebp
  001f7	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68448:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
$L68576:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00010	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68611
  00015	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?is@?$ctype@_W@std@@QBE_NF_W@Z:NEAR
EXTRN	__imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
EXTRN	__imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB:DWORD
EXTRN	__imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z:NEAR
EXTRN	__imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z:NEAR
EXTRN	__imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T68769	DD	0ffffffffH
	DD	FLAT:$L68636
	DD	00H
	DD	FLAT:$L68637
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68771	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68635
$T68770	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T68771
$T68760	DD	019930520H
	DD	04H
	DD	FLAT:$T68769
	DD	01H
	DD	FLAT:$T68770
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	ENDS
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
__Ctype_fac$64020 = -32					; size = 4
$T68629 = -28						; size = 4
__State$ = -24						; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 425  : 	{	// extract a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 1c	 sub	 esp, 28			; 0000001cH
  0001b	53		 push	 ebx
  0001c	56		 push	 esi

; 426  : 	typedef ctype<_Elem> _Ctype;
; 427  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 428  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 429  : 	typedef typename _Mystr::size_type _Mysizt;
; 430  : 
; 431  : 	ios_base::iostate _State = ios_base::goodbit;
; 432  : 	bool _Changed = false;
; 433  : 	const typename _Myis::sentry _Ok(_Istr);

  0001d	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
  00020	57		 push	 edi
  00021	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00024	33 ff		 xor	 edi, edi
  00026	57		 push	 edi
  00027	56		 push	 esi
  00028	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0002b	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
  0002e	c6 45 ef 00	 mov	 BYTE PTR __Changed$[ebp], 0
  00032	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 434  : 
; 435  : 	if (_Ok)

  00037	8a 45 dc	 mov	 al, BYTE PTR __Ok$[ebp+4]
  0003a	84 c0		 test	 al, al
  0003c	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  0003f	0f 84 f6 00 00
	00		 je	 $L64022

; 436  : 		{	// state okay, extract characters
; 437  : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  00045	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00047	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T68629[ebp]
  0004d	50		 push	 eax
  0004e	03 ce		 add	 ecx, esi
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  00056	50		 push	 eax
  00057	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0005b	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00060	83 c4 04	 add	 esp, 4
  00063	8d 4d e4	 lea	 ecx, DWORD PTR $T68629[ebp]
  00066	89 45 e0	 mov	 DWORD PTR __Ctype_fac$64020[ebp], eax
  00069	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1locale@std@@QAE@XZ

; 438  : 		_Str.erase();

  00073	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  00079	8b 02		 mov	 eax, DWORD PTR [edx]
  0007b	8b 5d 0c	 mov	 ebx, DWORD PTR __Str$[ebp]
  0007e	50		 push	 eax
  0007f	57		 push	 edi
  00080	8b cb		 mov	 ecx, ebx
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 439  : 
; 440  : 		_TRY_IO_BEGIN
; 441  : 		_Mysizt _Size = 0 < _Istr.width()
; 442  : 			&& (_Mysizt)_Istr.width() < _Str.max_size()
; 443  : 				? (_Mysizt)_Istr.width() : _Str.max_size();

  00088	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0008d	8b 7c 32 18	 mov	 edi, DWORD PTR [edx+esi+24]
  00091	85 ff		 test	 edi, edi
  00093	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00097	7e 17		 jle	 SHORT $L68630
  00099	8b cb		 mov	 ecx, ebx
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  000a1	3b f8		 cmp	 edi, eax
  000a3	73 0b		 jae	 SHORT $L68630
  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000aa	8b 5c 31 18	 mov	 ebx, DWORD PTR [ecx+esi+24]
  000ae	eb 0a		 jmp	 SHORT $L68631
$L68630:
  000b0	8b cb		 mov	 ecx, ebx
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  000b8	8b d8		 mov	 ebx, eax
$L68631:

; 444  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  000ba	8b 16		 mov	 edx, DWORD PTR [esi]
  000bc	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000bf	8b 4c 30 28	 mov	 ecx, DWORD PTR [eax+esi+40]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
$L68768:

; 445  : 
; 446  : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  000c9	85 db		 test	 ebx, ebx
  000cb	8b f8		 mov	 edi, eax
  000cd	76 6c		 jbe	 SHORT $L64022

; 447  : 			if(_Traits::eq_int_type(_Traits::eof(), _Meta))

  000cf	66 81 ff ff ff	 cmp	 di, 65535		; 0000ffffH
  000d4	75 06		 jne	 SHORT $L64031

; 448  : 				{	// end of file, quit
; 449  : 				_State |= ios_base::eofbit;

  000d6	83 4d e8 01	 or	 DWORD PTR __State$[ebp], 1

; 450  : 				break;

  000da	eb 5f		 jmp	 SHORT $L64022
$L64031:

; 451  : 				}
; 452  : 			else if (_Ctype_fac.is(_Ctype::space,
; 453  : 				_Traits::to_char_type(_Meta)))

  000dc	8b 4d e0	 mov	 ecx, DWORD PTR __Ctype_fac$64020[ebp]
  000df	57		 push	 edi
  000e0	6a 48		 push	 72			; 00000048H
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@_W@std@@QBE_NF_W@Z
  000e8	84 c0		 test	 al, al
  000ea	75 4f		 jne	 SHORT $L64022

; 454  : 				break;	// whitespace, quit
; 455  : 			else
; 456  : 				{	// add character to string
; 457  : 				_Str.append(1, _Traits::to_char_type(_Meta));

  000ec	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000ef	57		 push	 edi
  000f0	6a 01		 push	 1
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
  000f8	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000fa	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fd	8b 4c 32 28	 mov	 ecx, DWORD PTR [edx+esi+40]

; 458  : 				_Changed = true;

  00101	c6 45 ef 01	 mov	 BYTE PTR __Changed$[ebp], 1
  00105	4b		 dec	 ebx
  00106	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  0010c	eb bb		 jmp	 SHORT $L68768
$L68635:

; 459  : 				}
; 460  : 		_CATCH_IO_(_Istr)

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00111	8b 08		 mov	 ecx, DWORD PTR [eax]
  00113	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00116	8b 54 01 28	 mov	 edx, DWORD PTR [ecx+eax+40]
  0011a	03 c8		 add	 ecx, eax
  0011c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0011f	83 c8 04	 or	 eax, 4
  00122	85 d2		 test	 edx, edx
  00124	75 03		 jne	 SHORT $L68692
  00126	83 c8 04	 or	 eax, 4
$L68692:
  00129	6a 01		 push	 1
  0012b	50		 push	 eax
  0012c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
  00132	b8 00 00 00 00	 mov	 eax, $L68763
  00137	c3		 ret	 0
$L68763:
  00138	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
$L64022:

; 461  : 		}
; 462  : 
; 463  : 	_Istr.width(0);

  0013b	8b 16		 mov	 edx, DWORD PTR [esi]
  0013d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 464  : 	if (!_Changed)
; 465  : 		_State |= ios_base::failbit;

  00140	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  00143	33 ff		 xor	 edi, edi
  00145	03 c6		 add	 eax, esi
  00147	89 78 18	 mov	 DWORD PTR [eax+24], edi
  0014a	8a 45 ef	 mov	 al, BYTE PTR __Changed$[ebp]
  0014d	84 c0		 test	 al, al
  0014f	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  00152	75 03		 jne	 SHORT $L64035
  00154	83 ca 02	 or	 edx, 2
$L64035:

; 466  : 	_Istr.setstate(_State);

  00157	8b 06		 mov	 eax, DWORD PTR [esi]
  00159	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0015c	03 ce		 add	 ecx, esi
  0015e	3b d7		 cmp	 edx, edi
  00160	74 15		 je	 SHORT $L68721
  00162	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00165	0b c2		 or	 eax, edx
  00167	39 79 28	 cmp	 DWORD PTR [ecx+40], edi
  0016a	75 03		 jne	 SHORT $L68720
  0016c	83 c8 04	 or	 eax, 4
$L68720:
  0016f	57		 push	 edi
  00170	50		 push	 eax
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
$L68721:

; 467  : 	return (_Istr);

  00177	8b 45 d8	 mov	 eax, DWORD PTR __Ok$[ebp]
  0017a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0017f	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00183	3b c7		 cmp	 eax, edi
  00185	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0018c	74 09		 je	 SHORT $L68762
  0018e	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L68762:

; 468  : 	}

  00197	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0019a	5f		 pop	 edi
  0019b	8b c6		 mov	 eax, esi
  0019d	5e		 pop	 esi
  0019e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001a5	5b		 pop	 ebx
  001a6	8b e5		 mov	 esp, ebp
  001a8	5d		 pop	 ebp
  001a9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68636:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
$L68637:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR $T68629[ebp]
  0000b	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1locale@std@@QAE@XZ
__ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00011	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68760
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T68904	DD	0ffffffffH
	DD	FLAT:$L68779
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T68906	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68778
$T68905	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T68906
$T68896	DD	019930520H
	DD	03H
	DD	FLAT:$T68904
	DD	01H
	DD	FLAT:$T68905
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	ENDS
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
_TEXT	SEGMENT
__Ok$ = -32						; size = 8
__State$ = -24						; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
__Delim$ = 16						; size = 2
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 477  : 	{	// get characters into string, discard delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 14	 sub	 esp, 20			; 00000014H
  0001b	53		 push	 ebx
  0001c	56		 push	 esi

; 478  : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 479  : 	ios_base::iostate _State = ios_base::goodbit;
; 480  : 	bool _Changed = false;
; 481  : 	const typename _Myis::sentry _Ok(_Istr, true);

  0001d	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
  00020	57		 push	 edi
  00021	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00024	6a 01		 push	 1
  00026	33 ff		 xor	 edi, edi
  00028	56		 push	 esi
  00029	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0002c	89 7d e8	 mov	 DWORD PTR __State$[ebp], edi
  0002f	c6 45 ef 00	 mov	 BYTE PTR __Changed$[ebp], 0
  00033	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 482  : 
; 483  : 	if (_Ok)

  00038	8a 45 e4	 mov	 al, BYTE PTR __Ok$[ebp+4]
  0003b	84 c0		 test	 al, al
  0003d	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], edi
  00040	0f 84 b3 00 00
	00		 je	 $L64044

; 484  : 		{	// state okay, extract characters
; 485  : 		_TRY_IO_BEGIN
; 486  : 		_Str.erase();

  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00051	57		 push	 edi
  00052	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z

; 487  : 		const typename _Traits::int_type _Metadelim =
; 488  : 			_Traits::to_int_type(_Delim);
; 489  : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  0005c	8b 16		 mov	 edx, DWORD PTR [esi]
  0005e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00061	8b 4c 30 28	 mov	 ecx, DWORD PTR [eax+esi+40]
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
$L68903:
  0006b	8b f8		 mov	 edi, eax

; 490  : 
; 491  : 		for (; ; _Meta = _Istr.rdbuf()->snextc())
; 492  : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0006d	66 81 ff ff ff	 cmp	 di, 65535		; 0000ffffH
  00072	75 06		 jne	 SHORT $L64051

; 493  : 				{	// end of file, quit
; 494  : 				_State |= ios_base::eofbit;

  00074	83 4d e8 01	 or	 DWORD PTR __State$[ebp], 1

; 495  : 				break;

  00078	eb 7f		 jmp	 SHORT $L64044
$L64051:

; 496  : 				}
; 497  : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  0007a	66 3b 7d 10	 cmp	 di, WORD PTR __Delim$[ebp]
  0007e	75 15		 jne	 SHORT $L64053

; 498  : 				{	// got a delimiter, discard it and quit
; 499  : 				_Changed = true;
; 500  : 				_Istr.rdbuf()->sbumpc();

  00080	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00082	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00085	8b 4c 32 28	 mov	 ecx, DWORD PTR [edx+esi+40]
  00089	c6 45 ef 01	 mov	 BYTE PTR __Changed$[ebp], 1
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ

; 501  : 				break;

  00093	eb 64		 jmp	 SHORT $L64044
$L64053:

; 502  : 				}
; 503  : 			else if (_Str.max_size() <= _Str.size())

  00095	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  00098	8b 58 14	 mov	 ebx, DWORD PTR [eax+20]
  0009b	8b c8		 mov	 ecx, eax
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
  000a3	3b c3		 cmp	 eax, ebx
  000a5	77 06		 ja	 SHORT $L64055

; 504  : 				{	// string too large, quit
; 505  : 				_State |= ios_base::failbit;

  000a7	83 4d e8 02	 or	 DWORD PTR __State$[ebp], 2
  000ab	eb 4c		 jmp	 SHORT $L64044
$L64055:

; 506  : 				break;
; 507  : 				}
; 508  : 			else
; 509  : 				{	// got a character, add it to string
; 510  : 				_Str += _Traits::to_char_type(_Meta);

  000ad	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000b0	57		 push	 edi
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@_W@Z
  000b7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b9	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000bc	8b 4c 32 28	 mov	 ecx, DWORD PTR [edx+esi+40]

; 511  : 				_Changed = true;

  000c0	c6 45 ef 01	 mov	 BYTE PTR __Changed$[ebp], 1
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
  000ca	eb 9f		 jmp	 SHORT $L68903
$L68778:

; 512  : 				}
; 513  : 		_CATCH_IO_(_Istr)

  000cc	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d1	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000d4	8b 54 01 28	 mov	 edx, DWORD PTR [ecx+eax+40]
  000d8	03 c8		 add	 ecx, eax
  000da	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000dd	83 c8 04	 or	 eax, 4
  000e0	85 d2		 test	 edx, edx
  000e2	75 03		 jne	 SHORT $L68833
  000e4	83 c8 04	 or	 eax, 4
$L68833:
  000e7	6a 01		 push	 1
  000e9	50		 push	 eax
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
  000f0	b8 00 00 00 00	 mov	 eax, $L68899
  000f5	c3		 ret	 0
$L68899:
  000f6	8b 75 08	 mov	 esi, DWORD PTR __Istr$[ebp]
$L64044:

; 514  : 		}
; 515  : 
; 516  : 	if (!_Changed)

  000f9	8a 45 ef	 mov	 al, BYTE PTR __Changed$[ebp]
  000fc	84 c0		 test	 al, al

; 517  : 		_State |= ios_base::failbit;

  000fe	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  00101	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00108	75 03		 jne	 SHORT $L64057
  0010a	83 ca 02	 or	 edx, 2
$L64057:

; 518  : 	_Istr.setstate(_State);

  0010d	8b 06		 mov	 eax, DWORD PTR [esi]
  0010f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00112	03 ce		 add	 ecx, esi
  00114	85 d2		 test	 edx, edx
  00116	74 18		 je	 SHORT $L68857
  00118	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0011b	0b c2		 or	 eax, edx
  0011d	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00120	85 d2		 test	 edx, edx
  00122	75 03		 jne	 SHORT $L68856
  00124	83 c8 04	 or	 eax, 4
$L68856:
  00127	6a 00		 push	 0
  00129	50		 push	 eax
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
$L68857:

; 519  : 	return (_Istr);

  00130	8b 45 e0	 mov	 eax, DWORD PTR __Ok$[ebp]
  00133	8b 08		 mov	 ecx, DWORD PTR [eax]
  00135	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00138	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  0013c	85 c0		 test	 eax, eax
  0013e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00145	74 09		 je	 SHORT $L68898
  00147	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L68898:

; 520  : 	}

  00150	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00153	5f		 pop	 edi
  00154	8b c6		 mov	 eax, esi
  00156	5e		 pop	 esi
  00157	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0015e	5b		 pop	 ebx
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68779:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
__ehhandler$??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T68896
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\include\streambuf
xdata$x	SEGMENT
$T69096	DD	0ffffffffH
	DD	FLAT:$L68921
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:$L69049
$T69098	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L68920
$T69097	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T69098
$T69084	DD	019930520H
	DD	04H
	DD	FLAT:$T69096
	DD	01H
	DD	FLAT:$T69097
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	ENDS
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Ok$ = -36						; size = 8
__Size$ = -28						; size = 4
__Pad$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 538  : 	{	// insert a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 18	 sub	 esp, 24			; 00000018H

; 539  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 540  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 541  : 	typedef typename _Mystr::size_type _Mysizt;
; 542  : 
; 543  : 	ios_base::iostate _State = ios_base::goodbit;
; 544  : 	_Mysizt _Size = _Str.size();

  0001b	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  0001e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00021	53		 push	 ebx
  00022	56		 push	 esi

; 545  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
; 546  : 			? 0 : (_Mysizt)_Ostr.width() - _Size;

  00023	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
  00026	8b 16		 mov	 edx, DWORD PTR [esi]
  00028	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0002b	8b 44 30 18	 mov	 eax, DWORD PTR [eax+esi+24]
  0002f	33 db		 xor	 ebx, ebx
  00031	3b c3		 cmp	 eax, ebx
  00033	57		 push	 edi
  00034	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00037	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
  0003a	89 4d e4	 mov	 DWORD PTR __Size$[ebp], ecx
  0003d	7e 0d		 jle	 SHORT $L68910
  0003f	3b c1		 cmp	 eax, ecx
  00041	76 09		 jbe	 SHORT $L68910
  00043	2b c1		 sub	 eax, ecx
  00045	8b f8		 mov	 edi, eax
  00047	89 7d e8	 mov	 DWORD PTR __Pad$[ebp], edi
  0004a	eb 05		 jmp	 SHORT $L68911
$L68910:
  0004c	89 5d e8	 mov	 DWORD PTR __Pad$[ebp], ebx
  0004f	8b fb		 mov	 edi, ebx
$L68911:

; 547  : 	const typename _Myos::sentry _Ok(_Ostr);

  00051	56		 push	 esi
  00052	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00055	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry

; 548  : 
; 549  : 	if (!_Ok)

  0005a	8a 45 e0	 mov	 al, BYTE PTR __Ok$[ebp+4]
  0005d	84 c0		 test	 al, al
  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00066	75 0c		 jne	 SHORT $L64069

; 550  : 		_State |= ios_base::badbit;

  00068	c7 45 ec 04 00
	00 00		 mov	 DWORD PTR __State$[ebp], 4

; 551  : 	else

  0006f	e9 03 01 00 00	 jmp	 $L68999
$L64069:

; 552  : 		{	// state okay, insert characters
; 553  : 	_TRY_IO_BEGIN
; 554  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  00074	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00076	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00079	8b 44 32 10	 mov	 eax, DWORD PTR [edx+esi+16]
  0007d	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00082	83 f8 40	 cmp	 eax, 64			; 00000040H
  00085	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00089	74 33		 je	 SHORT $L69088
  0008b	eb 03 8d 49 00	 npad	 5
$L64073:

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  00090	85 ff		 test	 edi, edi
  00092	76 26		 jbe	 SHORT $L64075

; 556  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 557  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  00094	8b 06		 mov	 eax, DWORD PTR [esi]
  00096	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00099	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  0009c	33 d2		 xor	 edx, edx
  0009e	66 8b 50 30	 mov	 dx, WORD PTR [eax+48]
  000a2	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000a5	8b c8		 mov	 ecx, eax
  000a7	52		 push	 edx
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  000ae	66 3d ff ff	 cmp	 ax, 65535		; 0000ffffH
  000b2	75 23		 jne	 SHORT $L64074

; 558  : 					{	// insertion failed, quit
; 559  : 					_State |= ios_base::badbit;

  000b4	83 cb 04	 or	 ebx, 4
  000b7	89 5d ec	 mov	 DWORD PTR __State$[ebp], ebx
$L64075:

; 560  : 					break;
; 561  : 					}
; 562  : 
; 563  : 		if (_State == ios_base::goodbit)

  000ba	85 db		 test	 ebx, ebx
  000bc	75 74		 jne	 SHORT $L64090
$L69088:

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  000be	33 ff		 xor	 edi, edi
  000c0	bb 08 00 00 00	 mov	 ebx, 8
$L64081:
  000c5	3b 7d e4	 cmp	 edi, DWORD PTR __Size$[ebp]
  000c8	73 36		 jae	 SHORT $L64083

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

  000ca	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  000cd	39 58 18	 cmp	 DWORD PTR [eax+24], ebx
  000d0	72 0b		 jb	 SHORT $L68969
  000d2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d5	eb 09		 jmp	 SHORT $L68970
$L64074:

; 555  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000d7	4f		 dec	 edi
  000d8	89 7d e8	 mov	 DWORD PTR __Pad$[ebp], edi
  000db	eb b3		 jmp	 SHORT $L64073

; 565  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 566  : 					_Ostr.rdbuf()->sputc(_Str[_Count])))

$L68969:
  000dd	83 c0 04	 add	 eax, 4
$L68970:
  000e0	8b 16		 mov	 edx, DWORD PTR [esi]
  000e2	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e5	8b 4c 31 28	 mov	 ecx, DWORD PTR [ecx+esi+40]
  000e9	33 d2		 xor	 edx, edx
  000eb	66 8b 14 78	 mov	 dx, WORD PTR [eax+edi*2]
  000ef	52		 push	 edx
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  000f6	66 3d ff ff	 cmp	 ax, 65535		; 0000ffffH
  000fa	75 46		 jne	 SHORT $L64082

; 567  : 					{	// insertion failed, quit
; 568  : 					_State |= ios_base::badbit;

  000fc	83 4d ec 04	 or	 DWORD PTR __State$[ebp], 4
$L64083:

; 569  : 					break;
; 570  : 					}
; 571  : 
; 572  : 		if (_State == ios_base::goodbit)

  00100	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00103	85 c0		 test	 eax, eax
  00105	75 2b		 jne	 SHORT $L64090
$L64088:

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00107	8b 45 e8	 mov	 eax, DWORD PTR __Pad$[ebp]
  0010a	85 c0		 test	 eax, eax
  0010c	76 24		 jbe	 SHORT $L64090

; 574  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 575  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

  0010e	8b 06		 mov	 eax, DWORD PTR [esi]
  00110	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00113	8d 04 31	 lea	 eax, DWORD PTR [ecx+esi]
  00116	33 d2		 xor	 edx, edx
  00118	66 8b 50 30	 mov	 dx, WORD PTR [eax+48]
  0011c	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0011f	8b c8		 mov	 ecx, eax
  00121	52		 push	 edx
  00122	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
  00128	66 3d ff ff	 cmp	 ax, 65535		; 0000ffffH
  0012c	75 17		 jne	 SHORT $L64089

; 576  : 					{	// insertion failed, quit
; 577  : 					_State |= ios_base::badbit;

  0012e	83 4d ec 04	 or	 DWORD PTR __State$[ebp], 4
$L64090:

; 578  : 					break;
; 579  : 					}
; 580  : 		_Ostr.width(0);

  00132	8b 06		 mov	 eax, DWORD PTR [esi]
  00134	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00137	03 c6		 add	 eax, esi
  00139	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0
  00140	eb 35		 jmp	 SHORT $L68999
$L64082:

; 564  : 			for (_Mysizt _Count = 0; _Count < _Size; ++_Count)

  00142	47		 inc	 edi
  00143	eb 80		 jmp	 SHORT $L64081
$L64089:

; 573  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00145	ff 4d e8	 dec	 DWORD PTR __Pad$[ebp]
  00148	eb bd		 jmp	 SHORT $L64088
$L68920:

; 581  : 		_CATCH_IO_(_Ostr)

  0014a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0014d	8b 10		 mov	 edx, DWORD PTR [eax]
  0014f	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00152	8b 54 01 28	 mov	 edx, DWORD PTR [ecx+eax+40]
  00156	03 c8		 add	 ecx, eax
  00158	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0015b	83 c8 04	 or	 eax, 4
  0015e	85 d2		 test	 edx, edx
  00160	75 03		 jne	 SHORT $L69020
  00162	83 c8 04	 or	 eax, 4
$L69020:
  00165	6a 01		 push	 1
  00167	50		 push	 eax
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
  0016e	b8 00 00 00 00	 mov	 eax, $L69092
  00173	c3		 ret	 0
$L69092:

; 578  : 					break;
; 579  : 					}
; 580  : 		_Ostr.width(0);

  00174	8b 75 08	 mov	 esi, DWORD PTR __Ostr$[ebp]
$L68999:

; 582  : 		}
; 583  : 
; 584  : 	_Ostr.setstate(_State);

  00177	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00179	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0017c	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  0017f	03 ce		 add	 ecx, esi
  00181	85 d2		 test	 edx, edx
  00183	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0018a	74 18		 je	 SHORT $L69044
  0018c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0018f	0b c2		 or	 eax, edx
  00191	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00194	85 d2		 test	 edx, edx
  00196	75 03		 jne	 SHORT $L69043
  00198	83 c8 04	 or	 eax, 4
$L69043:
  0019b	6a 00		 push	 0
  0019d	50		 push	 eax
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@ios_base@std@@QAEXH_N@Z
$L69044:

; 585  : 	return (_Ostr);

  001a4	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 3
  001ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  001b1	84 c0		 test	 al, al
  001b3	75 09		 jne	 SHORT $L69082
  001b5	8b 4d dc	 mov	 ecx, DWORD PTR __Ok$[ebp]
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
$L69082:
  001be	8b 45 dc	 mov	 eax, DWORD PTR __Ok$[ebp]
  001c1	8b 10		 mov	 edx, DWORD PTR [eax]
  001c3	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001c6	8b 44 01 28	 mov	 eax, DWORD PTR [ecx+eax+40]
  001ca	85 c0		 test	 eax, eax
  001cc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001d3	74 09		 je	 SHORT $L69089
  001d5	8d 48 04	 lea	 ecx, DWORD PTR [eax+4]
  001d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Unlock@_Mutex@std@@QAEXXZ
$L69089:

; 586  : 	}

  001de	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001e1	5f		 pop	 edi
  001e2	8b c6		 mov	 eax, esi
  001e4	5e		 pop	 esi
  001e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001ec	5b		 pop	 ebx
  001ed	8b e5		 mov	 esp, ebp
  001ef	5d		 pop	 ebp
  001f0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L68921:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
$L69049:
  00008	8d 4d dc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__ehhandler$??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  00010	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69084
  00015	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringA@24:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
$T69168	DD	0ffffffffH
	DD	FLAT:$L69111
$T69162	DD	019930520H
	DD	01H
	DD	FLAT:$T69168
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
__acp_ex$ = -20						; size = 4
__AtlSafeAllocaManager$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWFake, COMDAT

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00010	50		 push	 eax
  00011	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00018	83 ec 08	 sub	 esp, 8
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	57		 push	 edi

; 193  : 	USES_CONVERSION_EX;

  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00024	33 f6		 xor	 esi, esi
  00026	89 45 ec	 mov	 DWORD PTR __acp_ex$[ebp], eax
  00029	33 db		 xor	 ebx, ebx
  0002b	89 75 f0	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi

; 194  : 	
; 195  : 	LPCSTR pszAString1 = NULL;
; 196  : 	if(pszString1 != NULL)

  0002e	8b 45 10	 mov	 eax, DWORD PTR _pszString1$[ebp]
  00031	3b c3		 cmp	 eax, ebx
  00033	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00036	74 6f		 je	 SHORT $L26832

; 197  : 	{
; 198  : 		pszAString1 = W2A_EX(pszString1,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  00038	50		 push	 eax
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  0003f	8d 7c 00 02	 lea	 edi, DWORD PTR [eax+eax+2]
  00043	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  00049	7f 1e		 jg	 SHORT $L69102
  0004b	57		 push	 edi
  0004c	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  00051	83 c4 04	 add	 esp, 4
  00054	84 c0		 test	 al, al
  00056	74 11		 je	 SHORT $L69102
  00058	8b c7		 mov	 eax, edi
  0005a	83 c0 03	 add	 eax, 3
  0005d	83 e0 fc	 and	 eax, -4			; fffffffcH
  00060	e8 00 00 00 00	 call	 __alloca_probe
  00065	8b c4		 mov	 eax, esp
  00067	eb 1f		 jmp	 SHORT $L69130
$L69102:
  00069	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0006c	50		 push	 eax
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00073	83 c4 04	 add	 esp, 4
  00076	85 c0		 test	 eax, eax
  00078	74 0e		 je	 SHORT $L69130
$L69132:
  0007a	8b f0		 mov	 esi, eax
  0007c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00082	89 75 f0	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi
  00085	83 c0 08	 add	 eax, 8
$L69130:
  00088	8b 4d ec	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  0008b	8b 55 10	 mov	 edx, DWORD PTR _pszString1$[ebp]
  0008e	51		 push	 ecx
  0008f	57		 push	 edi
  00090	52		 push	 edx
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper
  00097	8b d8		 mov	 ebx, eax

; 199  : 		if(pszAString1 == NULL)

  00099	85 db		 test	 ebx, ebx
  0009b	75 0a		 jne	 SHORT $L26832

; 200  : 			AtlThrow(E_OUTOFMEMORY);

  0009d	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  000a2	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L26832:

; 201  : 	}
; 202  : 
; 203  : 	LPCSTR pszAString2 = NULL;
; 204  : 	if(pszString2 != NULL)

  000a7	8b 4d 18	 mov	 ecx, DWORD PTR _pszString2$[ebp]
  000aa	33 c0		 xor	 eax, eax
  000ac	85 c9		 test	 ecx, ecx
  000ae	74 69		 je	 SHORT $L26838

; 205  : 	{
; 206  : 		pszAString2 = W2A_EX(pszString2,_ATL_SAFE_ALLOCA_DEF_THRESHOLD);

  000b0	51		 push	 ecx
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  000b7	8d 7c 00 02	 lea	 edi, DWORD PTR [eax+eax+2]
  000bb	81 ff 00 04 00
	00		 cmp	 edi, 1024		; 00000400H
  000c1	7f 1e		 jg	 SHORT $L69106
  000c3	57		 push	 edi
  000c4	e8 00 00 00 00	 call	 ?_AtlVerifyStackAvailable@_ATL_SAFE_ALLOCA_IMPL@ATL@@YA_NK@Z ; ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable
  000c9	83 c4 04	 add	 esp, 4
  000cc	84 c0		 test	 al, al
  000ce	74 11		 je	 SHORT $L69106
  000d0	8b c7		 mov	 eax, edi
  000d2	83 c0 03	 add	 eax, 3
  000d5	83 e0 fc	 and	 eax, -4			; fffffffcH
  000d8	e8 00 00 00 00	 call	 __alloca_probe
  000dd	8b c4		 mov	 eax, esp
  000df	eb 1b		 jmp	 SHORT $L69144
$L69106:
  000e1	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  000e4	50		 push	 eax
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000eb	83 c4 04	 add	 esp, 4
  000ee	85 c0		 test	 eax, eax
  000f0	74 0a		 je	 SHORT $L69144
$L69148:
  000f2	89 30		 mov	 DWORD PTR [eax], esi
  000f4	8b f0		 mov	 esi, eax
  000f6	89 75 f0	 mov	 DWORD PTR __AtlSafeAllocaManager$[ebp], esi
  000f9	83 c0 08	 add	 eax, 8
$L69144:
  000fc	8b 4d ec	 mov	 ecx, DWORD PTR __acp_ex$[ebp]
  000ff	8b 55 18	 mov	 edx, DWORD PTR _pszString2$[ebp]
  00102	51		 push	 ecx
  00103	57		 push	 edi
  00104	52		 push	 edx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ?AtlW2AHelper@@YGPADPADPB_WHI@Z ; AtlW2AHelper

; 207  : 		if(pszAString2 == NULL)

  0010b	85 c0		 test	 eax, eax
  0010d	75 0a		 jne	 SHORT $L26838

; 208  : 			AtlThrow(E_OUTOFMEMORY);

  0010f	68 0e 00 07 80	 push	 -2147024882		; 8007000eH
  00114	e8 00 00 00 00	 call	 ?AtlThrow@ATL@@YGXJ@Z	; ATL::AtlThrow
$L26838:

; 209  : 	}
; 210  : 
; 211  : 	return ::CompareStringA(lcid, dwFlags, pszAString1, nLength1, pszAString2, nLength2);

  00119	8b 4d 1c	 mov	 ecx, DWORD PTR _nLength2$[ebp]
  0011c	8b 55 14	 mov	 edx, DWORD PTR _nLength1$[ebp]
  0011f	51		 push	 ecx
  00120	8b 4d 08	 mov	 ecx, DWORD PTR _lcid$[ebp]
  00123	50		 push	 eax
  00124	8b 45 0c	 mov	 eax, DWORD PTR _dwFlags$[ebp]
  00127	52		 push	 edx
  00128	53		 push	 ebx
  00129	50		 push	 eax
  0012a	51		 push	 ecx
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CompareStringA@24
  00131	85 f6		 test	 esi, esi
  00133	8b d8		 mov	 ebx, eax
  00135	74 17		 je	 SHORT $L69159
  00137	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__free
  0013d	8d 49 00	 npad	 3
$L69158:
  00140	8b c6		 mov	 eax, esi
  00142	8b 36		 mov	 esi, DWORD PTR [esi]
  00144	50		 push	 eax
  00145	ff d7		 call	 edi
  00147	83 c4 04	 add	 esp, 4
  0014a	85 f6		 test	 esi, esi
  0014c	75 f2		 jne	 SHORT $L69158
$L69159:
  0014e	8b c3		 mov	 eax, ebx

; 212  : }

  00150	8d 65 e0	 lea	 esp, DWORD PTR [ebp-32]
  00153	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00156	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 18 00	 ret	 24			; 00000018H
$L69167:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69111:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR __AtlSafeAllocaManager$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CAtlSafeAllocBufferManager@VCCRTAllocator@ATL@@@_ATL_SAFE_ALLOCA_IMPL@ATL@@QAE@XZ ; ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<ATL::CCRTAllocator>::~CAtlSafeAllocBufferManager<ATL::CCRTAllocator>
__ehhandler$?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69162
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWFake
EXTRN	__imp__CompareStringW@24:NEAR
; Function compile flags: /Ogty
;	COMDAT ?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwFlags$ = 12						; size = 4
_pszString1$ = 16					; size = 4
_nLength1$ = 20						; size = 4
_pszString2$ = 24					; size = 4
_nLength2$ = 28						; size = 4
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z PROC NEAR	; ATL::CompareStringWThunk, COMDAT

; 217  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnCompareStringW), CompareStringWFake, ::CompareStringW);

  00000	f6 05 00 00 00
	00 01		 test	 BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00007	75 19		 jne	 SHORT $L69185
  00009	83 0d 00 00 00
	00 01		 or	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	24 01		 and	 al, 1
  0001b	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  00020	eb 05		 jmp	 SHORT $L69177
$L69185:
  00022	a0 00 00 00 00	 mov	 al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L69177:
  00027	84 c0		 test	 al, al
  00029	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?CompareStringWFake@ATL@@YGHKKPB_WH0H@Z ; ATL::CompareStringWFake
  0002e	75 05		 jne	 SHORT $L69180
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__CompareStringW@24
$L69180:
  00035	50		 push	 eax
  00036	68 00 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A ; ATL::_strthunks
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 218  : 
; 219  : 	return _strthunks.pfnCompareStringW(lcid, dwFlags, pszString1, nLength1, pszString2, nLength2);

  00041	ff 25 00 00 00
	00		 jmp	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A
?CompareStringWThunk@ATL@@YGHKKPB_WH0H@Z ENDP		; ATL::CompareStringWThunk
_TEXT	ENDS
PUBLIC	?SortList@@YAXAAVCStringList@@0H@Z		; SortList
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:NEAR			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	?RemoveAll@CStringList@@QAEXXZ:NEAR		; CStringList::RemoveAll
EXTRN	?FindIndex@CStringList@@QBEPAU__POSITION@@H@Z:NEAR ; CStringList::FindIndex
;	COMDAT xdata$x
; File d:\siteview\ecc_common\base\funcgeneral.cpp
xdata$x	SEGMENT
$T69240	DD	0ffffffffH
	DD	FLAT:$L69197
	DD	00H
	DD	FLAT:$L69198
	DD	0ffffffffH
	DD	FLAT:$L69199
	DD	02H
	DD	FLAT:$L69200
$T69230	DD	019930520H
	DD	04H
	DD	FLAT:$T69240
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ?SortList@@YAXAAVCStringList@@0H@Z
_TEXT	SEGMENT
_Val$60820 = -32					; size = 4
_Key$60819 = -28					; size = 4
_Count$ = -24						; size = 4
_s2$60826 = -20						; size = 4
_s1$60825 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_r$ = 8							; size = 4
_KeyList$ = 8						; size = 4
_ValList$ = 12						; size = 4
_bAsc$ = 16						; size = 4
?SortList@@YAXAAVCStringList@@0H@Z PROC NEAR		; SortList, COMDAT

; 527  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?SortList@@YAXAAVCStringList@@0H@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 14	 sub	 esp, 20			; 00000014H
  00018	53		 push	 ebx

; 528  : 	int Count = KeyList.GetCount();

  00019	8b 5c 24 28	 mov	 ebx, DWORD PTR _KeyList$[esp+32]
  0001d	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00020	55		 push	 ebp
  00021	56		 push	 esi

; 529  : 
; 530  : 	_rec *r = new _rec[Count*sizeof(_rec)];

  00022	8d 34 c5 00 00
	00 00		 lea	 esi, DWORD PTR [eax*8]
  00029	89 44 24 14	 mov	 DWORD PTR _Count$[esp+44], eax
  0002d	8d 04 f5 04 00
	00 00		 lea	 eax, DWORD PTR [esi*8+4]
  00034	57		 push	 edi
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0003b	83 c4 04	 add	 esp, 4
  0003e	85 c0		 test	 eax, eax
  00040	74 20		 je	 SHORT $L69191
  00042	68 00 00 00 00	 push	 OFFSET FLAT:??1_rec@@QAE@XZ
  00047	68 00 00 00 00	 push	 OFFSET FLAT:??0_rec@@QAE@XZ
  0004c	56		 push	 esi
  0004d	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00050	6a 08		 push	 8
  00052	57		 push	 edi
  00053	89 30		 mov	 DWORD PTR [eax], esi
  00055	e8 00 00 00 00	 call	 ??_L@YGXPAXIHP6EX0@Z1@Z
  0005a	8b ef		 mov	 ebp, edi
  0005c	89 6c 24 34	 mov	 DWORD PTR _r$[esp+44], ebp
  00060	eb 0c		 jmp	 SHORT $L69192
$L69191:
  00062	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _r$[esp+44], 0
  0006a	8b 6c 24 34	 mov	 ebp, DWORD PTR _r$[esp+44]
$L69192:

; 531  : 
; 532  : 	POSITION posKey = KeyList.FindIndex(0);

  0006e	6a 00		 push	 0
  00070	8b cb		 mov	 ecx, ebx
  00072	e8 00 00 00 00	 call	 ?FindIndex@CStringList@@QBEPAU__POSITION@@H@Z ; CStringList::FindIndex

; 533  : 	POSITION posVal = ValList.FindIndex(0);

  00077	8b 4c 24 38	 mov	 ecx, DWORD PTR _ValList$[esp+44]
  0007b	6a 00		 push	 0
  0007d	8b f0		 mov	 esi, eax
  0007f	e8 00 00 00 00	 call	 ?FindIndex@CStringList@@QBEPAU__POSITION@@H@Z ; CStringList::FindIndex

; 534  : 
; 535  : 	int i=0;
; 536  : 	while(posKey && posVal)

  00084	85 f6		 test	 esi, esi
  00086	8b f8		 mov	 edi, eax
  00088	0f 84 81 00 00
	00		 je	 $L60818
  0008e	8b ff		 npad	 2
$L60817:
  00090	85 ff		 test	 edi, edi
  00092	74 77		 je	 SHORT $L69237

; 537  : 	{
; 538  : 		CString Key = KeyList.GetNext(posKey);

  00094	85 f6		 test	 esi, esi
  00096	8b c6		 mov	 eax, esi
  00098	0f 84 34 01 00
	00		 je	 $L69233
  0009e	8b 36		 mov	 esi, DWORD PTR [esi]
  000a0	83 c0 08	 add	 eax, 8
  000a3	50		 push	 eax
  000a4	8d 4c 24 18	 lea	 ecx, DWORD PTR _Key$60819[esp+52]
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z

; 539  : 		CString Val = ValList.GetNext(posVal);

  000ae	8b c7		 mov	 eax, edi
  000b0	8b 3f		 mov	 edi, DWORD PTR [edi]
  000b2	83 c0 08	 add	 eax, 8
  000b5	50		 push	 eax
  000b6	8d 4c 24 14	 lea	 ecx, DWORD PTR _Val$60820[esp+52]
  000ba	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 0
  000c2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z

; 540  : 		r[i].key = Key;

  000c8	8d 4c 24 14	 lea	 ecx, DWORD PTR _Key$60819[esp+48]
  000cc	51		 push	 ecx
  000cd	8b cd		 mov	 ecx, ebp
  000cf	c6 44 24 30 01	 mov	 BYTE PTR __$EHRec$[esp+60], 1
  000d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 541  : 		r[i].val = Val;		

  000da	8d 54 24 10	 lea	 edx, DWORD PTR _Val$60820[esp+48]
  000de	52		 push	 edx
  000df	8d 4d 04	 lea	 ecx, DWORD PTR [ebp+4]
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??4?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAEAAV01@ABV01@@Z

; 542  : 		i++;
; 543  : 	}

  000e8	8d 4c 24 10	 lea	 ecx, DWORD PTR _Val$60820[esp+48]
  000ec	83 c5 08	 add	 ebp, 8
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  000f5	8d 4c 24 14	 lea	 ecx, DWORD PTR _Key$60819[esp+48]
  000f9	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  00101	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00107	85 f6		 test	 esi, esi
  00109	75 85		 jne	 SHORT $L60817
$L69237:

; 539  : 		CString Val = ValList.GetNext(posVal);

  0010b	8b 6c 24 34	 mov	 ebp, DWORD PTR _r$[esp+44]
$L60818:

; 544  : 
; 545  : 	//
; 546  : 	_Sort(r,Count,bAsc);

  0010f	8b 44 24 3c	 mov	 eax, DWORD PTR _bAsc$[esp+44]
  00113	8b 7c 24 18	 mov	 edi, DWORD PTR _Count$[esp+48]
  00117	50		 push	 eax
  00118	57		 push	 edi
  00119	55		 push	 ebp
  0011a	e8 00 00 00 00	 call	 ?_Sort@@YAXPAU_rec@@HH@Z ; _Sort
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 547  : 
; 548  : 	KeyList.RemoveAll();

  00122	8b cb		 mov	 ecx, ebx
  00124	e8 00 00 00 00	 call	 ?RemoveAll@CStringList@@QAEXXZ ; CStringList::RemoveAll

; 549  : 	ValList.RemoveAll();

  00129	8b 4c 24 38	 mov	 ecx, DWORD PTR _ValList$[esp+44]
  0012d	e8 00 00 00 00	 call	 ?RemoveAll@CStringList@@QAEXXZ ; CStringList::RemoveAll

; 550  : 
; 551  : 	for(int j=0; j<Count; j++)

  00132	85 ff		 test	 edi, edi
  00134	7e 68		 jle	 SHORT $L60824
  00136	8b f5		 mov	 esi, ebp
  00138	8b ef		 mov	 ebp, edi
  0013a	8d 9b 00 00 00
	00		 npad	 6
$L60822:

; 552  : 	{
; 553  : 		CString s1 = r[j].key;

  00140	56		 push	 esi
  00141	8d 4c 24 24	 lea	 ecx, DWORD PTR _s1$60825[esp+52]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z

; 554  : 		CString s2 = r[j].val;

  0014b	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0014e	57		 push	 edi
  0014f	8d 4c 24 20	 lea	 ecx, DWORD PTR _s2$60826[esp+52]
  00153	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+60], 2
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@ABV01@@Z

; 555  : 
; 556  : 		KeyList.AddTail(r[j].key);

  00161	56		 push	 esi
  00162	8b cb		 mov	 ecx, ebx
  00164	c6 44 24 30 03	 mov	 BYTE PTR __$EHRec$[esp+60], 3
  00169	e8 00 00 00 00	 call	 ?AddTail@CStringList@@QAEPAU__POSITION@@ABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringList::AddTail

; 557  : 		ValList.AddTail(r[j].val);

  0016e	8b 4c 24 38	 mov	 ecx, DWORD PTR _ValList$[esp+44]
  00172	57		 push	 edi
  00173	e8 00 00 00 00	 call	 ?AddTail@CStringList@@QAEPAU__POSITION@@ABV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@@Z ; CStringList::AddTail

; 558  : 	}

  00178	8d 4c 24 1c	 lea	 ecx, DWORD PTR _s2$60826[esp+48]
  0017c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00182	8d 4c 24 20	 lea	 ecx, DWORD PTR _s1$60825[esp+48]
  00186	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+56], -1
  0018e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
  00194	83 c6 08	 add	 esi, 8
  00197	4d		 dec	 ebp
  00198	75 a6		 jne	 SHORT $L60822

; 550  : 
; 551  : 	for(int j=0; j<Count; j++)

  0019a	8b 6c 24 34	 mov	 ebp, DWORD PTR _r$[esp+44]
$L60824:

; 559  : 
; 560  : 	delete[] r;

  0019e	85 ed		 test	 ebp, ebp
  001a0	74 1d		 je	 SHORT $L69195
  001a2	8b 4d fc	 mov	 ecx, DWORD PTR [ebp-4]
  001a5	68 00 00 00 00	 push	 OFFSET FLAT:??1_rec@@QAE@XZ
  001aa	8d 75 fc	 lea	 esi, DWORD PTR [ebp-4]
  001ad	51		 push	 ecx
  001ae	6a 08		 push	 8
  001b0	55		 push	 ebp
  001b1	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  001b6	56		 push	 esi
  001b7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001bc	83 c4 04	 add	 esp, 4
$L69195:

; 561  : }

  001bf	8b 4c 24 24	 mov	 ecx, DWORD PTR __$EHRec$[esp+48]
  001c3	5f		 pop	 edi
  001c4	5e		 pop	 esi
  001c5	5d		 pop	 ebp
  001c6	5b		 pop	 ebx
  001c7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  001ce	83 c4 20	 add	 esp, 32			; 00000020H
  001d1	c3		 ret	 0
$L69233:

; 537  : 	{
; 538  : 		CString Key = KeyList.GetNext(posKey);

  001d2	e9 00 00 00 00	 jmp	 ?AfxThrowInvalidArgException@@YGXXZ ; AfxThrowInvalidArgException
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69197:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _Key$60819[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L69198:
  00009	8d 4d e0	 lea	 ecx, DWORD PTR _Val$60820[ebp]
  0000c	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L69199:
  00012	8d 4d f0	 lea	 ecx, DWORD PTR _s1$60825[ebp]
  00015	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
$L69200:
  0001b	8d 4d ec	 lea	 ecx, DWORD PTR _s2$60826[ebp]
  0001e	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@QAE@XZ
__ehhandler$?SortList@@YAXAAVCStringList@@0H@Z:
  00024	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69230
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SortList@@YAXAAVCStringList@@0H@Z ENDP			; SortList
PUBLIC	?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z PROC NEAR ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _nElements$[esp-4]
  00004	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	76 0c		 jbe	 SHORT $L69248
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	5e		 pop	 esi

; 245  : 	}

  00017	c2 04 00	 ret	 4

; 244  : 		return( AllocateBytes( nElements*sizeof( T ) ) );

$L69248:
  0001a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0001d	89 06		 mov	 DWORD PTR [esi], eax
  0001f	5e		 pop	 esi

; 245  : 	}

  00020	c2 04 00	 ret	 4
?Allocate@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAEPADI@Z ENDP ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:NEAR
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	56		 push	 esi

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Istr$[esp]
  00005	8b 06		 mov	 eax, DWORD PTR [esi]
  00007	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000a	6a 0a		 push	 10			; 0000000aH
  0000c	03 ce		 add	 ecx, esi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00014	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Str$[esp]
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	5e		 pop	 esi

; 530  : 	}

  00024	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
EXTRN	__imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:NEAR
; Function compile flags: /Ogty
;	COMDAT ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC NEAR ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 528  : 	{	// get characters into string, discard newline

  00000	56		 push	 esi

; 529  : 	return (getline(_Istr, _Str, _Istr.widen('\n')));

  00001	8b 74 24 08	 mov	 esi, DWORD PTR __Istr$[esp]
  00005	8b 06		 mov	 eax, DWORD PTR [esi]
  00007	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000a	6a 0a		 push	 10			; 0000000aH
  0000c	03 ce		 add	 ecx, esi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00014	8b 4c 24 0c	 mov	 ecx, DWORD PTR __Str$[esp]
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@_W@Z ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	5e		 pop	 esi

; 530  : 	}

  00024	c3		 ret	 0
??$getline@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::getline<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
PUBLIC	?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableA@12:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
$T69341	DD	0ffffffffH
	DD	FLAT:$L69262
	DD	00H
	DD	FLAT:$L69263
$T69336	DD	019930520H
	DD	02H
	DD	FLAT:$T69341
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
_pszBufferA$ = -280					; size = 132
_pszNameA$ = -148					; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWFake, COMDAT

; 159  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	56		 push	 esi
  00021	89 84 24 0c 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+284], eax
  00028	57		 push	 edi

; 160  : 	ULONG nSizeA;
; 161  : 	ULONG nSizeW;
; 162  : 	CTempBuffer<char> pszBufferA;

  00029	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR _pszBufferA$[esp+288], 0

; 163  : 	CW2A pszNameA(pszName);

  00031	8d 84 24 90 00
	00 00		 lea	 eax, DWORD PTR _pszNameA$[esp+292]
  00038	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR __$EHRec$[esp+296], 0
  00043	89 84 24 8c 00
	00 00		 mov	 DWORD PTR _pszNameA$[esp+288], eax
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00050	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR _pszName$[esp+284]
  00057	50		 push	 eax
  00058	51		 push	 ecx
  00059	8d 8c 24 94 00
	00 00		 lea	 ecx, DWORD PTR _pszNameA$[esp+296]
  00060	e8 00 00 00 00	 call	 ?Init@?$CW2AEX@$0IA@@ATL@@AAEXPB_WI@Z ; ATL::CW2AEX<128>::Init

; 164  : 
; 165  : 	nSizeA = ::GetEnvironmentVariableA(pszNameA, NULL, 0);

  00065	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR _pszNameA$[esp+288]
  0006c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetEnvironmentVariableA@12
  00072	6a 00		 push	 0
  00074	6a 00		 push	 0
  00076	52		 push	 edx
  00077	c6 84 24 28 01
	00 00 01	 mov	 BYTE PTR __$EHRec$[esp+308], 1
  0007f	ff d7		 call	 edi
  00081	8b f0		 mov	 esi, eax

; 166  : 	if (nSizeA == 0)

  00083	85 f6		 test	 esi, esi
  00085	75 38		 jne	 SHORT $L26803

; 167  : 		return 0;

  00087	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _pszNameA$[esp+288]
  0008e	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _pszNameA$[esp+292]
  00095	3b c1		 cmp	 eax, ecx
  00097	74 0a		 je	 SHORT $L69280
  00099	50		 push	 eax
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000a0	83 c4 04	 add	 esp, 4
$L69280:
  000a3	8b 44 24 08	 mov	 eax, DWORD PTR _pszBufferA$[esp+288]
  000a7	8d 54 24 0c	 lea	 edx, DWORD PTR _pszBufferA$[esp+292]
  000ab	3b c2		 cmp	 eax, edx
  000ad	74 09		 je	 SHORT $L69284
  000af	8d 4c 24 08	 lea	 ecx, DWORD PTR _pszBufferA$[esp+288]
  000b3	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L69284:
  000b8	33 c0		 xor	 eax, eax
  000ba	e9 cd 00 00 00	 jmp	 $L26744
$L26803:

; 168  : 
; 169  : 	pszBufferA.Allocate(nSizeA*2);

  000bf	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  000c2	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000c7	76 0c		 jbe	 SHORT $L69296
  000c9	50		 push	 eax
  000ca	8d 4c 24 0c	 lea	 ecx, DWORD PTR _pszBufferA$[esp+292]
  000ce	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
  000d3	eb 08		 jmp	 SHORT $L69297
$L69296:
  000d5	8d 44 24 0c	 lea	 eax, DWORD PTR _pszBufferA$[esp+292]
  000d9	89 44 24 08	 mov	 DWORD PTR _pszBufferA$[esp+288], eax
$L69297:

; 170  : 	::GetEnvironmentVariableA(pszNameA, pszBufferA, nSizeA);

  000dd	8b 4c 24 08	 mov	 ecx, DWORD PTR _pszBufferA$[esp+288]
  000e1	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR _pszNameA$[esp+288]
  000e8	56		 push	 esi
  000e9	51		 push	 ecx
  000ea	52		 push	 edx
  000eb	ff d7		 call	 edi

; 171  : 
; 172  : 	nSizeW = ::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, NULL, 0);

  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  000f3	8b 4c 24 08	 mov	 ecx, DWORD PTR _pszBufferA$[esp+288]
  000f7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__MultiByteToWideChar@24
  000fd	6a 00		 push	 0
  000ff	6a 00		 push	 0
  00101	6a ff		 push	 -1
  00103	51		 push	 ecx
  00104	6a 00		 push	 0
  00106	50		 push	 eax
  00107	ff d7		 call	 edi
  00109	8b f0		 mov	 esi, eax

; 173  : 	if (nSize == 0)

  0010b	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR _nSize$[esp+284]
  00112	85 c0		 test	 eax, eax
  00114	75 28		 jne	 SHORT $L26805

; 174  : 		return nSizeW;

  00116	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _pszNameA$[esp+288]
  0011d	8d 94 24 90 00
	00 00		 lea	 edx, DWORD PTR _pszNameA$[esp+292]
  00124	3b c2		 cmp	 eax, edx
  00126	74 0a		 je	 SHORT $L69314
  00128	50		 push	 eax
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0012f	83 c4 04	 add	 esp, 4
$L69314:
  00132	8b 4c 24 08	 mov	 ecx, DWORD PTR _pszBufferA$[esp+288]
  00136	8d 44 24 0c	 lea	 eax, DWORD PTR _pszBufferA$[esp+292]
  0013a	3b c8		 cmp	 ecx, eax
  0013c	eb 41		 jmp	 SHORT $L69340
$L26805:

; 175  : 	ATLASSERT(nSize >= nSizeW);
; 176  : 	::MultiByteToWideChar(_AtlGetConversionACP(), 0, pszBufferA, -1, pszBuffer, nSizeW);

  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00144	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR _pszBuffer$[esp+284]
  0014b	8b 54 24 08	 mov	 edx, DWORD PTR _pszBufferA$[esp+288]
  0014f	56		 push	 esi
  00150	51		 push	 ecx
  00151	6a ff		 push	 -1
  00153	52		 push	 edx
  00154	6a 00		 push	 0
  00156	50		 push	 eax
  00157	ff d7		 call	 edi

; 177  : 
; 178  : 	return nSizeW;

  00159	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR _pszNameA$[esp+288]
  00160	8d 8c 24 90 00
	00 00		 lea	 ecx, DWORD PTR _pszNameA$[esp+292]
  00167	3b c1		 cmp	 eax, ecx
  00169	74 0a		 je	 SHORT $L69329
  0016b	50		 push	 eax
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00172	83 c4 04	 add	 esp, 4
$L69329:
  00175	8b 44 24 08	 mov	 eax, DWORD PTR _pszBufferA$[esp+288]
  00179	8d 54 24 0c	 lea	 edx, DWORD PTR _pszBufferA$[esp+292]
  0017d	3b c2		 cmp	 eax, edx
$L69340:
  0017f	74 09		 je	 SHORT $L69333
  00181	8d 4c 24 08	 lea	 ecx, DWORD PTR _pszBufferA$[esp+288]
  00185	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L69333:
  0018a	8b c6		 mov	 eax, esi
$L26744:

; 179  : }

  0018c	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+288]
  00193	5f		 pop	 edi
  00194	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0019b	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+284]
  001a2	5e		 pop	 esi
  001a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a8	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  001ae	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69262:
  00000	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _pszBufferA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
$L69263:
  0000b	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _pszNameA$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$CW2AEX@$0IA@@ATL@@QAE@XZ ; ATL::CW2AEX<128>::~CW2AEX<128>
__ehhandler$?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69336
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWFake
EXTRN	__imp__GetEnvironmentVariableW@12:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z
_TEXT	SEGMENT
_pszName$ = 8						; size = 4
_pszBuffer$ = 12					; size = 4
_nSize$ = 16						; size = 4
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z PROC NEAR ; ATL::GetEnvironmentVariableWThunk, COMDAT

; 184  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetEnvironmentVariableW), 
; 185  : 		GetEnvironmentVariableWFake, ::GetEnvironmentVariableW);

  00000	f6 05 00 00 00
	00 01		 test	 BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00007	75 19		 jne	 SHORT $L69359
  00009	83 0d 00 00 00
	00 01		 or	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	24 01		 and	 al, 1
  0001b	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  00020	eb 05		 jmp	 SHORT $L69351
$L69359:
  00022	a0 00 00 00 00	 mov	 al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L69351:
  00027	84 c0		 test	 al, al
  00029	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?GetEnvironmentVariableWFake@ATL@@YGKPB_WPA_WK@Z ; ATL::GetEnvironmentVariableWFake
  0002e	75 05		 jne	 SHORT $L69354
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetEnvironmentVariableW@12
$L69354:
  00035	50		 push	 eax
  00036	68 14 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 186  : 
; 187  : 	return _strthunks.pfnGetEnvironmentVariableW(pszName, pszBuffer, nSize);

  00041	ff 25 14 00 00
	00		 jmp	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+20
?GetEnvironmentVariableWThunk@ATL@@YGKPB_WPA_WK@Z ENDP	; ATL::GetEnvironmentVariableWThunk
_TEXT	ENDS
PUBLIC	?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z	; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExA@20:NEAR
;	COMDAT xdata$x
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\atlalloc.h
xdata$x	SEGMENT
$T69403	DD	0ffffffffH
	DD	FLAT:$L69365
$T69399	DD	019930520H
	DD	01H
	DD	FLAT:$T69403
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File d:\program files\microsoft visual studio .net 2003\vc7\atlmfc\include\cstringt.h
xdata$x	ENDS
;	COMDAT ?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
_pszA$ = -148						; size = 132
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWFake, COMDAT

; 224  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	53		 push	 ebx
  00021	55		 push	 ebp
  00022	89 84 24 8c 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+156], eax
  00029	56		 push	 esi

; 225  : 	int nLengthA;
; 226  : 	CTempBuffer<char> pszA;

  0002a	33 c0		 xor	 eax, eax
  0002c	57		 push	 edi
  0002d	89 44 24 10	 mov	 DWORD PTR _pszA$[esp+164], eax

; 227  : 
; 228  : 	nLengthA = ::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, NULL, 0, NULL, NULL);

  00031	8b bc 24 b4 00
	00 00		 mov	 edi, DWORD PTR _nLength$[esp+160]
  00038	8b 9c 24 b0 00
	00 00		 mov	 ebx, DWORD PTR _pszSrc$[esp+160]
  0003f	50		 push	 eax
  00040	50		 push	 eax
  00041	50		 push	 eax
  00042	50		 push	 eax
  00043	57		 push	 edi
  00044	53		 push	 ebx
  00045	50		 push	 eax
  00046	89 84 24 bc 00
	00 00		 mov	 DWORD PTR __$EHRec$[esp+200], eax
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00053	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__WideCharToMultiByte@32
  00059	50		 push	 eax
  0005a	ff d5		 call	 ebp
  0005c	8b f0		 mov	 esi, eax

; 229  : 	pszA.Allocate(nLengthA);

  0005e	81 fe 80 00 00
	00		 cmp	 esi, 128		; 00000080H
  00064	76 0c		 jbe	 SHORT $L69382
  00066	56		 push	 esi
  00067	8d 4c 24 14	 lea	 ecx, DWORD PTR _pszA$[esp+168]
  0006b	e8 00 00 00 00	 call	 ?AllocateHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXI@Z ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::AllocateHeap
  00070	eb 08		 jmp	 SHORT $L69383
$L69382:
  00072	8d 44 24 14	 lea	 eax, DWORD PTR _pszA$[esp+168]
  00076	89 44 24 10	 mov	 DWORD PTR _pszA$[esp+164], eax
$L69383:

; 230  : 	::WideCharToMultiByte(_AtlGetConversionACP(), 0, pszSrc, nLength, pszA, nLengthA, NULL, NULL);

  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pfnGetThreadACP@ATL@@3P6GIXZA ; ATL::g_pfnGetThreadACP
  00080	8b 4c 24 10	 mov	 ecx, DWORD PTR _pszA$[esp+164]
  00084	6a 00		 push	 0
  00086	6a 00		 push	 0
  00088	56		 push	 esi
  00089	51		 push	 ecx
  0008a	57		 push	 edi
  0008b	53		 push	 ebx
  0008c	6a 00		 push	 0
  0008e	50		 push	 eax
  0008f	ff d5		 call	 ebp

; 231  : 
; 232  : 	if (nLength == -1)

  00091	83 ff ff	 cmp	 edi, -1
  00094	75 02		 jne	 SHORT $L26861

; 233  : 		nLengthA = -1;

  00096	0b f7		 or	 esi, edi
$L26861:

; 234  : 
; 235  : 	return ::GetStringTypeExA(lcid, dwInfoType, pszA, nLengthA, pwCharType);

  00098	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR _pwCharType$[esp+160]
  0009f	8b 44 24 10	 mov	 eax, DWORD PTR _pszA$[esp+164]
  000a3	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR _dwInfoType$[esp+160]
  000aa	52		 push	 edx
  000ab	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR _lcid$[esp+164]
  000b2	56		 push	 esi
  000b3	50		 push	 eax
  000b4	51		 push	 ecx
  000b5	52		 push	 edx
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetStringTypeExA@20
  000bc	8b 4c 24 10	 mov	 ecx, DWORD PTR _pszA$[esp+164]
  000c0	8b f0		 mov	 esi, eax
  000c2	8d 44 24 14	 lea	 eax, DWORD PTR _pszA$[esp+168]
  000c6	3b c8		 cmp	 ecx, eax
  000c8	74 09		 je	 SHORT $L69400
  000ca	8d 4c 24 10	 lea	 ecx, DWORD PTR _pszA$[esp+164]
  000ce	e8 00 00 00 00	 call	 ?FreeHeap@?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@AAEXXZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::FreeHeap
$L69400:

; 236  : }

  000d3	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR __$EHRec$[esp+164]
  000da	5f		 pop	 edi
  000db	8b c6		 mov	 eax, esi
  000dd	5e		 pop	 esi
  000de	5d		 pop	 ebp
  000df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e6	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+152]
  000ed	5b		 pop	 ebx
  000ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f3	81 c4 94 00 00
	00		 add	 esp, 148		; 00000094H
  000f9	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L69365:
  00000	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _pszA$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$CTempBuffer@D$0IA@VCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CTempBuffer<char,128,ATL::CCRTAllocator>::~CTempBuffer<char,128,ATL::CCRTAllocator>
__ehhandler$?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T69399
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ENDP		; ATL::GetStringTypeExWFake
EXTRN	__imp__GetStringTypeExW@20:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z
_TEXT	SEGMENT
_lcid$ = 8						; size = 4
_dwInfoType$ = 12					; size = 4
_pszSrc$ = 16						; size = 4
_nLength$ = 20						; size = 4
_pwCharType$ = 24					; size = 4
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z PROC NEAR	; ATL::GetStringTypeExWThunk, COMDAT

; 241  : 	_AtlInstallStringThunk(reinterpret_cast<void**>(&_strthunks.pfnGetStringTypeExW), GetStringTypeExWFake, ::GetStringTypeExW);

  00000	f6 05 00 00 00
	00 01		 test	 BYTE PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00007	75 19		 jne	 SHORT $L69421
  00009	83 0d 00 00 00
	00 01		 or	 DWORD PTR ??_B?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@51, 1
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersion@0
  00016	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00019	24 01		 and	 al, 1
  0001b	a2 00 00 00 00	 mov	 BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA, al ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
  00020	eb 05		 jmp	 SHORT $L69413
$L69421:
  00022	a0 00 00 00 00	 mov	 al, BYTE PTR ?s_bWin9x@?1??_AtlInstallStringThunk@ATL@@YAXPAPAXPAX1@Z@4_NA ; `ATL::_AtlInstallStringThunk'::`2'::s_bWin9x
$L69413:
  00027	84 c0		 test	 al, al
  00029	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?GetStringTypeExWFake@ATL@@YGHKKPB_WHPAG@Z ; ATL::GetStringTypeExWFake
  0002e	75 05		 jne	 SHORT $L69416
  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__GetStringTypeExW@20
$L69416:
  00035	50		 push	 eax
  00036	68 04 00 00 00	 push	 OFFSET FLAT:?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedExchange@8

; 242  : 
; 243  : 	return _strthunks.pfnGetStringTypeExW(lcid, dwInfoType, pszSrc, nLength, pwCharType);

  00041	ff 25 04 00 00
	00		 jmp	 DWORD PTR ?_strthunks@ATL@@3U_AtlStringThunks@1@A+4
?GetStringTypeExWThunk@ATL@@YGHKKPB_WHPAG@Z ENDP	; ATL::GetStringTypeExWThunk
_TEXT	ENDS
EXTRN	_atexit:NEAR
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Ogty
; File d:\siteview\ecc_common\base\funcgeneral.h
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 127  : static std::string  gRoot_path="";

  00000	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_gRoot_path
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
  00010	68 00 00 00 00	 push	 OFFSET FLAT:_$E2
  00015	e8 00 00 00 00	 call	 _atexit
  0001a	59		 pop	 ecx
  0001b	c3		 ret	 0
_$E1	ENDP
; Function compile flags: /Ogty
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_gRoot_path
  00005	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_$E2	ENDP
text$yd	ENDS
_BSS	SEGMENT
_gRoot_path DB	01cH DUP (?)
_BSS	ENDS
END
